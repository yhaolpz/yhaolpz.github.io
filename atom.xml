<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Great hopes make great man</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yhaowa.gitee.io/"/>
  <updated>2020-03-22T14:49:53.962Z</updated>
  <id>http://yhaowa.gitee.io/</id>
  
  <author>
    <name>Ahab</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Framework &amp; startActivity</title>
    <link href="http://yhaowa.gitee.io/a608ff50/"/>
    <id>http://yhaowa.gitee.io/a608ff50/</id>
    <published>2019-09-15T11:42:33.000Z</published>
    <updated>2020-03-22T14:49:53.962Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>源码基于 <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:" target="_blank" rel="noopener">Android 10</a></p></blockquote><a id="more"></a><p><img src="../img/startActivity-Android10.jpg" alt="Android 10.0 startActivity 流程图"><br><a href="../img/startActivity-Android10.jpg">大图</a></p><p>此图着重提炼了生命周期的部分，Android 10 中 新增了 ActivityTaskManager ，专门用于管理 Activity，接替了 ActivityManager 的一部分工作</p><h3 id="理解-Instrumentation"><a href="#理解-Instrumentation" class="headerlink" title="理解 Instrumentation"></a>理解 Instrumentation</h3><p>Activity 首先会通过 Instrumentation 去调用，Instrumentation 中包含 callActivityOnCreate、callActivityOnPause、callApplicationOnCreate 等调用，具有强大的跟踪 Activity 及 Application 生命周期的功能，所以也被作为应用测试框架中的基类使用。一个进程有一个 ActivityThread 对象，ActivityThread 对象持有一个 Instrumentation 对象，每个 Activity 都持有 Instrumentation</p><h3 id="IPC-发生在何处？"><a href="#IPC-发生在何处？" class="headerlink" title="IPC 发生在何处？"></a>IPC 发生在何处？</h3><p>在 Instrumentation 中通过 IActivityTaskManager.aidl 接口由 App 进程进入到 system_server 进程；在 ClientTransaction 中通过 IApplicationThread.aidl 接口由 system_server 回到 App 进程</p><h3 id="Activity-栈是如何管理的？"><a href="#Activity-栈是如何管理的？" class="headerlink" title="Activity 栈是如何管理的？"></a>Activity 栈是如何管理的？</h3><p>ActivityRecord：Activity 以 ActivityRecord 形式记录，一个 ActivityRecord 对应一个 Activity 实例<br>TaskRecord：这个才是一个真正的 Activity 栈，内部持有 ArrayList&lt; ActivityRecord &gt;，记录当前栈中所有的 Activity<br>ActivityStack：负责管理 Activity 栈，存放了多个 TaskRecord</p><h3 id="何处读取-manifest-中-Activity-节点的启动模式等配置"><a href="#何处读取-manifest-中-Activity-节点的启动模式等配置" class="headerlink" title="何处读取 manifest 中 Activity 节点的启动模式等配置"></a>何处读取 manifest 中 Activity 节点的启动模式等配置</h3><p><img src="../img/startActivity-Android10-2.jpg" alt="读取 manifest 配置图"></p><p>如图通过 PackageManagerService#resolveIntentInternal 方法返回 ResolveInfo ，ResolveInfo 包括 ActivityInfo、ServiceInfo、ProviderInfo 等信息，此调用已经处于 system_server 进程了，所以并不是 IPC，PackageManagerService 主要负责解析 AndroidManifest.xml、扫描本地 apk 目录、管理 App 安装删除等</p><h3 id="何处检测-Activity-是否在-manifest-注册？"><a href="#何处检测-Activity-是否在-manifest-注册？" class="headerlink" title="何处检测 Activity 是否在 manifest 注册？"></a>何处检测 Activity 是否在 manifest 注册？</h3><p>关键代码在 ActivityStarter#startActivity 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">    <span class="comment">// Also the end of the line.</span></span><br><span class="line">    err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>aInfo 就是 ActivityInfo ，而 ActivityInfo 为空导致后续报错返回。那 aInfo 是从哪来的呢？当然就是通过 PackageManagerService#resolveIntentInternal 方法解析出来的。然后在 Instrumentation#checkStartActivityResult 方法中检测到 ActivityManager.START_CLASS_NOT_FOUND 返回值后，就抛出 “Unable to find explicit activity class {xxx}; have you declared this activity in your AndroidManifest.xml? “异常了 </p><h3 id="为什么单独配置-taskAffinity-不会生效"><a href="#为什么单独配置-taskAffinity-不会生效" class="headerlink" title="为什么单独配置 taskAffinity 不会生效"></a>为什么单独配置 taskAffinity 不会生效</h3><p>关键代码在 ActivityStarter#startActivityUnchecked 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mStartActivity.resultTo == <span class="keyword">null</span> &amp;&amp; mInTask == <span class="keyword">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">              &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">       newTask = <span class="keyword">true</span>;</span><br><span class="line">       result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">       result = setTaskFromSourceRecord();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">       result = setTaskFromInTask();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       result = setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只有 mLaunchFlags 标记为 FLAG_ACTIVITY_NEW_TASK 才会去创建一个新的 Activity 栈即 TaskRecord，而系统并没有对单独配置一个 taskAffinity 的情况做处理。那在 AndroidManifest.xml 中配置的 launchMode 是在何处处理，并反应到 mLaunchFlags 中的呢？<br>ActivityStarter#startActivityUnchecked 方法中调用了 ActivityStarter#computeLaunchingTaskFlags 方法，该方法中配置 mLaunchFlags 的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span> &amp;&amp; mInTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Slog.w(TAG, <span class="string">"startActivity called from non-Activity context; forcing "</span> +</span><br><span class="line">                     <span class="string">"Intent.FLAG_ACTIVITY_NEW_TASK for: "</span> + mIntent);</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 LAUNCH_SINGLE_INSTANCE 模式会在一个新的栈中启动等我们早已熟知的规则</p><h3 id="理解-ClientTransactionItem-与-ActivityLifecycleItem"><a href="#理解-ClientTransactionItem-与-ActivityLifecycleItem" class="headerlink" title="理解 ClientTransactionItem 与 ActivityLifecycleItem"></a>理解 ClientTransactionItem 与 ActivityLifecycleItem</h3><p>ClientLifecycleManager 可以将一或多个生命周期事件组合到一起作为一个事务即 ClientTransaction 来执行，startActivity 时新 Activity 的 onCreate、onStart、onResume 事件就是存放在一个事务中被执行的</p><p>startActivity 时新 Activity 的 onCreate 事件存放在 ClientTransaction 的 List &lt; ClientTransactionItem &gt; 类型的成员变量中，载体为 LaunchActivityItem。 LaunchActivityItem 也是 ClientTransactionItem 的子类，即启动 Activity 事件。另外还有 NewIntentItem（触发 onNewIntent 回调）、ActivityResultItem（触发 onActivityResult）、ConfigurationChangeItem（触发 onConfigurationChanged 回调）等事件</p><p>startActivity 时新 Activity 的 onResume 事件存放在 ClientTransaction 的 ActivityLifecycleItem 类型的变量成员变量中，这个变量也表示最终的生命周期状态，载体为 ResumeActivityItem。ActivityLifecycleItem 也是 ClientTransactionItem 的一个子类</p><h3 id="为什么不能在-Activity-的-onPause-方法中做耗时操作？"><a href="#为什么不能在-Activity-的-onPause-方法中做耗时操作？" class="headerlink" title="为什么不能在 Activity 的 onPause 方法中做耗时操作？"></a>为什么不能在 Activity 的 onPause 方法中做耗时操作？</h3><p>ClientTransaction 为 Parcelable 数据，会通过 IApplicationThread.aidl 的 scheduleTransaction 方法发送到 App 端，然后加入到主线程 ActivityThread.H 消息队列中等待执行。startActivity 时会依次发送前一个 Activity 的 pause 和新 Activity 的 resume 事务，然后这两个事务会通过 ActivityThread.H 依次执行，所以不能在 Activity 的 onPause 方法中做耗时操作，因为只有 onPause 方法执行完后，下一个 Activity 的生命周期事件才能被执行，否则会阻塞新界面显示</p><h3 id="activity-实例在何处创建？"><a href="#activity-实例在何处创建？" class="headerlink" title="activity 实例在何处创建？"></a>activity 实例在何处创建？</h3><p>在 ActivityThread#performLaunchActivity 方法中，会通过 Instrumentation#newActivity 方法创建 Activity 的实例对象，随后就调用了 Instrumentation#callActivityOnCreate 方法回调 Activity 的 onCreate 方法</p><h3 id="Launcher-中点击图标启动-App"><a href="#Launcher-中点击图标启动-App" class="headerlink" title="Launcher 中点击图标启动 App"></a>Launcher 中点击图标启动 App</h3><p>Launcher 中点击图标启动同样是调用 startActivity 方法，但需要创建进程，关键代码在 ActivityStackSupervisor#startSpecificActivityLocked 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowProcessController wpc =</span><br><span class="line">        mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"><span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">     <span class="comment">//判断进程存在，继续启动</span></span><br><span class="line">     realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程不存在，创建进程</span></span><br><span class="line"><span class="keyword">final</span> Message msg = PooledLambda.obtainMessage(</span><br><span class="line">        ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,</span><br><span class="line">        r.info.applicationInfo, knownToBeDead, <span class="string">"activity"</span>, r.intent.getComponent());</span><br><span class="line">mService.mH.sendMessage(msg);</span><br></pre></td></tr></table></figure><p><img src="../img/startActivity-Android10-3.jpg" alt="startProcess 流程图"></p><p>与 zygote 进程通信采取了 Socket 方式，为什么不使用更安全、数据只需拷贝一次的 binder 呢？zygote 作为 Android 的受精卵进程，通过 fork 方法创建进程，而 fork 是不允许多线程的，否则会因为 Copy-on-Write 机制导致死锁，而 binder 正是基于多线程运行的</p><p>在 ProcessList#startProcessLocked 方法中，传入了值为 “android.app.ActivityThread” 的 entryPoint 参数，后续会透传给 zygote 进程，zygote fork 新进程成功后，新进程的 ActivityThread#main 函数会被调用，即 App 真正的启动入口</p><p><img src="../img/startActivity-Android10-4.jpg" alt="ActivityThread.main 流程图"><br><a href="../img/startActivity-Android10-4.jpg">大图</a></p><p>在 ActivityManagerService#attachApplicationLocked 方法中执行了两个关键逻辑，一是通过 IApplicationThread 回到 App 进程中创建 Application 实例并回调 onCreate 方法；二是调用 ActivityTaskManagerService#attachApplication 方法，进一步去启动首页 Activity 。<br>启动 Activity 和普通的 startActivity 一样，都会调用到 ActivityStackSupervisor#realStartActivityLocked 方法</p><h3 id="理解-ActivityThread-与-ApplicationThread"><a href="#理解-ActivityThread-与-ApplicationThread" class="headerlink" title="理解 ActivityThread 与 ApplicationThread"></a>理解 ActivityThread 与 ApplicationThread</h3><p>ActivityThread.main() 方法是程序的启动入口，初始化了主线程 Looper，在 ActivityThread.H 中处理消息。ApplicationThread 是 ActivityThread 的内部类，实现了 IApplicationThread.aidl 接口以接受 AMS 等系统服务的回调，而大多数都是四大组件相关的任务，所以发送 Handler 消息到 ActivityThread.H ，即从 binder 线程切换到主线程中处理</p><h3 id="如何启动一个未在-manifest-中注册的-Activity-？"><a href="#如何启动一个未在-manifest-中注册的-Activity-？" class="headerlink" title="如何启动一个未在 manifest 中注册的 Activity ？"></a>如何启动一个未在 manifest 中注册的 Activity ？</h3><p>加载 manifest 信息及检测注册在 system_server 进程，即无法干扰检测逻辑。常见做法是在 manifest 中注册一个占位 Activity，在进入 system_server 进程之前把未注册的 Activity 修改为占位 Activity，然后等从 system_server 返回到 App 进程后再修改回未注册的 Activity，然后去创建、启动，也就是说需 hook 两处：</p><p>hook ActivityTaskManager：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Field singletonField = ActivityTaskManager<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">             .getDeclaredField("IActivityTaskManagerSingleton");</span><br><span class="line">singletonField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton singleton = (Singleton) singletonField.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">final</span> Object activityTaskManagerObject = singleton.get();</span><br><span class="line">final Field mInstanceField = Singleton.class.getDeclaredField("mInstance");</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object value = Proxy.newProxyInstance(ActivityTaskManager<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span></span><br><span class="line">     , new Class[]&#123;Class.forName("android.app.IActivityTaskManager")&#125;</span><br><span class="line">     , <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">                  Intent raw;</span><br><span class="line">                  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">                        index = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (!(args[index] <span class="keyword">instanceof</span> Intent)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">                  raw = (Intent) args[index];</span><br><span class="line">                  <span class="keyword">if</span> (raw.getComponent().getClassName()</span><br><span class="line">                         .equals(<span class="string">"com.yinghao.test.UnRegisterActivity"</span>)) &#123;</span><br><span class="line">                      ntent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">                      <span class="comment">//将未注册的 UnRegisterActivity 替换为占位 FakeActivity</span></span><br><span class="line">                      newIntent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.yinghao.test"</span>, </span><br><span class="line">                                   FakeActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">                      <span class="comment">//记录 UnRegisterActivity</span></span><br><span class="line">                      newIntent.putExtra(EXTRA_TARGET_INTENT, raw); </span><br><span class="line">                      args[index] = newIntent;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(activityTaskManagerObject, args);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mInstanceField.set(singleton, value);</span><br></pre></td></tr></table></figure></p><p>hook ActivityThread：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread activityThread = ActivityThread.currentActivityThread();</span><br><span class="line">Field mH1 = activityThread.getClass().getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mH1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">final</span> Handler mH = (Handler) mH1.get(activityThread);</span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField("mCallback");</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (msg.what == <span class="number">159</span>) &#123; <span class="comment">// ActivityThread.H.EXECUTE_TRANSACTION</span></span><br><span class="line">    <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">    Field mActivityCallbacksField = transaction</span><br><span class="line">               .getClass().getDeclaredField(<span class="string">"mActivityCallbacks"</span>);</span><br><span class="line">    mActivityCallbacksField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    List&lt;ClientTransactionItem&gt; clientTransactionItems = </span><br><span class="line">        (List&lt;ClientTransactionItem&gt;) mActivityCallbacksField.get(transaction);</span><br><span class="line">    <span class="keyword">if</span> (clientTransactionItems != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (ClientTransactionItem c : clientTransactionItems) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c <span class="keyword">instanceof</span> LaunchActivityItem) &#123;</span><br><span class="line">       <span class="comment">//修正 Activity 启动事件实体 LaunchActivityItem</span></span><br><span class="line">       LaunchActivityItem item = (LaunchActivityItem) c;</span><br><span class="line">       Field intentField = item.getClass().getDeclaredField(<span class="string">"mIntent"</span>);</span><br><span class="line">       intentField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Intent intent = (Intent) intentField.get(item);</span><br><span class="line">       Field mInfoField = item.getClass().getDeclaredField(<span class="string">"mInfo"</span>);</span><br><span class="line">       mInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       ActivityInfo aInfo = (ActivityInfo) mInfoField.get(item);</span><br><span class="line">       Intent realIntent = intent.getParcelableExtra(EXTRA_TARGET_INTENT);</span><br><span class="line">       <span class="keyword">if</span> (realIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//将占位 FakeActivity 改回未注册的 UnRegisterActivity</span></span><br><span class="line">         intent.setComponent(realIntent.getComponent());</span><br><span class="line">         aInfo.packageName = realIntent.getComponent().getPackageName();</span><br><span class="line">         aInfo.name = realIntent.getComponent().getClassName();</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//返回 false 正好可以让 ActivityThread 继续处理</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>实现启动未注册 Activity 的前提必然是已掌握 startActivity 流程，这也是插件化的入门，实际应用需要去兼容各个 Android 版本</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>带着问题去分析、学习源码，自然的就会聚焦出一条主线</p><div style="display: none"><br>participant Activity<br>participant Instrumentation<br>participant ActivityTaskManager<br>participant IActivityTaskManager<br>Note over IActivityTaskManager:AIDL<br>participant ActivityTaskManagerService<br>participant ActivityStartController<br>participant ActivityStarter<br>participant RootActivityContainer<br>participant ActivityStack<br>participant ActivityStackSupervisor<br>participant ClientLifecycleManager<br>participant ClientTransaction<br>participant IApplicationThread<br>Note over IApplicationThread:AIDL<br>participant ApplicationThread<br>participant ActivityThread<br>participant ActivityThread.H<br>participant TransactionExecutor<br>participant PauseActivityItem<br>participant LaunchActivityItem<br>participant ResumeActivityItem<br>Activity-&gt; Instrumentation:startActivityAsUser()<br>Instrumentation-&gt; ActivityTaskManager:execStartActivity()<br>ActivityTaskManager-&gt; IActivityTaskManager:startActivity()<br><br>IActivityTaskManager-&gt; ActivityTaskManagerService:startActivity()<br>ActivityTaskManagerService-&gt; ActivityStartController:getActivityStartController()<br>ActivityStartController-&gt; ActivityStarter:obtainStarter()<br>ActivityStarter-&gt; ActivityStarter:startActivityMayWait()<br>ActivityStarter-&gt; ActivityStarter:startActivity()<br>ActivityStarter-&gt;RootActivityContainer:startActivityUnchecked()<br>RootActivityContainer-&gt;ActivityStack:resumeFocusedStacksTopActivities()<br>ActivityStack-&gt;ActivityStack: resumeTopActivityUncheckedLocked()<br>ActivityStack–&gt;ClientLifecycleManager:startPausingLocked()<br>ClientLifecycleManager-&gt;ClientTransaction:scheduleTransaction(PauseActivityItem)<br>ClientTransaction-&gt;IApplicationThread:schedule()<br>IApplicationThread-&gt;ApplicationThread:scheduleTransaction()<br>ApplicationThread-&gt;ActivityThread:scheduleTransaction()<br>ActivityThread-&gt;ActivityThread.H:sendMessage(EXECUTE_TRANSACTION)<br>ActivityStack-&gt;ActivityStackSupervisor:resumeTopActivityInnerLocked()<br>ActivityStackSupervisor-&gt;ActivityStackSupervisor:startSpecificActivityLocked()<br>ActivityStackSupervisor-&gt;ClientLifecycleManager:realStartActivityLocked()<br>ClientLifecycleManager-&gt;ClientTransaction:scheduleTransaction(ResumeActivityItem)<br>ClientTransaction-&gt;IApplicationThread:schedule()<br>IApplicationThread-&gt;ApplicationThread:scheduleTransaction()<br>ApplicationThread-&gt;ActivityThread:scheduleTransaction()<br>ActivityThread-&gt;ActivityThread.H:sendMessage(EXECUTE_TRANSACTION)<br><br>ActivityThread.H-&gt;TransactionExecutor:handleMessage()<br>TransactionExecutor-&gt;TransactionExecutor:execute()<br>TransactionExecutor-&gt;PauseActivityItem:executeLifecycleState()<br>PauseActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handlePauseActivity()<br>ActivityThread-&gt;ActivityThread:performPauseActivity()<br>ActivityThread–&gt;Instrumentation:performPauseActivityIfNeeded()<br>Instrumentation-&gt;Activity:callActivityOnPause()<br>Activity-&gt;Activity:performPause()<br>Activity-&gt;Activity:onPause()<br><br>ActivityThread.H-&gt;TransactionExecutor:handleMessage()<br>TransactionExecutor-&gt;TransactionExecutor:execute()<br>TransactionExecutor–&gt;LaunchActivityItem:executeCallbacks()<br>LaunchActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handleLaunchActivity()<br>ActivityThread–&gt;Instrumentation:performLaunchActivity()<br>Instrumentation-&gt;Activity:callActivityOnCreate()<br>Activity-&gt;Activity:performCreate()<br>Activity-&gt;Activity:onCreate()<br><br>TransactionExecutor–&gt;ResumeActivityItem:executeLifecycleState()<br>ResumeActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handleResumeActivity()<br>ActivityThread–&gt;Activity:performResumeActivity()<br>Activity-&gt;Instrumentation:performResume()<br>Instrumentation-&gt;Activity:callActivityOnResume()<br>Activity-&gt;Activity:onResume()<br></div><div style="display: none"><br><div id="sequence-0"></div><br></div><div style="display: none"><br><div id="sequence-1"></div><br></div><div style="display: none"><br><br>ActivityThread-&gt;ActivityThread:Loop#prepareMainLooper()<br>ActivityThread–&gt;IActivityManager:attach()<br>Note over IActivityManager:AIDL<br>IActivityManager-&gt;ActivityManagerService:attachApplication()<br>ActivityManagerService-&gt;IApplicationThread:attachApplicationLocked()<br>Note over IApplicationThread:AIDL<br>IApplicationThread-&gt;ApplicationThread:bindApplication()<br>ApplicationThread-&gt;ActivityThread.H:sendMessage(BIND_APPLICATION)<br><br>ActivityManagerService–&gt;ActivityTaskManagerService.LocalService:attachApplicationLocked()<br>ActivityTaskManagerService.LocalService-&gt;RootActivityContainer:attachApplication()<br>RootActivityContainer-&gt;ActivityStackSupervisor:attachApplication()<br>ActivityStackSupervisor-&gt;ClientLifecycleManager:realStartActivityLocked()<br>ClientLifecycleManager-&gt;ClientLifecycleManager:scheduleTransaction()<br><br>ActivityThread-&gt;ActivityThread:Looper#loop()<br><br>ActivityThread.H–&gt;ActivityThread:handleMessage(BIND_APPLICATION)<br>ActivityThread–&gt;LoadedApk:handleBindApplication()<br>LoadedApk-&gt;Instrumentation:makeApplication()<br>Instrumentation-&gt;CoreComponentFactory:newApplication()<br>CoreComponentFactory-&gt;CoreComponentFactory:instantiateApplication()<br>Instrumentation–&gt;Application:callApplicationOnCreate()<br>Application-&gt;Application:onCreate()<br><br></div><p><script src="https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js"></script><script src="https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js"></script><script src="https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js"></script><script src="https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">ActivityStarter->ActivityStackSupervisor:startActivityMayWait()ActivityStackSupervisor->ActivityTaskManagerService:resolveIntent()ActivityTaskManagerService->PackageManagerInternalImpl:getPackageManagerInternalLocked()PackageManagerInternalImpl->PackageManagerService:resolveIntent()PackageManagerService->PackageManagerService:resolveIntentInternal()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">ActivityStackSupervisor->ActivityManagerInternal(ActivityManagerService.LocalService):startSpecificActivityLocked()ActivityManagerInternal(ActivityManagerService.LocalService)->ActivityManagerService:startProcess()ActivityManagerService->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->Process:startProcess()Process->ZygoteProcess:start()ZygoteProcess->ZygoteProcess:startViaZygote()ZygoteProcess->ZygoteProcess:openZygoteSocketIfNeeded()ZygoteProcess->ZygoteProcess:zygoteSendArgsAndGetResult()</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;源码基于 &lt;a href=&quot;https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 10&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/categories/Framework/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/tags/Framework/"/>
    
      <category term="AMS" scheme="http://yhaowa.gitee.io/tags/AMS/"/>
    
  </entry>
  
  <entry>
    <title>Android 集成 FFmpeg (四) 轻松实现一个音视频编辑 App</title>
    <link href="http://yhaowa.gitee.io/798144ac/"/>
    <id>http://yhaowa.gitee.io/798144ac/</id>
    <published>2019-06-16T12:07:18.000Z</published>
    <updated>2020-03-14T10:55:56.917Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看到一篇关于 FFmpeg 的文章，讲的大概是基于 FFmpeg 实现了一个 App，支持视频拼图等强大炫酷的音视频编辑功能，其原理是在 Android 端集成 FFmpeg，通过命令方式调用 FFmpeg。</p><p>尽管在 Android 端集成命令方式调用并不复杂，但一个具有强大炫酷音视频编辑功能的 App 是有价值的。由此启发，并决定敲下 Android 集成 FFmpeg 系列的第四篇，以一个实际应用的方式展现 FFmpeg 强大的音视频编辑功能。</p><a id="more"></a><p>应用截图：</p><p><img src="../img/19.jpg" alt></p><blockquote><p>源码：<a href="https://github.com/yhaolpz/FFmpegCmd" target="_blank" rel="noopener">https://github.com/yhaolpz/FFmpegCmd</a></p></blockquote><p>若想实现更多效果，见 <a href="http://ffmpeg.org/ffmpeg.html" target="_blank" rel="noopener">ffmpeg Documentation</a>，应用代码非常简单，这里就不再过多阐述，直接查看源码，一看即懂，理论知识及编译实现见前三篇：</p><blockquote><p><a href="https://yhaolpz.github.io/e0b4d9fc/" target="_blank" rel="noopener">Android 集成 FFmpeg (一) 基础知识及简单调用</a><br><a href="https://yhaolpz.github.io/ddeb5551/" target="_blank" rel="noopener">Android 集成 FFmpeg (二) 以命令方式调用 FFmpeg</a><br><a href="https://yhaolpz.github.io/8837781/" target="_blank" rel="noopener">Android 集成 FFmpeg (三) 获取 FFmpeg 执行进度</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看到一篇关于 FFmpeg 的文章，讲的大概是基于 FFmpeg 实现了一个 App，支持视频拼图等强大炫酷的音视频编辑功能，其原理是在 Android 端集成 FFmpeg，通过命令方式调用 FFmpeg。&lt;/p&gt;
&lt;p&gt;尽管在 Android 端集成命令方式调用并不复杂，但一个具有强大炫酷音视频编辑功能的 App 是有价值的。由此启发，并决定敲下 Android 集成 FFmpeg 系列的第四篇，以一个实际应用的方式展现 FFmpeg 强大的音视频编辑功能。&lt;/p&gt;
    
    </summary>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="FFmpeg" scheme="http://yhaowa.gitee.io/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES（三）简单图形变换</title>
    <link href="http://yhaowa.gitee.io/1008175c/"/>
    <id>http://yhaowa.gitee.io/1008175c/</id>
    <published>2019-06-16T09:11:32.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>尽管对 VAO、VBO 以及纹理相关的知识跃跃欲试，但还是决定耐下心来，先学习绘制一些简单图形及图形变换，在第一篇文章也只是简单学习了下 GLSL 语言，这篇文章的学习也可以对 GLSL 语言有更好的掌握。</p><a id="more"></a><blockquote><p>正在学习…</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管对 VAO、VBO 以及纹理相关的知识跃跃欲试，但还是决定耐下心来，先学习绘制一些简单图形及图形变换，在第一篇文章也只是简单学习了下 GLSL 语言，这篇文章的学习也可以对 GLSL 语言有更好的掌握。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES（二）绘制三角形</title>
    <link href="http://yhaowa.gitee.io/2296ca3/"/>
    <id>http://yhaowa.gitee.io/2296ca3/</id>
    <published>2019-06-16T08:39:50.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过上篇文章的学习，现在已经了解到，要想在 Android 端使用 OpenGL ES 绘制图形，必须创建 OpenGL ES 环境和视图窗口，具体来说就是构建 EGL 环境，即 OpenGL ES 和 Android 底层平台视窗系统之间的接口。另外 OpenGL ES 2.0 版本为可编程管线，我们就可以编写着色器程序来确定绘制内容，即编写 Vertex Shader 顶点着色器和 Fragment Shader 片元着色器。</p><p>而这些工作可以通过 GLSurfaceView 非常简单的实现。</p><a id="more"></a><p>在介绍 GLSurfaceView 之前先来看下 Android 系统提供的与 OpenGL ES 相关的包：</p><ul><li>javax.microedition.khronos.opengles： 存放 GL 绘图指令相关代码</li><li>javax.microedition.khronos.egl： 存放 EGL 管理相关代码，包括 Display、surface 等</li><li>android.opengl： 存放 GL 辅助类，连接 OpenGL 与 Android View，Activity 等</li></ul><p>其中 GLSurfaceView 处于 android.opengl 包中，GLSurfaceView 具有以下特性：</p><ul><li>内置 EGL 管理，自带 GL 上下文环境和 GLThread 绘制线程</li><li>起到连接 OpenGL ES 与 Android 的 View 层次结构之间的桥梁作用</li><li>使得 OpenGL ES 库适应于 Activity 生命周期</li><li>继承自 SurfaceView，拥有 SurfaceView 的全部特性，绘制结果会输出到 SurfaceView 所提供的 Surface 上</li><li>提供了方便使用的调试工具来跟踪 OpenGL ES 函数调用以帮助检查错误</li></ul><p>通过 GLSurfaceView 的 setRenderer 方法可设置要渲染的效果，即 GLSurfaceView.Renderer 渲染器接口，该接口方法：</p><ul><li>onSurfaceCreated：渲染线程开启时调用，可做初始化背景色、初始化纹理资源等工作</li><li>onSurfaceChanged：窗口尺寸改变时调用，通常会设置视窗范围或投影矩阵等</li><li>onDrawFrame：外部请求渲染一次就调用一次，可在此载入着色器程序、激活绑定纹理以及调用绘制</li></ul><p>下面来看具体如何绘制一个三角形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String vertexShaderResource =</span><br><span class="line">            <span class="string">"attribute vec3 vPosition;"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;"</span> +</span><br><span class="line">                    <span class="string">"  gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);"</span> +</span><br><span class="line">                    <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String fragmentShaderResource =</span><br><span class="line">            <span class="string">"precision mediump float;"</span> +</span><br><span class="line">                    <span class="string">"uniform vec4 vColor;"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;"</span> +</span><br><span class="line">                    <span class="string">"  gl_FragColor = vColor;"</span> +</span><br><span class="line">                    <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] vertexCoords = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">            <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// top</span></span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom left</span></span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// bottom right</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> color[] = &#123;<span class="number">1.0f</span>, <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">1.0f</span>&#125;; <span class="comment">//red</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 着色器程序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mProgram;</span><br><span class="line">    <span class="comment">// 顶点坐标数据</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer vertexFloatBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置清空屏幕后的背景色</span></span><br><span class="line">        GLES30.glClearColor(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">//构建顶点着色器</span></span><br><span class="line">        <span class="keyword">int</span> vertexShader = GLES30.glCreateShader(GLES30.GL_VERTEX_SHADER);</span><br><span class="line">        GLES30.glShaderSource(vertexShader, vertexShaderResource);</span><br><span class="line">        GLES30.glCompileShader(vertexShader);</span><br><span class="line">        <span class="comment">//构建片段着色器</span></span><br><span class="line">        <span class="keyword">int</span> fragmentShader = GLES30.glCreateShader(GLES30.GL_FRAGMENT_SHADER);</span><br><span class="line">        GLES30.glShaderSource(fragmentShader, fragmentShaderResource);</span><br><span class="line">        GLES30.glCompileShader(fragmentShader);</span><br><span class="line">        <span class="comment">//构建着色器程序，并将顶点着色器和片段着色器链接进来</span></span><br><span class="line">        mProgram = GLES30.glCreateProgram();</span><br><span class="line">        GLES30.glAttachShader(mProgram, vertexShader);</span><br><span class="line">        GLES30.glAttachShader(mProgram, fragmentShader);</span><br><span class="line">        GLES30.glLinkProgram(mProgram);</span><br><span class="line">        <span class="comment">//顶点着色器和片段着色器链接到着色器程序后就无用了</span></span><br><span class="line">        GLES30.glDeleteShader(vertexShader);</span><br><span class="line">        GLES30.glDeleteShader(fragmentShader);</span><br><span class="line">        <span class="comment">//转换为需要的顶点数据格式</span></span><br><span class="line">        vertexFloatBuffer = floatToBuffer(vertexCoords);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置视窗</span></span><br><span class="line">        GLES30.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//清空屏幕，擦除屏幕上所有的颜色，用 glClearColor 定义的颜色填充</span></span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">//在当前 EGL 环境激活着色器程序</span></span><br><span class="line">        GLES30.glUseProgram(mProgram);</span><br><span class="line">        <span class="comment">//获取顶点着色器的 vPosition 成员句柄</span></span><br><span class="line">        <span class="keyword">int</span> positionHandle = GLES30.glGetAttribLocation(mProgram, <span class="string">"vPosition"</span>);</span><br><span class="line">        <span class="comment">//启用句柄</span></span><br><span class="line">        GLES30.glEnableVertexAttribArray(positionHandle);</span><br><span class="line">        <span class="comment">//设置顶点坐标数据</span></span><br><span class="line">        GLES30.glVertexAttribPointer(positionHandle, <span class="number">3</span>, GLES30.GL_FLOAT,</span><br><span class="line">                <span class="keyword">false</span>, <span class="number">3</span> * <span class="number">4</span>, vertexFloatBuffer);</span><br><span class="line">        <span class="comment">//获取片元着色器的 vColor 成员句柄</span></span><br><span class="line">        <span class="keyword">int</span> colorHandle = GLES30.glGetUniformLocation(mProgram, <span class="string">"vColor"</span>);</span><br><span class="line">        <span class="comment">//设置颜色</span></span><br><span class="line">        GLES30.glUniform4fv(colorHandle, <span class="number">1</span>, color, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//绘制三角形</span></span><br><span class="line">        GLES30.glDrawArrays(GLES30.GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//禁止顶点数组的句柄</span></span><br><span class="line">        GLES30.glDisableVertexAttribArray(positionHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FloatBuffer <span class="title">floatToBuffer</span><span class="params">(<span class="keyword">float</span>[] a)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(a.length * <span class="number">4</span>); <span class="comment">//float占4个字节</span></span><br><span class="line">        buffer.order(ByteOrder.nativeOrder());</span><br><span class="line">        FloatBuffer byteBuffer = buffer.asFloatBuffer();</span><br><span class="line">        byteBuffer.put(a);</span><br><span class="line">        byteBuffer.position(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> byteBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h4><p>要绘制一个三角形，就要确定三个顶点的 3D 坐标（OpenGL 是一个 3D 图形库，在 OpenGL 中指定的所有坐标都需要是 3D 坐标，即 x、y 和 z）。而顶点坐标起始于局部坐标，需要为标准化设备坐标，即 x、y、z 的范围限定于 -1 到 1 之间，任何落在范围外的坐标都会被丢弃。上面代码中输入的顶点数据为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] vertexCoords = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里将 z 坐标都设置为 0，表示三角形每一点的深度都为 0（通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源），这样定义的顶点数据反应到标准化设备坐标系中就是这样的：</p><p><img src="../img/17.jpg" alt></p><h4 id="解释顶点数据"><a href="#解释顶点数据" class="headerlink" title="解释顶点数据"></a>解释顶点数据</h4><p>可以看到调用 glVertexAttribPointer 设置顶点数据时并不是直接把 float[] 数组传递进去，而是转换成 FloatBuffer 传入，所谓的解释顶点数据就是说明输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。对于 glVertexAttribPointer 函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glVertexAttribPointer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> indx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> normalized,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> stride,</span></span></span><br><span class="line"><span class="function"><span class="params">    java.nio.Buffer ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>indx：指定要配置的顶点属性，这里传入顶点着色器的 vPosition 成员句柄</li><li>size：指定顶点属性的大小，顶点属性是一个 vec3，它由 3 个值（x、y、z）组成，所以大小传入 3</li><li>type：指定数据的类型为 float 类型</li><li>normalized：是否希望数据被标准化</li><li>stride：指定连续的顶点数据之间的间隔，由于一个顶点数据长度为 3 个 float，所以把步长设置为 3 * 4（一个 float 占 4 个字节）</li><li>ptr：顶点数据</li></ul><p>下图很好的阐释这个逻辑：</p><p><img src="../img/18.jpg" alt></p><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String vertexShaderResource =</span><br><span class="line">    <span class="string">"attribute vec3 vPosition;"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;"</span> +</span><br><span class="line">        <span class="string">"  gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><p>由于每个顶点都有一个 3D 坐标，这里就创建一个 vec3 变量输入顶点坐标。而内置变量 gl_Position 为 vec4 类型，所以需要将三维向量转换为四维向量，最后 gl_Position 设置的值会成为该顶点着色器的输出。</p><p>onDrawFrame 方法中在获取顶点着色器的 vPosition 成员句柄后，需要调用 glEnableVertexAttribArray、glDisableVertexAttribArray 分别启用、禁止顶点数据，而片段着色器的 vColor 成员句柄就不需要。这是因为出于性能考虑，所有顶点着色器的属性默认都是关闭的。<br>glVertexAttribPointer 只是建立 CPU 和 GPU 之间的逻辑连接实现将 CPU 数据上传至 GPU，但是，数据在 GPU 端是否可见，即着色器能否读取到数据，还要取决于 glEnableVertexAttribArray 方法。</p><h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String fragmentShaderResource =</span><br><span class="line"><span class="string">"precision mediump float;"</span> +</span><br><span class="line">        <span class="string">"uniform vec4 vColor;"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;"</span> +</span><br><span class="line">        <span class="string">"  gl_FragColor = vColor;"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><p>在 OpenGL 中定义一个颜色的数据格式为 RGBA 四个 0.0 到 1.0 之间强度的分量，片段着色器所做的是计算像素最后的颜色输出，也只有 gl_FragColor 这一个输出变量。</p><h4 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vertexShader = GLES30.glCreateShader(GLES30.GL_VERTEX_SHADER);</span><br><span class="line">GLES30.glShaderSource(vertexShader, vertexShaderResource);</span><br><span class="line">GLES30.glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p>为了让 OpenGL 能够使用我们编写的着色器源码，必须在运行时动态编译。首先通过 glCreateShader 创建一个着色器对象，返回该着色器的 ID，然后通过 glShaderSource、glCompileShader 方法将源码附着在着色器对象上并编译它。</p><p>编译着色器可能失败，一般编译时会通过如下方法判断是否编译成功并输出编译信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] compileStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">GLES20.glGetShaderiv(shaderObjectId, GLES20.GL_COMPILE_STATUS, compileStatus, <span class="number">0</span>);</span><br><span class="line">Log.d(TAG, <span class="string">"glCompileStatus: "</span> + compileStatus[<span class="number">0</span>] </span><br><span class="line">            + <span class="string">" log:"</span> + GLES20.glGetShaderInfoLog(shaderObjectId));</span><br><span class="line"><span class="keyword">if</span> (compileStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="comment">//编译失败</span></span><br><span class="line">    GLES20.glDeleteShader(shaderObjectId);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mProgram = GLES30.glCreateProgram();</span><br><span class="line">GLES30.glAttachShader(mProgram, vertexShader);</span><br><span class="line">GLES30.glAttachShader(mProgram, fragmentShader);</span><br><span class="line">GLES30.glLinkProgram(mProgram);</span><br></pre></td></tr></table></figure><p>着色器程序对象是多个着色器合并之后并最终链接完成的版本，它将编译好的顶点着色器和片段着色器链接为一个着色器程序对象，链接后顶点着色器和片段着色器就没用了，可以通过 glDeleteShader 删除。就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">GLES20.glGetProgramiv(mProgram, GLES20.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">Log.d(TAG, <span class="string">"glCompileStatus："</span> + linkStatus[<span class="number">0</span>]</span><br><span class="line">            + <span class="string">" log:"</span> + GLES20.glGetProgramInfoLog(mProgram));</span><br><span class="line"><span class="keyword">if</span> (linkStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="comment">//链接失败</span></span><br><span class="line">    GLES20.glDeleteProgram(mProgram);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链接成功后，在渲染的时候通过 glUseProgram 方法激活着色器程序，已激活着色器程序的着色器就会在渲染时被使用，最后通过 glDrawArrays 方法触发绘制。</p><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://item.jd.com/12292642.html" target="_blank" rel="noopener">《音视频开发进阶指南 - 基于Android与IOS平台的实践》</a><br><a href="https://blog.csdn.net/TuGeLe/article/details/79199161" target="_blank" rel="noopener">Android GLSurfaceView详解</a><br><a href="http://wiki.jikexueyuan.com/project/opengl-es-guide/glsurfaceview.html" target="_blank" rel="noopener">GLSurfaceView</a><br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">你好，三角形</a><br><a href="https://www.jianshu.com/p/b05884a0ff8e" target="_blank" rel="noopener">OpenGL ES 3.0 glEnableVertexAttribArray的作用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过上篇文章的学习，现在已经了解到，要想在 Android 端使用 OpenGL ES 绘制图形，必须创建 OpenGL ES 环境和视图窗口，具体来说就是构建 EGL 环境，即 OpenGL ES 和 Android 底层平台视窗系统之间的接口。另外 OpenGL ES 2.0 版本为可编程管线，我们就可以编写着色器程序来确定绘制内容，即编写 Vertex Shader 顶点着色器和 Fragment Shader 片元着色器。&lt;/p&gt;
&lt;p&gt;而这些工作可以通过 GLSurfaceView 非常简单的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES（一）开发入门</title>
    <link href="http://yhaowa.gitee.io/eeb650a2/"/>
    <id>http://yhaowa.gitee.io/eeb650a2/</id>
    <published>2019-06-09T12:40:06.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>早就听过大名鼎鼎的 OpenGL，却迟迟没有实践学习，有些惭愧。今天开始通过实践+博文方式学习掌握 OpenGL。此文对于 OpenGL 的学习分为以下部分：</p><ul><li>OpenGL 基础概念</li><li>OpenGL 坐标系理解</li><li>OpenGL 渲染管线</li><li>OpenGL 着色语言</li></ul><a id="more"></a><h1 id="OpenGL-基础概念"><a href="#OpenGL-基础概念" class="headerlink" title="OpenGL 基础概念"></a>OpenGL 基础概念</h1><h4 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h4><p>OpenGL 即 Open Graphics Library，是一个功能强大、调用方便的底层图形库，它定义了跨编程语言、跨平台的专业图形程序接口，可用于二维或三维图像的处理与渲染。</p><p>OpenGL 是跨平台的，除了它纯粹专注的渲染外，其他内容在每个平台上都要有它的具体实现，比如上下文环境和窗口的管理就交由各个设备自己来完成。</p><h4 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h4><p>OpenGL ES （OpenGL for Embedded Systems）是三维图形 API OpenGL 的子集，针对手机、PDA 和游戏主机等嵌入式设备而设计。</p><p>Android 对应 OpenGL ES 的版本支持如下：</p><ul><li>Android 1.0 开始支持 OpenGL ES 1.0 及 1.1</li><li>Android 2.2 开始支持 OpenGL ES 2.0</li><li>Android 4.3 开始支持 OpenGL ES 3.0</li><li>Android 5.0 开始支持 OpenGL ES 3.1</li></ul><p>其中 OpenGL ES 1.0 是以 OpenGL 1.3 规范为基础的，OpenGL ES 1.1 是以 OpenGL 1.5 规范为基础的，而 OpenGL ES 2.0 基于 OpenGL 2.0 实现。2.x 版本相比 1.x 版本有较大差异，1.x 版本为 fixed function pipeline，即固定管线硬件，而 2.x 版本为 programmable pipeline，可编程管线硬件。</p><p>固定管线中原本由系统做的一部分工作，在可编程管线中必须需要自己写程序实现，具体程序为 vertex shader（顶点着色器）和 fragment shader（片元着色器）。</p><h4 id="OpenGL-上下文"><a href="#OpenGL-上下文" class="headerlink" title="OpenGL 上下文"></a>OpenGL 上下文</h4><p>OpenGL 是一个仅仅关注图像渲染的图像接口库，在渲染过程中它需要将顶点信息、纹理信息、编译好的着色器等渲染状态信息存储起来，而存储这些信息的数据结构就可以看作 OpenGL 的上下文。</p><p>调用任何 OpenGL 函数前，必须已经创建了 OpenGL Context，GL Context 存储了OpenGL 的状态变量以及其他渲染有关的信息。OpenGL 是个状态机，有很多状态变量，是个标准的过程式操作过程，改变状态会影响后续所有操作，这和面向对象的解耦原则不符，毕竟渲染本身就是个复杂的过程。OpenGL 采用 Client-Server 模型来解释 OpenGL 程序，即 Server 存储 GL Context（可能不止一个），Client 提出渲染请求，Server 给予响应，一般 Server 和 Client 都在我们的 PC 上，但 Server 和 Client 也可以是通过网络连接。</p><p>之后的渲染工作就要依赖这些渲染状态信息来完成，当一个上下文被销毁时，它所对应的 OpenGL 渲染工作也将结束。</p><h4 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h4><p>在 OpenGL 的设计中，OpenGL 是不负责管理窗口的，窗口的管理交由各个设备自己来完成，具体来讲，IOS 平台上使用 EAGL 提供本地平台对 OpenGL 的实现，在 Android 平台上使用 EGL 提供本地平台对 OpenGL 的实现。EGL 是 OpenGL ES 和 Android 底层平台视窗系统之间的接口，在 OpenGL 的输出与设备屏幕之间架接起一个桥梁，承担了为 OpenGL 提供上下文环境以及管理窗口的职责。</p><p>EGL 为双缓冲工作模式，即有一个 Back Frame Buffer 和一个 Front Frame Buffer，正常绘制的目标都是 Back Frame Buffer，绘制完成后再调用 eglSwapBuffer API，将绘制完毕的 FrameBuffer 交换到 Front Frame Buffer 并显示出来。</p><p>从代码层面来看，OpenGL ES 的 opengles 包下定义了平台无关的绘图指令，EGL（javax.microedition.khronos.egl）<br>则定义了控制 displays，contexts 以及 surfaces 的统一的平台接口。</p><ul><li>Display（EGLDisplay） 是对实际显示设备的抽象</li><li>Surface（EGLSurface）是对用来存储图像的内存区域 FrameBuffer 的抽象，包括 Color Buffer、Stencil Buffer、Depth Buffer</li><li>Context（EGLContext）存储 OpenGL ES 绘图的一些状态信息</li></ul><p><img src="../img/1.jpeg" alt></p><blockquote><p>使用 EGL 绘图的一般步骤：<br>获取 EGLDisplay 对象<br>初始化与 EGLDisplay 之间的连接<br>获取 EGLConfig 对象<br>创建 EGLContext 实例<br>创建 EGLSurface 实例<br>连接 EGLContext 和 EGLSurface<br>使用 GL 指令绘制图形<br>断开并释放与 EGLSurface 关联的 EGLContext 对象<br>删除 EGLSurface 对象<br>删除 EGLContext 对象<br>终止与 EGLDisplay 之间的连接</p></blockquote><p>一般来说在 Android 平台上开发 OpenGL ES 应用，无需按照上述步骤来绘制图形，可以直接使用 GLSurfaceView 控件，该控件提供了对 Display、Surface 以及 Context 的管理，大大简化了开发流程。</p><h4 id="OpenGL-纹理"><a href="#OpenGL-纹理" class="headerlink" title="OpenGL 纹理"></a>OpenGL 纹理</h4><p>纹理（Texture）是一个 2D 图片（甚至也有 1D 和 3D 的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的 3D 的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><h1 id="OpenGL-坐标系理解"><a href="#OpenGL-坐标系理解" class="headerlink" title="OpenGL 坐标系理解"></a>OpenGL 坐标系理解</h1><p>OpenGL 要求输入的顶点坐标都是标准化设备坐标，即每个顶点的 x、y、z 都在 -1 到 1 之间，由标准化设备坐标转换为屏幕坐标的过程中会经历变换多个坐标系统，在这些特定的坐标系中，一些操作和计算可以更加方便。</p><p><img src="../img/15.jpg" alt></p><ul><li><strong>1. 局部坐标</strong><br>顶点坐标起始于局部空间（Local Space），在这里称为局部坐标，是以物体某一点为原点而建立的，该坐标系仅对该物体适用，用来简化对物体各部分坐标的描述。物体放到场景中时，各部分经历的坐标变换相同，相对位置不变。</li><li><strong>2. 世界坐标</strong><br>局部坐标通过模型矩阵进行位移、缩放、旋转，将物体从局部变换到世界空间，并和其他物体一起相对于世界的原点摆放。</li><li><strong>3. 观察坐标</strong><br>将世界空间坐标转化为用户视野前方的坐标，通常是由一系列的位移和旋转的组合（观察矩阵）来完成。</li><li><strong>4. 裁剪坐标</strong><br>坐标到达观察空间之后，通过投影矩阵会将指定范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)，所有在范围外的坐标会被裁剪掉。</li><li><strong>5. 屏幕坐标</strong><br>将裁剪坐标位于(-1.0, 1.0)范围的坐标变换到由 glViewport 函数所定义的坐标范围内，最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ul><h1 id="OpenGL-渲染管线"><a href="#OpenGL-渲染管线" class="headerlink" title="OpenGL 渲染管线"></a>OpenGL 渲染管线</h1><p>OpenGL 渲染管线流程为：顶点数据 -&gt; 顶点着色器 -&gt; 图元装配 -&gt; 几何着色器 -&gt; 光栅化 -&gt; 片段着色器 -&gt; 逐片段处理 -&gt; 帧缓冲 </p><p><img src="../img/16.jpg" alt></p><p>OpenGL 渲染管线的流程其实就是 OpenGL 引擎渲染图像的流程，也就是说 OpenGL 引擎一步一步的将图片渲染到屏幕上的过程，渲染管线可以分为以下几个阶段：</p><ul><li><p><strong>1. 指定几何对象</strong><br>首先要了解几何图元的概念，几何图元就是点、直线、三角线等几何对象，在提供了顶点坐标后，还要确定具体要画的是点、线段还是三角形，这就要确定具体执行的绘制指令。比如 OpenGL 提供给开发者的绘制方法 glDrawArrays，这个方法的第一个参数就是指定绘制方式，可选值有：<br><strong>GL_POINTS</strong>：以点的形式进行绘制，通常用在绘制粒子效果的场景。<br><strong>GL_LINES</strong>：以线的形式进行绘制，通常用于绘制直线的场景。<br><strong>GL_TRIANGLE_STRIP</strong>：以三角形的形式进行绘制，所有二维图像的渲染都会使用这种方式。<br>具体选用哪一种绘制方式决定了 OpenGL 渲染管线的第一阶段应如何去绘制几何图元，这就是第一阶段指定几何对象。</p></li><li><p><strong>2. 顶点处理</strong><br>不论上面的几何图元是如何指定的，所有的几何数据都将会通过这个阶段。这个阶段的操作内容有：根据模型视图（即根据几何图元创建的物体）和投影矩阵进行变换来改变顶点的位置，根据纹理坐标与纹理矩阵来改变纹理坐标的位置，如果设计三维的渲染，还要处理光照计算和法线变换。<br>关键的操作就是顶点坐标变换及光照处理，每个顶点是分别单独处理的。这个阶段所接受的数据是每个顶点的属性特征，输出的则是变换后的顶点数据。</p></li><li><p><strong>3. 图元组装</strong><br>在顶点处理之后，顶点的全部属性都已经被确定。在这个阶段顶点将会根据应用程序设定的图元规则如 GL_POINTS 、GL_TRIANGLES(三角形) 等被组装成图元。</p></li><li><p><strong>4. 珊格化操作</strong><br>在图元组装后会传递过来图元数据，到目前为止，这些图元信息还只是顶点而已：顶点处都还没有“像素点”、直线段端点之间是空的、多边形的边和内部也是空的，光栅化的任务就是构造这些。<br>这个阶段会将图元数据分解成更小的单元并对应于帧缓冲区的各个像素，这些单元称为片元，一个片元可能包含窗口颜色、纹理坐标等属性。片元的属性则是图元上的顶点数据等经过插值而确定的，这就是珊格化操作，也就是确定好每一个片元是什么。</p></li><li><p><strong>5. 片元处理</strong><br>珊格化操作构造了像素点，这个阶段就是处理这些像素点，根据自己的业务处理（比如提亮、饱和度调节、对比度调节、高斯模糊等）来变换这个片元的颜色。</p></li><li><p><strong>6. 逐片段处理</strong><br>进行剪切、Alpha 测试、 模版测试、深度测试、混合等处理，这些操作将会最后影响其在帧缓冲区的颜色值。</p></li><li><p><strong>7. 帧缓冲操作</strong><br>此阶段主要执行帧缓冲的写入操作，也是渲染管线的最后一步，负责将最终的像素点写到帧缓冲区。</p></li></ul><p>上面提到 OpenGL ES 2.0 版本相比之前版本，提供了可编程的着色器来代替 1.x 版本渲染管线的某些阶段，具体为：</p><ul><li>Vertex Shader（顶点着色器）用于替换顶点处理阶段</li><li>Fragment Shader（片元着色器）用于替换片元处理阶段</li></ul><h1 id="OpenGL-着色语言"><a href="#OpenGL-着色语言" class="headerlink" title="OpenGL 着色语言"></a>OpenGL 着色语言</h1><p>OpenGL 着色语言 GLSL 全称为 OpenGL Shading Language，是为了实现着色器的功能而向开发人员提供的一种开发语言，语法与 C 语言类似，下面分为以下几点来学习 GLSL：</p><ul><li><strong>1. 基本数据类型</strong></li></ul><blockquote><p>void：空类型，即不返回任何值<br>bool：布尔类型，true/false<br>int：带符号的整数，signed integer<br>float：带符号的浮点数，signed scalar<br>vec2、vec3、vec4：n-维浮点数向量<br>bvec2、bvec3、bvec4：n-维布尔向量<br>ivec2、ivec3、ivec4：n-维整数向量<br>mat2、mat3、mat4：2x2、3x3、4x4 浮点数矩阵<br>sampler2D：2D 纹理<br>samplerCube：盒纹理</p></blockquote><p>其中 float 可指定精度：</p><blockquote><p>high：32bit，一般用于顶点坐标（vertex Coordinate）<br>medium：16bit，一般用于纹理坐标（texture Coordinate）<br>low：8bit，一般用于颜色表示（color）</p></blockquote><ul><li><strong>2. 变量修饰符</strong></li></ul><blockquote><p>none：(默认的可省略)本地变量，可读可写，函数的输入参数既是这种类型<br>const：声明变量或函数的参数为只读类型<br>attribute：用于保存顶点或法线数据,它可以在数据缓冲区中读取数据，仅能用于顶点着色器<br>uniform：在运行时 shader 无法改变 uniform 变量，一般用来放置程序传递给 shader 的变换矩阵，材质，光照参数等等，可用于顶点着色器和片元着色器<br>varying：用于修饰从顶点着色器向片元着色器传递的变量</p></blockquote><p>要注意全局变量限制符只能为 const、attribute、uniform 和 varying 中的某一个，不可复合。</p><ul><li><strong>3. 内置变量</strong></li></ul><p>GLSL 程序使用一些特殊的内置变量与硬件进行沟通，他们大致分成两种，一种是 input 类型,他负责向硬件(渲染管线)发送数据；另一种是 output 类型，负责向程序回传数据，以便编程时需要。<br>顶点着色器中 output 类型的内置变量如下：</p><blockquote><p>highp vec4  gl_Position：放置顶点坐标信息<br>mediump float gl_PointSize：需要绘制点的大小,(只在gl.POINTS模式下有效)</p></blockquote><p>片元着色器中 input 类型的内置变量如下：</p><blockquote><p>mediump vec4 gl_FragCoord;：片元在 framebuffer 画面的相对位置<br>bool gl_FrontFacing：标志当前图元是不是正面图元的一部分<br>mediump vec2 gl_PointCoord：经过插值计算后的纹理坐标,点的范围是0.0到1.0</p></blockquote><p>片元着色器中 output 类型的内置变量如下：</p><blockquote><p>mediump vec4 gl_FragColor：设置当前片点的颜色<br>mediump vec4 gl_FragData[n]：设置当前片点的颜色,使用glDrawBuffers数据数组</p></blockquote><ul><li><strong>4. 内置常量</strong></li></ul><p>GLSL 提供了一些内置的常量，用来说明当前系统的一些特性。有时我们需要针对这些特性，对 shader 程序进行优化，让程序兼容度更好。</p><p>顶点着色器中的内置常量如下：</p><blockquote><p>const mediump int gl_MaxVertexAttribs &gt;= 8：顶点着色器中可用的最大 attributes 数<br>const mediump int gl_MaxVertexUniformVectors &gt;= 128：顶点着色器中可用的最大 uniform vectors 数<br>const mediump int gl_MaxVaryingVectors &gt;= 8：顶点着色器中可用的最大 varying vectors 数<br>const mediump int gl_MaxVertexTextureImageUnits &gt;= 0：顶点着色器中可用的最大纹理单元数<br>const mediump int gl_MaxCombinedTextureImageUnits &gt;= 8：表示最多支持多少个纹理单元</p></blockquote><p>片元着色器中的内置常量如下：</p><blockquote><p>const mediump int gl_MaxTextureImageUnits &gt;= 8：片元着色器中能访问的最大纹理单元数<br>const mediump int gl_MaxFragmentUniformVectors &gt;= 16：片元着色器中可用的最大 uniform vectors 数<br>const mediump int gl_MaxDrawBuffers = 1：表示可用的 drawBuffers 数,在 OpenGL ES 2.0 中这个值为 1, 在将来的版本可能会有所变化</p></blockquote><p>上面这些值的大小取决于 OpenGL ES 在某设备上的具体实现。</p><ul><li><strong>5. 内置函数</strong></li></ul><blockquote><p>通用函数：abs、floor、min、max 等，参数可传入 float/vec2/vec3/vec4 类型<br>角度函数：sin、cos 等，参数可传入 float/vec2/vec3/vec4 类型<br>指数函数：pow、log 等，参数可传入 float/vec2/vec3/vec4 类型<br>几何函数：distance、dot 等，参数可传入 float/vec2/vec3/vec4 类型<br>矩阵函数：matrixCompMult，参数传入 mat 类型<br>向量函数：lessThan、equal 等，参数可传入 vec2/vec3/vec4 类型<br>纹理函数：texture2D、texture2DProj 等</p></blockquote><p>更详细的内置函数介绍可去官方文档查看，在此只简单列一下大致种类。</p><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://item.jd.com/12292642.html" target="_blank" rel="noopener">《音视频开发进阶指南 - 基于Android与IOS平台的实践》</a><br><a href="https://baike.baidu.com/item/OpenGL/238984?fr=aladdin" target="_blank" rel="noopener">OpenGL 百度百科</a><br><a href="https://blog.csdn.net/qq_36383623/article/details/89315921" target="_blank" rel="noopener">OpenGL Context（渲染上下文）</a><br><a href="https://baike.baidu.com/item/OpenGL%20ES" target="_blank" rel="noopener">OpenGL ES 百度百科</a><br><a href="https://blog.csdn.net/weixin_41101173/article/details/80036809" target="_blank" rel="noopener">在Android中使用OpenGL ES进行开发第（一）节：概念先行</a><br><a href="https://blog.csdn.net/jackie03/article/details/7298682" target="_blank" rel="noopener">Android OpenGL ES（四）:关于EGL</a><br><a href="https://blog.csdn.net/qq_35370018/article/details/80156643" target="_blank" rel="noopener">初学OpenGL（4）：纹理</a><br><a href="https://blog.csdn.net/u011153817/article/details/51899091" target="_blank" rel="noopener">OpenGL各坐标系及模型矩阵、投影矩阵等的深入理解</a><br><a href="https://www.cnblogs.com/liangliangh/p/4116164.html" target="_blank" rel="noopener">OpenGL管线（用经典管线代说着色器内部）</a><br><a href="https://blog.csdn.net/jeffasd/article/details/77989274" target="_blank" rel="noopener">OpenGL shader GLSL 中文手册</a><br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/" target="_blank" rel="noopener">坐标系统</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就听过大名鼎鼎的 OpenGL，却迟迟没有实践学习，有些惭愧。今天开始通过实践+博文方式学习掌握 OpenGL。此文对于 OpenGL 的学习分为以下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenGL 基础概念&lt;/li&gt;
&lt;li&gt;OpenGL 坐标系理解&lt;/li&gt;
&lt;li&gt;OpenGL 渲染管线&lt;/li&gt;
&lt;li&gt;OpenGL 着色语言&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android 知识简记</title>
    <link href="http://yhaowa.gitee.io/c75061d/"/>
    <id>http://yhaowa.gitee.io/c75061d/</id>
    <published>2019-06-01T12:42:37.000Z</published>
    <updated>2020-03-14T10:56:17.333Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1.网络&amp;算法&amp;数据结构</li><li>2.Java 基础&amp;容器&amp;同步&amp;设计模式</li><li>3.Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理</li><li>4.Android 基础&amp;性能优化&amp;Framwork</li><li>5.Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩&amp;AOP</li><li>6.JNI&amp;音视频&amp;FFmpeg&amp;播放器</li><li>7.AndroidStudio&amp;Lint&amp;gradle&amp;maven&amp;CI&amp;CD</li></ul><a id="more"></a><h1 id="1-网络-amp-算法-amp-数据结构"><a href="#1-网络-amp-算法-amp-数据结构" class="headerlink" title="1.网络&amp;算法&amp;数据结构"></a>1.网络&amp;算法&amp;数据结构</h1><h4 id="网络协议模型"><a href="#网络协议模型" class="headerlink" title="网络协议模型"></a>网络协议模型</h4><ul><li>应用层：负责处理特定的应用程序细节，如 HTTP、FTP、DNS</li><li>运输层：为两台主机提供端到端的基础通信，如 TCP、UDP</li><li>网络层：控制分组传输、路由选择等，如 IP</li><li>链路层：操作系统设备驱动程序、网卡相关接口</li></ul><h4 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h4><ul><li>TCP 连接；可靠；有序；面向字节流；速度慢；较重量；全双工；适用于文件传输、浏览器等<br>全双工：A 给 B 发消息的同时，B 也能给 A 发<br>半双工：A 给 B 发消息的同时，B 不能给 A 发</li><li>UDP 无连接；不可靠；无序；面向报文；速度快；轻量；适用于即时通讯、视频通话等</li></ul><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><ol><li>A：你能听到吗？</li><li>B：我能听到，你能听到吗？</li><li>A：我能听到，开始吧</li></ol><ul><li>A 和 B 两方都要能确保：我说的话，你能听到；你说的话，我能听到。所以需要三次握手</li></ul><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><ol><li>A：我说完了</li><li>B：我知道了，等一下，我可能还没说完</li><li>B：我也说完了</li><li>A：我知道了，结束吧</li></ol><ul><li>B 收到 A 结束的消息后 B 可能还没说完，没法立即回复结束标示，只能等说完后再告诉 A ：我说完了</li></ul><h4 id="POST-和-GET-区别"><a href="#POST-和-GET-区别" class="headerlink" title="POST 和 GET 区别"></a>POST 和 GET 区别</h4><ul><li>Get 参数放在 url 中；Post 参数放在 request Body 中</li><li>Get 可能不安全，因为参数放在 url 中</li></ul><h4 id="HTTP-请求过程"><a href="#HTTP-请求过程" class="headerlink" title="HTTP 请求过程"></a>HTTP 请求过程</h4><ol><li>DNS 域名解析</li><li>TCP 三次握手建立连接</li><li>发起 HTTP 请求</li></ol><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ul><li>HTTP 是超文本传输协议，明文传输；HTTPS 使用 SSL 协议对 HTTP 传输数据进行了加密</li><li>HTTP 默认 80 端口；HTTPS 默认 443 端口</li><li>优点：安全</li><li>缺点：费时、SSL 证书收费，加密能力还是有限的，但是比 HTTP 强多了</li><li>加密过程：</li></ul><h4 id="平衡二叉树、二叉查找树、红黑树"><a href="#平衡二叉树、二叉查找树、红黑树" class="headerlink" title="平衡二叉树、二叉查找树、红黑树"></a>平衡二叉树、二叉查找树、红黑树</h4><h1 id="2-Java-基础-amp-容器-amp-同步-amp-设计模式"><a href="#2-Java-基础-amp-容器-amp-同步-amp-设计模式" class="headerlink" title="2.Java 基础&amp;容器&amp;同步&amp;设计模式"></a>2.Java 基础&amp;容器&amp;同步&amp;设计模式</h1><h4 id="StringBuilder、StringBuffer、-、String-concat-链接字符串："><a href="#StringBuilder、StringBuffer、-、String-concat-链接字符串：" class="headerlink" title="StringBuilder、StringBuffer、+、String.concat 链接字符串："></a>StringBuilder、StringBuffer、+、String.concat 链接字符串：</h4><ul><li>StringBuffer 线程安全，StringBuilder 线程不安全</li><li>+实际上是用 StringBuilder 来实现的，所以非循环体可以直接用 +，循环体不行，因为会频繁创建 StringBuilder</li><li>String.concat 实质是 new String ，效率也低，耗时排序：StringBuilder &lt; StringBuffer &lt; concat &lt; +</li></ul><h4 id="Java-泛型擦除"><a href="#Java-泛型擦除" class="headerlink" title="Java 泛型擦除"></a>Java 泛型擦除</h4><ul><li>修饰成员变量等类结构相关的泛型不会被擦除</li><li>容器类泛型会被擦除</li></ul><h4 id="Exception-和-Error"><a href="#Exception-和-Error" class="headerlink" title="Exception 和 Error"></a>Exception 和 Error</h4><ul><li>Exception 和 Error 都继承自 Throwable</li><li>Error 大部分是指不可恢复的错误状态，比如 OOM，所以也不需要捕获</li><li>Exception 分为 CheckedException 和 UnCheckedException<ul><li>CheckedException：必须显式捕获，受编译器检查，比如 io 操作</li><li>UnCheckedException：不用显示捕获，比如空指针、数组越界等</li></ul></li></ul><h4 id="IO-、-NIO、-OKIO"><a href="#IO-、-NIO、-OKIO" class="headerlink" title="IO 、 NIO、 OKIO"></a>IO 、 NIO、 OKIO</h4><ul><li>IO 是面向流的，一次一个字节的处理，NIO 是面向缓冲区的，一次产生或消费一个数据块</li><li>IO 是阻塞的，NIO 是非阻塞的</li><li>NIO 支持内存映射方式</li><li>okio 相比 io 和 nio，api 更简单易用</li><li>okio 支持超时机制</li><li>okio 引入 ByteString 空间换时间提高性能</li><li>okio 采用 segment 机制进行内存共享，节省 copy 时间消耗</li></ul><h4 id="ArrayList、LinkedList"><a href="#ArrayList、LinkedList" class="headerlink" title="ArrayList、LinkedList"></a>ArrayList、LinkedList</h4><ul><li><p>ArrayList</p><ul><li>基于数组实现，查找快：o(1)，增删慢：o(n)</li><li>初始容量为10，扩容通过 System.arrayCopy 方法</li></ul></li><li><p>LinkedList</p><ul><li>基于双向链表实现，查找慢：o(n)，增删快：o(1)</li><li>封装了队列和栈的调用</li></ul></li></ul><h4 id="HashMap-、HashTable、HashSet"><a href="#HashMap-、HashTable、HashSet" class="headerlink" title="HashMap 、HashTable、HashSet"></a>HashMap 、HashTable、HashSet</h4><ul><li><p>HashMap（允许 key/value 为 null）</p><ul><li>基于数组和单向链表实现，数组是 HashMap 的主体；链表是为解决哈希冲突而存在的，存放的是key和value结合的实体</li><li>数组索引通过 key.hashCode（还会二次 hash） 得到，在链表上通过 key.equals 索引</li><li>哈希冲突落在同一个桶中时，直接放在链表头部（java1.8后放到尾部）</li><li>JAVA 8 中链表数量大于 8 时会转为红黑树存储，查找时间由 O(n) 变为 O(logn)</li><li>数组长度总是2的n次方：这样就能通过位运算实现取余，从而让 index 能落在数组长度范围内</li><li>加载因子（默认0.75）表示添加到多少填充比时进行扩容，填充比大：链表较长，查找慢；填充比小：链表短，查找快</li><li>扩容时直接创建原数组两倍的长度，然后将原有对象再进行hash找到新的index，重新放</li></ul></li><li><p>HashTable（不允许 key/value 为 null)</p><ul><li>数据结构和 HashMap 一样</li><li>线程安全</li></ul></li><li><p>HashSet</p><ul><li>基于 HashMap 实现，元素就是 HashMap 的 key，Value 传入了一个固定值</li></ul></li></ul><h4 id="ArrayMap、SparseArray"><a href="#ArrayMap、SparseArray" class="headerlink" title="ArrayMap、SparseArray"></a>ArrayMap、SparseArray</h4><ul><li><p>ArrayMap</p><ul><li>基于两个数组实现，一个存放 hash；一个存放键值对</li><li>存放 hash 的数组是有序的，查找时使用二分法查找</li><li>发生哈希冲突时键值对数组里连续存放，查找时也是通过 key.equals索引，找不到时先向后再向前遍历相同hash值的键值对数组</li><li>扩容时不像 HashMap 直接 double，内存利用率高；也不需要重建哈希表，只需要调用 system.arraycopy 数组拷贝，性能较高</li><li>不适合存大量数据（1000以下），因为数据量大的时候二分查找相比红黑树会慢很多</li></ul></li><li><p>SparseArray</p><ul><li>基于 ArrayMap，key 只能是特定类型</li></ul></li></ul><h4 id="Concurrent-集合"><a href="#Concurrent-集合" class="headerlink" title="Concurrent 集合"></a>Concurrent 集合</h4><ul><li>ConcurrentHashMap<ul><li>数据结构跟 HashMap 一样，还是数组加链表</li><li>采用 segment 分段锁技术，不像 HashTable 无脑直接同步 put 和 get 操作</li><li>get 操作没有加锁，因为 value 用 volatile 修饰来保证可见行，性能很高</li><li>java1.8 后去除分段锁，采用 CAS 乐观锁加 synchronized 来实现</li></ul></li></ul><h4 id="WeakHashMap-原理"><a href="#WeakHashMap-原理" class="headerlink" title="WeakHashMap 原理"></a>WeakHashMap 原理</h4><h4 id="LRUCache-原理"><a href="#LRUCache-原理" class="headerlink" title="LRUCache 原理"></a>LRUCache 原理</h4><ul><li>基于访问顺序排序的 LinkedHashMap 实现，最近访问的会排在最后</li></ul><h4 id="Volatile-关键字"><a href="#Volatile-关键字" class="headerlink" title="Volatile 关键字"></a>Volatile 关键字</h4><ul><li>只能用来修饰变量，适用修饰可能被多线程同时访问的变量</li><li>相当于轻量级的 synchronized，volatitle 能保证有序性（禁用指令重排序）、可见性</li><li>变量位于主内存中，每个线程还有自己的工作内存，变量在自己线程的工作内存中有份拷贝，线程直接操作的是这个拷贝</li><li>被 volatile 修饰的变量改变后会立即同步到主内存，保持变量的可见性<blockquote><p>双重检查单例，为什么要加 violate？<br>volatile想要解决的问题是，在另一个线程中想要使用instance，发现instance!=null，但是实际上instance还未初始化完毕这个问题。将instance =newInstance();拆分为3句话是。1.分配内存2.初始化3.将instance指向分配的内存空间，volatile可以禁止指令重排序，确保先执行2，后执行3</p></blockquote></li></ul><h4 id="wait-和-sleep"><a href="#wait-和-sleep" class="headerlink" title="wait 和 sleep"></a>wait 和 sleep</h4><ul><li>sleep 是 Thread 的静态方法，可以在任何地方调用</li><li>wait 是 Object 的成员方法，只能在 synchronized 代码块中调用，否则会报 IllegalMonitorStateException 非法监控状态异常</li><li>sleep 不会释放共享资源锁，wait 会释放共享资源锁</li></ul><h4 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h4><ul><li>锁池：某个对象的锁已被线程A拥有，其他线程要执行该对象的 synchronized 方法获取锁时就会进入该对象的锁池，锁池中的线程回去竞争该对象的锁</li><li>等待池：某个线程调用了某个对象的 wait 方法，该线程就会释放该对象的锁，进入该对象的等待池，等待池中的线程不会去竞争该对象的锁</li><li>调用 notify 会随机唤醒等待池中的一个线程，唤醒后会进入到锁池</li><li>调用 notifyAll 会唤醒等待池中的所有线程，唤醒后会都进入到锁池</li></ul><h4 id="lock-和-synchronized"><a href="#lock-和-synchronized" class="headerlink" title="lock 和 synchronized"></a>lock 和 synchronized</h4><ul><li>synchronized 是 Java 关键字，内置特性；Lock 是一个接口</li><li>synchronized 会自动释放锁；lock 需要手动释放，所以需要写到 try catch 块中并在 finally 中释放锁</li><li>synchronized 无法中断等待锁；lock 可以中断</li><li>Lock 可以提高多个线程进行读/写操作的效率</li><li>竞争资源激烈时，lock 的性能会明显的优于 synchronized</li></ul><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul><li>定义：已经获取到锁后，再次调用同步代码块/尝试获取锁时不必重新去申请锁，可以直接执行相关代码</li><li>ReentrantLock 和 synchronized 都是可重入锁</li></ul><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><ul><li>定义：等待时间最久的线程会优先获得锁</li><li>非公平锁无法保证哪个线程获取到锁，synchronized 就是非公平锁</li><li>ReentrantLock 默认时非公平锁，可以设置为公平锁</li></ul><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ul><li>悲观锁：线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁<br>乐观锁：假设没有冲突，不加锁，更新数据时判断该数据是否过期，过期的话则不进行数据更新，适用于读取操作频繁的场景</li><li>乐观锁 CAS：Compare And Swap，更新数据时先比较原值是否相等，不相等则表示数据过去，不进行数据更新</li><li>乐观锁实现：AtomicInteger、AtomicLong、AtomicBoolean</li></ul><h4 id="死锁-4-个必要条件"><a href="#死锁-4-个必要条件" class="headerlink" title="死锁 4 个必要条件"></a>死锁 4 个必要条件</h4><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ul><h4 id="Synchronized-原理"><a href="#Synchronized-原理" class="headerlink" title="Synchronized 原理"></a>Synchronized 原理</h4><ul><li>每个对象都有一个监视器锁：monitor，同步代码块会执行  monitorenter 开始，motnitorexit 结束 </li><li>Wait/notify 就依赖 monitor 监视器，所以在非同步代码块中执行会报 IllegalMonitorStateException 异常</li></ul><h4 id="六大原则（DJ单开一里）"><a href="#六大原则（DJ单开一里）" class="headerlink" title="六大原则（DJ单开一里）"></a>六大原则（DJ单开一里）</h4><ul><li>开闭原则：对拓展开放，对修改关闭</li><li>单一指责原则：一个类指责单一</li><li>里氏替换原则：引用基类的地方都能替换成子类对象</li><li>依赖倒置原则：高层次模块不依赖低层次模块的具体实现，抽象不应该依赖细节</li><li>接口隔离原则：类之间的依赖关系应该建立在最小的接口上</li><li>迪米特原则：一个对象对其他对象应该有尽量少的了解</li></ul><h4 id="Java-23-种设计模式（按目的分类为：5-7-11）"><a href="#Java-23-种设计模式（按目的分类为：5-7-11）" class="headerlink" title="Java 23 种设计模式（按目的分类为：5+7+11）"></a>Java 23 种设计模式（按目的分类为：5+7+11）</h4><blockquote><p>1995 年 GoF（四人组）出了一本设计模式的书，收录了 23 种设计模式，树立设计模式里程碑，也叫：GoF 设计模式</p></blockquote><ul><li>创建型（5）：描述怎么创建对象<ul><li>1.单例模式</li><li>2.原型模式：对象的拷贝</li><li>3.建造者模式</li><li>4.工厂模式：建立一个工厂方法来制造新的对象</li><li>5.抽象工厂模式：</li></ul></li><li>结构型（7）：描述如何将类或对象按某种规则组成更大的结构（键盘记忆：qw sd zzx）<ul><li>1.桥接模式：对于两个或以上纬度独立变化的场景，将抽象与具体实现分离，实例：用不同颜色画不同形状</li><li>2.外观模式：对外有一个统一接口，外部不用关心内部子系统的具体实现，这是”迪米特原则”的典型应用</li><li>3.适配器模式：改变类的接口，使原本由于接口不匹配而无法一起工作的两个类能够在一工作，实例：RecycleView 的 Adapter 不管什么类型的 View 都返回 ViewHolder</li><li>4.代理模式：由代理对象控制对原对象的引用，包括静态代理和动态代理</li><li>5.组合模式：将对象组成树形结构，用于对单个对象和组合对象的使用具有一致性，实例：ViewGroup</li><li>6.装饰模式：对对象包装一层，动态的增加一些额外功能，实例：ContextWrapper 包装 Context</li><li>7.享元模式：复用对象，实例：java 的常量池（比如 String），线程池，Message.obtain 等</li></ul></li><li>行为型（11）：描述类或对象之间怎么相互协作，怎样分配指责（记忆：3者 3短 4长 1模版方法）<ul><li>1.观察者模式：一对多依赖关系，多个观察者可以同时监听某一个对象，实例：jetpack 的 lifeCycle 添加生命周期观察者</li><li>2.中介者模式：定义一个中介对象封装一系列对象的交互，解耦这些对象，实例：MVP 的 P</li><li>3.访问者模式：将作用于某数据结构中各元素的操作分离出来封装成独立的类，对这些元素添加新的操作，但不改变原数据结构，实例：asm 中的 classVisitor 中再分别对类注解、变量、方法等进行处理</li><li>4.状态模式：行为由状态决定，不同状态下由不同行为，与策略模式类似，实例：不同状态下有同一种操作的不同行为的子类实现</li><li>5.命令模式：将一个请求封装为一个对象发出，交给别的对象去处理请求，实例：Handler 发送定义好的消息事件</li><li>6.策略模式：将一系列的算法封装起来，方便替换，实例：动画的时间插值器</li><li>7.责任链模式：让多个对象都有机会处理一个事件，实例：View 事件传递机制</li><li>8.备忘录模式：保存对象之前的状态，方便后面恢复</li><li>9.迭代器模式：提供一种方法遍历容器中的元素，而不需要暴露该对象的内部表示，实例：集合的迭代器</li><li>10.解释器模式：多次出现的问题有一定规律，就可以归纳成一种简单的语言来解释，实例：AndroidManifest 文件、GLES 着色器语言</li><li>11.模版方法模式：定义一套固定步骤，方便直接执行，实例：AsyncTask</li></ul></li></ul><h1 id="3-Java-虚拟机-amp-内存结构-amp-GC-amp-类加载-amp-四种引用-amp-动态代理"><a href="#3-Java-虚拟机-amp-内存结构-amp-GC-amp-类加载-amp-四种引用-amp-动态代理" class="headerlink" title="3.Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理"></a>3.Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理</h1><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>定义：可以理解成一个虚构的计算机，解释自己的字节码指令集映射到本地 CPU 或 OS 的指令集，上层只需关注 Class 文件，与操作系统无关，实现跨平台</li><li>Kotlin 就是能解释成 Class 文件，所以可以跑在 JVM 上</li></ul><h4 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h4><ul><li>Java 多线程之间是通过共享内存来通信的，每个线程都有自己的本地内存</li><li>共享变量存放于主内存中，线程会拷贝一份共享变量到本地内存</li><li>volatile 关键字就是给内存模型服务的，用来保证内存可见性和顺序性</li></ul><h4 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h4><ul><li>线程私有：<ul><li>1.程序计数器：记录正在执行的字节码指令地址，若正在执行 Native 方法则为空</li><li>2.虚拟机栈：执行方法时把方法所需数据存为一个栈帧入栈，执行完后出栈</li><li>3.本地方法栈：同虚拟机栈，但是针对的是 Native 方法</li></ul></li><li>线程共享：<ul><li>1.堆：存储 Java 实例，GC 主要区域，分代收集 GC 方法会吧堆划分为新生代、老年代</li><li>2.方法区：存储类信息，常量池，静态变量等数据</li></ul></li></ul><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><ul><li>回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收</li><li>回收类型：<ul><li>1.堆中的对象<ul><li>分代收集 GC 方法会吧堆划分为新生代、老年代</li><li>新生代：新建小对象会进入新生代；通过复制算法回收对象</li><li>老年代：新建大对象及老对象会进入老年代；通过标记-清除算法回收对象</li></ul></li><li>2.方法区中的类信息、常量池</li></ul></li><li>判断一个对象是否可被回收：<ul><li>1.引用计数法<ul><li>缺点：循环引用</li></ul></li><li>2.可达性分析法<ul><li>定义：从 GC ROOT 开始搜索，不可达的对象都是可以被回收的</li><li>GC ROOT ：<ul><li>1.虚拟机栈/本地方法栈中引用的对象</li><li>2.方法区中常量/静态变量引用的对象</li></ul></li></ul></li></ul></li></ul><h4 id="Minor-GC-Major-GC-Full-GC"><a href="#Minor-GC-Major-GC-Full-GC" class="headerlink" title="Minor GC/Major GC/Full GC"></a>Minor GC/Major GC/Full GC</h4><ul><li>Minor GC（Young GC）：即新生代（分为一个 Eden 区和两个 Survivor 区）的垃圾回收<ul><li>Eden 区无用对象被回收，存活对象会移到 Survivor 区</li><li>Survivor 区的存活对象会被复制到另一个 Survivor 区，复制次数也记做年龄，年龄足够大时（15）会移到老年代</li><li>如果 Survivor 区已满，则存活对象会被提前移动到老年代（过早提升），如果老年代也无法容纳，则会触发 Full GC（提升失败）</li><li>老年代的对象可能引用新生代对象，所以这个引用会被作为 GC Roots</li></ul></li><li>Major GC：通常是跟 Full GC 等价的，回收整个堆</li><li>Full GC：回收整个堆，包括新生代和老年代<ul><li>当要在老年代分配空间但无法容纳时触发</li><li>当主动调用 System.gc 时触发</li></ul></li></ul><h4 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h4><ul><li>强引用：不会被回收</li><li>软引用：内存不足时会被回收</li><li>弱引用：gc 时会被回收</li><li>虚引用：无法通过虚引用得到对象，可以监听对象的回收</li></ul><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><ul><li>类的生命周期：<br>1.加载；2.验证；3.准备；4.解析；5.初始化；6.使用；7.卸载</li><li>类加载过程：<br>1.加载：获取类的二进制字节流；生成方法区的运行时存储结构；在内存中生成 Class 对象<br>2.验证：确保该 Class 字节流符合虚拟机要求<br>3.准备：初始化静态变量<br>4.解析：将常量池的符号引用替换为直接引用<br>5.初始化：执行静态块代码、类变量赋值</li><li>类加载时机：<br>1.实例化对象<br>2.调用类的静态方法<br>3.调用类的静态变量（放入常量池的常量除外）</li><li>类加载器：负责加载 class 文件<br>1.引导类加载器 - 没有父类加载器<br>2.拓展类加载器 - 继承自引导类加载器<br>3.系统类加载器 - 继承自拓展类加载器</li><li>双亲委托模型：<ul><li>当要加载一个 class 时，会先逐层向上让父加载器先加载，加载失败才会自己加载</li><li>为什么叫双亲？不考虑自定义加载器，系统类加载器需要网上询问两层，所以叫双亲</li><li>判断是否是同一个类时，除了类信息，还必须时同一个类加载器</li><li>优点：<ul><li>防止重复加载，父加载器加载过了就没必要加载了</li><li>安全，防止篡改核心库类</li></ul></li></ul></li></ul><h4 id="动态代理原理及实现"><a href="#动态代理原理及实现" class="headerlink" title="动态代理原理及实现"></a>动态代理原理及实现</h4><ul><li>InvocationHandler 接口，动态代理类需要实现这个接口</li><li>Proxy.newProxyInstance，用于动态创建代理对象</li><li>Retrofit 应用： Retrofit 通过动态代理，为我们定义的请求接口都生成一个动态代理对象，实现请求</li></ul><h1 id="4-Android-基础-amp-性能优化-amp-Framwork"><a href="#4-Android-基础-amp-性能优化-amp-Framwork" class="headerlink" title="4.Android 基础&amp;性能优化&amp;Framwork"></a>4.Android 基础&amp;性能优化&amp;Framwork</h1><h4 id="Android-解析-XML"><a href="#Android-解析-XML" class="headerlink" title="Android 解析 XML"></a>Android 解析 XML</h4><ul><li>SAX：流式解析</li><li>DOM：先把 XML 全部读取到内存，再访问树形结构，很消耗内存</li><li>PULL：流式解析，Android 内置的默认解析方式</li></ul><h4 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h4><ul><li>A 打开 B 界面，会先执行 A 的 onPause，再执行 B 的 onCreate、onStart、onResume，再执行 A 的 onStop</li><li>B 界面的打开依赖 A 界面 onPause 方法执行完，所以不要在 onPause 中做耗时操作</li></ul><h4 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h4><ul><li>standard 标准模式</li><li>singleTop 栈顶复用模式，<ul><li>推送点击消息界面</li></ul></li><li>singleTask 栈内复用模式，<ul><li>首页</li></ul></li><li>singleInstance 单例模式，单独位于一个任务栈中<ul><li>拨打电话界面</li></ul></li><li>细节：<ul><li>taskAffinity：任务相关性，用于指定任务栈名称，默认为应用包名</li><li>allowTaskReparenting：允许转移任务栈</li></ul></li></ul><h4 id="MeasureSpec-测量规则"><a href="#MeasureSpec-测量规则" class="headerlink" title="MeasureSpec 测量规则"></a>MeasureSpec 测量规则</h4><ul><li>EXACTLY：父 View 指定了子 View 确切的大小</li><li>AT_MOST：父 View 指定一个大小，子 View 不能超过这个值</li><li>UNSPECIFIEND： 父 View 不对子 View 有任何限制</li></ul><h4 id="View-工作原理"><a href="#View-工作原理" class="headerlink" title="View 工作原理"></a>View 工作原理</h4><ul><li>DecorView (FrameLayout)<ul><li>LinearLayout<ul><li>titlebar<ul><li>Content</li><li>调用 setContentView 设置的 View</li></ul></li></ul></li></ul></li></ul><ul><li>ViewRoot 的 performTraversals 方法调用触发开始 View 的绘制，然后会依次调用:<ul><li>performMeasure：遍历 View 的 measure 测量尺寸</li><li>performLayout：遍历 View 的 layout 确定位置</li><li>performDraw：遍历 View 的 draw 绘制</li></ul></li></ul><h4 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h4><ul><li>一个 MotionEvent 产生后，按 Activity -&gt; Window -&gt; decorView -&gt; View 顺序传递，View 传递过程就是事件分发，主要依赖三个方法:</li><li>dispatchTouchEvent：用于分发事件，只要接受到点击事件就会被调用，返回结果表示是否消耗了当前事件</li><li>onInterceptTouchEvent：用于判断是否拦截事件，当 ViewGroup 确定要拦截事件后，该事件序列都不会再触发调用此 ViewGroup 的 onIntercept</li><li>onTouchEvent：用于处理事件，返回结果表示是否处理了当前事件，未处理则传递给父容器处理</li><li>细节：<ul><li>一个事件序列只能被一个 View 拦截且消耗</li><li>View 没有 onIntercept 方法，直接调用 onTouchEvent 处理</li><li>OnTouchListener 优先级比 OnTouchEvent 高，onClickListener 优先级最低</li><li>requestDisallowInterceptTouchEvent 可以屏蔽父容器 onIntercet 方法的调用</li></ul></li></ul><h4 id="Window-、-WindowManager、WMS、SurfaceFlinger"><a href="#Window-、-WindowManager、WMS、SurfaceFlinger" class="headerlink" title="Window 、 WindowManager、WMS、SurfaceFlinger"></a>Window 、 WindowManager、WMS、SurfaceFlinger</h4><ul><li>WIndow：抽象概念不是实际存在的，而是以 View 的形式存在，通过 PhoneWindow 实现</li><li>WindowManager：外界访问 Window 的入口，内部与 WMS 交互是个 IPC 过程</li><li>WMS：管理窗口 Surface 的布局和次序，作为系统级服务单独运行在一个进程</li><li>SurfaceFlinger：将 WMS 维护的窗口按一定次序混合后显示到屏幕上</li></ul><h4 id="View-动画、帧动画及属性动画"><a href="#View-动画、帧动画及属性动画" class="headerlink" title="View 动画、帧动画及属性动画"></a>View 动画、帧动画及属性动画</h4><ul><li>View 动画：<ul><li>作用对象是 View，可用 xml 定义，建议 xml 实现比较易读</li><li>支持四种效果：平移、缩放、旋转、透明度</li></ul></li><li>帧动画：<ul><li>通过 AnimationDrawable 实现，容易 OOM</li></ul></li><li>属性动画：<ul><li>可作用于任何对象，可用 xml 定义，Android 3 引入，建议代码实现比较灵活</li><li>包括 ObjectAnimator、ValuetAnimator、AnimatorSet</li><li>时间插值器：根据时间流逝的百分比计算当前属性改变的百分比<ul><li>系统预置匀速、加速、减速等插值器</li></ul></li><li>类型估值器：根据当前属性改变的百分比计算改变后的属性值<ul><li>系统预置整型、浮点、色值等类型估值器</li></ul></li><li>使用注意事项：<ul><li>避免使用帧动画，容易OOM</li><li>界面销毁时停止动画，避免内存泄漏</li><li>开启硬件加速，提高动画流畅性 ，硬件加速：<ul><li>将 cpu 一部分工作分担给 gpu ，使用 gpu 完成绘制工作</li><li>从工作分摊和绘制机制两个方面优化了绘制速度</li></ul></li></ul></li></ul></li></ul><h4 id="Handler、MessageQueue、Looper-及-postDelayed-原理"><a href="#Handler、MessageQueue、Looper-及-postDelayed-原理" class="headerlink" title="Handler、MessageQueue、Looper 及 postDelayed 原理"></a>Handler、MessageQueue、Looper 及 postDelayed 原理</h4><ul><li>Handler：开发直接接触的类，内部持有 MessageQueue 和 Looper</li><li>MessageQueue：消息队列，内部通过单链表存储消息</li><li>Looper：内部持有 MessageQueue，循环查看是否有新消息，有就处理，没就阻塞</li><li>postDelayed 其实就是调用 postAtTime 实现的，传入的时间戳基于 SystemClock.uptimeMillis，即 boot 时间</li><li>进一步会调用 MessageQueue#enqueueMessage 将消息插入到队列</li><li>插入消息时会根据消息执行时刻 Message#when 来决定插入到什么位置，when 为 0 或最早执行就会插入到链表头，否则按执行时刻排序插入</li><li>插入后如果正在阻塞则会尝试唤醒，插入到头部则会唤醒，插入到队列中则再根据其他条件判断是否需要唤醒</li><li>Looper#loop 中调用 MessageQueue#next 取消息，next 方法除非是即将销毁时会返回 null，否则就会返回消息，没有消息就阻塞。如果当前时刻还没到消息的执行时刻 when，就会再阻塞这个时间差的时间</li><li>阻塞是调用 nativePollOnce 实现，基于 Linux epoll 事件管理机制，主线程不会因为 Looper 阻塞是因为系统每 16ms 会发送一个刷新 UI 消息唤醒 </li><li>Looper#loop 中取出消息后通过 Message#target 拿到 handler，然后调用 Handler#dispatchMessage 分发处理消息</li></ul><h4 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h4><ul><li>MVP：Model：处理数据；View：控制视图；Presenter：分离 Activity 和 Model</li><li>MVVM：Model：处理获取保存数据；View：控制视图；ViewModel：数据容器<ul><li>使用 Jetpack 组件架构的 LiveData、ViewModel 便捷实现 MVVM</li></ul></li></ul><h4 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h4><ul><li>如何感知声明周期：像 Glide 一样给界面添加了无视图的 Fragment</li></ul><h4 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h4><ul><li>界面旋转短暂销毁重建时如何保存 ViewModel ？<ul><li>ViewModel 保存在 ViewModelStore 中</li><li>当 Activity 配置变更销毁时，系统会调用 onRetainNonConfigurationInstance 保存 NonConfigurationInstances，而 ViewModel 就保存在 NonConfigurationInstances 中</li><li>重建时 onCreate 方法通过 getLastNonConfigurationInstance 方法获取到 NonConfigurationInstances，从而获取到 ViewModelStore</li></ul></li></ul><h4 id="Serializable、Parcelable"><a href="#Serializable、Parcelable" class="headerlink" title="Serializable、Parcelable"></a>Serializable、Parcelable</h4><ul><li>Serializable ：Java 序列化方式，适用于存储和网络传输，serialVersionUID 用于确定反序列化和类版本是否一致，不一致时反序列化回失败</li><li>Parcelable ：Android 序列化方式，适用于组件通信数据传递，性能高，因为不像 Serializable 一样有大量反射操作，频繁 GC</li></ul><h4 id="Linux-IPC-方式"><a href="#Linux-IPC-方式" class="headerlink" title="Linux IPC 方式"></a>Linux IPC 方式</h4><ul><li>管道：</li><li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段</li><li>信号：不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等（Android中的Kill Process采用的就是signal（信号）机制）</li><li>消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信</li><li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决</li><li>socket：</li></ul><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><ul><li>Android 中基于 C/S 结构的一种面向对象的进程间通信的机制</li><li>主要用在 system_server 进程与上层 App 层的 IPC 交互</li><li>包含：Client,Server,Binder 驱动和 ServiceManager 四大组成部分</li></ul><h4 id="Android-为什么选择-binder"><a href="#Android-为什么选择-binder" class="headerlink" title="Android 为什么选择 binder"></a>Android 为什么选择 binder</h4><ul><li>性能：使用 mmap 一次数据拷贝实现 IPC，传统 IPC：用户A空间-&gt;内核-&gt;用户B空间；mmap 将内核与用户B空间映射，实现直接从用户A空间-&gt;用户B空间，而 Linux 的管道、消息队列、Socket 都需要拷贝两次，binder 仅次于共享内存</li><li>稳定性：基于C/S架构，架构清晰，稳定性好，不像共享内存实现方式复杂，需要充分考虑访问临界资源的并发同步问题</li><li>安全：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份</li></ul><h4 id="Android-IPC-方式"><a href="#Android-IPC-方式" class="headerlink" title="Android IPC 方式"></a>Android IPC 方式</h4><ul><li>Intent extras、Bundle：要求传递数据能被序列化，实现 Parcelable、Serializable ，适用于四大组件通信</li><li>文件共享：适用于交换简单的数据实时性不高的场景</li><li>AIDL：AIDL 接口实质上是系统提供给我们可以方便实现 BInder 的工具<ul><li>Android Interface Definition Language，可实现跨进程调用方法</li><li>服务端：将暴漏给客户端的接口声明在 AIDL 文件中，创建 Service 实现 AIDL 接口并监听客户端连接请求</li><li>客户端：绑定服务端 Service ，绑定成功后拿到服务端 Binder 对象转为 AIDL 接口调用</li><li>RemoteCallbackList 实现跨进程接口监听，同个 Binder 对象做 key 存储客户端注册的 listener</li><li>监听 Binder 断开：1.Binder.linkToDeath 设置死亡代理；2. onServiceDisconnected 回调</li></ul></li><li>Messenger：基于 AIDL 实现，服务端串行处理，主要用于传递消息，适用于低并发一对多通信</li><li>ContentProvider：基于 Binder 实现，适用于一对多进程间数据共享</li><li>Socket：TCP、UDP，适用于网络数据交换</li></ul><h4 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h4><p><img src="../img/20.jpg" alt></p><ul><li>Linux 内核</li><li>HAL</li><li>本地 Native 库和 Android 运行时环境</li><li>Framework 框架层</li><li>应用层</li></ul><h4 id="Android-系统启动流程"><a href="#Android-系统启动流程" class="headerlink" title="Android 系统启动流程"></a>Android 系统启动流程</h4><ul><li>按电源键 -&gt; 加载引导程序 BootLoader 到 RAM -&gt; 执行 BootLoader 程序启动内核 -&gt; 启动 init 进程 -&gt; 启动 Zygote 和各种守护进程 -&gt;</li><li>启动  System Server 服务进程开启 AMS、WMS 等 -&gt; 启动 Launcher 应用进程</li></ul><h4 id="App-启动流程"><a href="#App-启动流程" class="headerlink" title="App 启动流程"></a>App 启动流程</h4><ul><li>Launcher 中点击一个应用图标 -&gt; 通过 AMS 查找应用进程，若不存在就通过 Zygote 进程 fork </li></ul><h4 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h4><ul><li>进程优先级：1.前台进程 ；2.可见进程；3.服务进程；4.后台进程；5.空进程</li><li>进程被 kill 场景：1.切到后台内存不足时被杀；2.切到后台厂商省电机制杀死；3.用户主动清理</li><li>保活方式：<ul><li>1.Activity 提权：挂一个 1像素 Activity 将进程优先级提高到前台进程</li><li>2.Service 提权：启动一个前台服务（API&gt;18会有正在运行通知栏）</li><li>3.广播拉活</li><li>4.Service 拉活</li><li>5.JobScheduler 定时任务拉活</li><li>6.双进程拉活</li></ul></li></ul><h4 id="网络优化及检测"><a href="#网络优化及检测" class="headerlink" title="网络优化及检测"></a>网络优化及检测</h4><ul><li>速度：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；4.IP 直连省去 DNS 解析时间</li><li>成功率：1.失败重试策略；</li><li>流量：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；5.文件下载断点续传 ；6.缓存</li><li>协议层的优化，比如更优的 http 版本等</li><li>监控：Charles 抓包、Network Monitor 监控流量</li></ul><h4 id="UI卡顿优化"><a href="#UI卡顿优化" class="headerlink" title="UI卡顿优化"></a>UI卡顿优化</h4><ul><li>减少布局层级及控件复杂度，避免过度绘制</li><li>使用 include、merge、viewstub</li><li>优化绘制过程，避免在 Draw 中频繁创建对象、做耗时操作</li></ul><h4 id="内存泄漏场景及规避"><a href="#内存泄漏场景及规避" class="headerlink" title="内存泄漏场景及规避"></a>内存泄漏场景及规避</h4><ul><li>1.静态变量、单例强引跟生命周期相关的数据或资源，包括 EventBus</li><li>2.游标、IO 流等资源忘记主动释放</li><li>3.界面相关动画在界面销毁时及时暂停</li><li>4.内部类持有外部类引用导致的内存泄漏<ul><li>handler 内部类内存泄漏规避：1.使用静态内部类+弱引用 2.界面销毁时清空消息队列</li><li>检测：Android Studio Profiler </li></ul></li></ul><h4 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h4><ul><li>内存问题<ul><li>内存泄漏</li><li>内存抖动：频繁创建临时对象</li><li>Bitmap 大内存：规避位图超标</li><li>代码质量：枚举代替 intdef，使用 SparseArray 代替 Hashmap</li></ul></li><li>检测工具<ul><li>MAT(Memory Analysis Tools) ，可分析 Java 堆数据，可查看实例占用空间、引用关系等</li><li>Android Studio 自带的 Profiler</li><li>LeakCanary</li></ul></li></ul><h4 id="LeakCanary-原理"><a href="#LeakCanary-原理" class="headerlink" title="LeakCanary 原理"></a>LeakCanary 原理</h4><ul><li>通过弱引用和引用队列监控对象是否被回收</li><li>比如 Activity 销毁时开始监控此对象，检测到未被回收则主动 gc ，然后继续监控</li></ul><h4 id="OOM-场景及规避"><a href="#OOM-场景及规避" class="headerlink" title="OOM 场景及规避"></a>OOM 场景及规避</h4><ul><li>加载大图：减小图片</li><li>内存泄漏：规避内存泄漏</li></ul><h4 id="ANR-问题及分析"><a href="#ANR-问题及分析" class="headerlink" title="ANR 问题及分析"></a>ANR 问题及分析</h4><ul><li>anr 分类<ul><li>主线程 5s 内没有处理完输入事件</li><li>service 阻塞 20s</li><li>前台广播阻塞 10s 或后台广告阻塞 20s</li></ul></li><li>anr 发生过程<ul><li>1.捕获到 anr，发送 linux 信号量 3</li><li>2.进程接受到信号量将 anr 信息写入 data/anr/traces.txt 文件</li><li>3.Log 打印 anr 信息</li><li>4.进程进入 anr 状态，弹出 anr 提示框</li></ul></li><li>监控 anr<ul><li>1.Android 5.0 以下监听 traces.txt 文件写入</li><li>2.每隔 5s 向主线程发送消息判断主线程是否阻塞</li></ul></li><li>分析 anr<ul><li>查看 cpu 负载是否是 cpu 资源紧张导致</li><li>查看堆栈看是否是我们的代码耗时过长</li></ul></li><li>避免 anr<ul><li>主线程中不要做耗时操作，注意使用 IntentService </li><li>降低子线程优先级，让主线程可以更多的获取到 cpu 资源</li></ul></li></ul><h1 id="5-Android-模块化-amp-热修复-amp-热更新-amp-打包-amp-混淆-amp-压缩-amp-AOP"><a href="#5-Android-模块化-amp-热修复-amp-热更新-amp-打包-amp-混淆-amp-压缩-amp-AOP" class="headerlink" title="5.Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩&amp;AOP"></a>5.Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩&amp;AOP</h1><h4 id="Dalvik-和-ART"><a href="#Dalvik-和-ART" class="headerlink" title="Dalvik 和 ART"></a>Dalvik 和 ART</h4><ul><li>Dalvik<ul><li>谷歌设计专用于 Android 平台的 Java 虚拟机，可直接运行 .dex 文件，适合内存和处理速度有限的系统 </li><li>JVM 指令集是基于栈的；Dalvik 指令集是基于寄存器的，代码执行效率更优</li></ul></li><li>ART<ul><li>Dalvik 每次运行都要将字节码转换成机器码；ART 在应用安装时就会转换成机器码，执行速度更快</li><li>ART 存储机器码占用空间更大，空间换时间</li></ul></li></ul><h4 id="APK-打包流程"><a href="#APK-打包流程" class="headerlink" title="APK 打包流程"></a>APK 打包流程</h4><ul><li>1.aapt 打包资源文件生成 R.java 文件；aidl 生成 java 文件</li><li>2.将 java 文件编译为 class 文件</li><li>3.将工程及第三方的 class 文件转换成 dex 文件</li><li>4.将 dex 文件、so、编译过的资源、原始资源等打包成 apk 文件</li><li>5.签名</li><li>6.资源文件对齐，减少运行时内存</li></ul><h4 id="App-安装过程"><a href="#App-安装过程" class="headerlink" title="App 安装过程"></a>App 安装过程</h4><ul><li>首先要解压 APK，资源、so等放到应用目录</li><li>Dalvik 会将 dex 处理成 ODEX ；ART 会将 dex 处理成 OAT；</li><li>OAT 包含 dex 和安装时编译的机器码</li></ul><h4 id="瘦包"><a href="#瘦包" class="headerlink" title="瘦包"></a>瘦包</h4><ul><li>1.资源方面：资源在线化、图片使用 webp 格式、tint 着色生成不同色调的切、使用 icon font</li><li>2.so 库：保留一个 cpu 架构的 so 文件</li><li>3.AS Inspect Code 清除无用代码和资源</li><li>4.代码混淆：使用 ProGuard 可以移除无用的类、字段、方法（压缩），移除无用字节码指令 </li><li>5.不保留行号：使用 ProGuard 配置不保留行号 </li><li>6.开启 shrinkResources：移除无用资源 </li><li>7.资源混淆：使用 AndResGuard 缩短资源长度，对资源进行 7z 压缩等（直接对apk操作）</li><li>8.代码结构简化，比如用 intdef 代替 枚举(一个枚举有1~1.4kb大小)</li><li>9.使用 compileOnly 在只需编译时依赖的场景，不会打到 apk 里</li><li>10.使用 thinR 插件剔除 R 文件，将引用 R 字段的地方替换成对应常量</li><li>11.Android 7.0 使用 V2(apksigner) 代替 V1(jarsigner) 签名工具</li><li>12.动态加载 so 库(System.load加载绝对路径文件)、插件化技术、App Bundle</li><li>13.使用 facebook 的 redex</li></ul><h4 id="Android-类加载器"><a href="#Android-类加载器" class="headerlink" title="Android 类加载器"></a>Android 类加载器</h4><ul><li>BootClassLoader(加载 Franwork 级别的类)</li><li>PathClassLoader(加载系统类和 data/app 应用目录下的 dex 文件)</li><li>DexClassLoader(加载自定义的 dex 文件或 jar，支持从 sd 卡中进行加载)</li></ul><h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><ul><li>DexClassLoader 动态加载</li><li>VirtualAPK：动态加载，四大组件未注册问题通过 hook AMS、Instrumentation 等解决</li></ul><h4 id="热修复原理"><a href="#热修复原理" class="headerlink" title="热修复原理"></a>热修复原理</h4><ul><li>Native Hook（AndFix）：直接在 native 层进行方法的结构体信息对换</li><li>分包（QFix）：插入新 dex 到 dexElements[]，利用 ClassLoader 通过遍历 dexElements[] 来 findClass 的特性</li><li>Java Hook（Robust）：hook 每个方法，在每个方法里埋好准备替换的逻辑</li></ul><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><ul><li>ARoute 路由实现：通过 APT 解析 @Route 等注解，结合 JavaPoet 生成路由表，即路由与 Activity 的映射关系</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li>基于 Gradle Transform API 创建 TransForm ，其执行时机在 class 被打包成 dex 之前</li><li>在 TransForm 中通过 javassist 或 asm 修改字节码</li><li>基于 Gradle Plugin API 自定义插件，应用自定义的 TransForm</li></ul><h1 id="6-JNI-amp-音视频-amp-FFmpeg-amp-播放器"><a href="#6-JNI-amp-音视频-amp-FFmpeg-amp-播放器" class="headerlink" title="6.JNI&amp;音视频&amp;FFmpeg&amp;播放器"></a>6.JNI&amp;音视频&amp;FFmpeg&amp;播放器</h1><h4 id="SurfaceView、TextureView、SurfaceTexture、GLSurfaceView"><a href="#SurfaceView、TextureView、SurfaceTexture、GLSurfaceView" class="headerlink" title="SurfaceView、TextureView、SurfaceTexture、GLSurfaceView"></a>SurfaceView、TextureView、SurfaceTexture、GLSurfaceView</h4><ul><li>SurfaceView：使用双缓冲机制，有自己的 surface，在一个独立的线程里绘制，Android7.0之前不能平移、缩放</li><li>TextureView：持有 SurfaceTexture，将图像处理为 OpenGL 纹理更新到 HardwareLayer，必须开启硬件加速，Android5.0之前在主线程渲染，之后有独立的渲染线程，可以平移、旋转、缩放</li><li>SurfaceTexture：将图像流转为 OpenGL 外部纹理，不直接显示</li><li>GLSurfaceView：加入 EGL 管理，自带 GL 上下文和 GL 渲染线程</li></ul><h4 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h4><h4 id="Native-Crash"><a href="#Native-Crash" class="headerlink" title="Native Crash"></a>Native Crash</h4><ul><li>崩溃过程：native crash 时操作系统会向进程发送信号，崩溃信息会写入到 data/tombstones 下，并在 logcat 输出崩溃日志</li><li>定位：so 库剥离调试信息的话，只有相对位置没有具体行号，可以使用 NDK 提供的 addr2line 或 ndk-stack 来定位</li><li>addr2line：根据有调试信息的 so 和相对位置定位实际的代码处</li><li>ndk-stack：可以分析 tombstone 文件，得到实际的代码调用栈</li></ul><h4 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h4><ul><li>基于命令方式实现了一个音视频编辑 App：<a href="https://github.com/yhaolpz/FFmpegCmd" target="_blank" rel="noopener">FFEditor</a></li><li>集成编译了 AAC、MP3、H264 编码器</li></ul><h4 id="播放器原理"><a href="#播放器原理" class="headerlink" title="播放器原理"></a>播放器原理</h4><ul><li>视频播放原理：（mp4、flv）-&gt; 解封装 -&gt; （mp3/aac、h264/h265）-&gt; 解码 -&gt; （pcm、yuv）-&gt; 音视频同步 -&gt; 渲染播放</li><li>音视频同步：<ul><li>选择参考时钟源：音频时间戳、视频时间戳和外部时间三者选择一个作为参考时钟源（一般选择音频，因为人对音频更敏感，ijk 默认也是音频）</li><li>通过等待或丢帧将视频流与参考时钟源对齐，实现同步</li></ul></li></ul><h4 id="IjkPlayer-原理"><a href="#IjkPlayer-原理" class="headerlink" title="IjkPlayer 原理"></a>IjkPlayer 原理</h4><ul><li>集成了 MediaPlayer、ExoPlayer 和 IjkPlayer 三种实现，其中 IjkPlayer 基于 FFmpeg 的 ffplay </li><li>音频输出方式：AudioTrack、OpenSL ES；视频输出方式：NativeWindow、OpenGL ES</li></ul><h1 id="7-AndroidStudio-amp-Lint-amp-gradle-amp-maven-amp-CI-amp-CD"><a href="#7-AndroidStudio-amp-Lint-amp-gradle-amp-maven-amp-CI-amp-CD" class="headerlink" title="7.AndroidStudio&amp;Lint&amp;gradle&amp;maven&amp;CI&amp;CD"></a>7.AndroidStudio&amp;Lint&amp;gradle&amp;maven&amp;CI&amp;CD</h1><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><ul><li>Android Lint是Google提供给Android开发者的静态代码检查工具</li><li>使用Lint对Android工程代码进行扫描和检查，可以发现代码潜在的问题，提醒程序员及早修正</li><li>基于 Detector、IssueRegistry 实现，通过 lintChecks project 引入</li></ul><h4 id="CI-amp-CD"><a href="#CI-amp-CD" class="headerlink" title="CI&amp;CD"></a>CI&amp;CD</h4><ul><li>Continuous integration（持续集成，简称CI）：频繁的将代码集成到主干，防止分支大幅偏离主干，方便快速发现错误</li><li>Continuous delivery（持续交付）：频繁地将软件的新版本，交付给质量团队或者用户，以供评审</li><li>Continuous deployment（持续部署）：持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境</li><li>交付后需要进行构建，将源码转换为可以运行的实际代码，常用的构建工具有 Jenkins、Strider</li></ul><blockquote><h5 id="持续补充中…"><a href="#持续补充中…" class="headerlink" title="持续补充中…"></a>持续补充中…</h5></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;1.网络&amp;amp;算法&amp;amp;数据结构&lt;/li&gt;
&lt;li&gt;2.Java 基础&amp;amp;容器&amp;amp;同步&amp;amp;设计模式&lt;/li&gt;
&lt;li&gt;3.Java 虚拟机&amp;amp;内存结构&amp;amp;GC&amp;amp;类加载&amp;amp;四种引用&amp;amp;动态代理&lt;/li&gt;
&lt;li&gt;4.Android 基础&amp;amp;性能优化&amp;amp;Framwork&lt;/li&gt;
&lt;li&gt;5.Android 模块化&amp;amp;热修复&amp;amp;热更新&amp;amp;打包&amp;amp;混淆&amp;amp;压缩&amp;amp;AOP&lt;/li&gt;
&lt;li&gt;6.JNI&amp;amp;音视频&amp;amp;FFmpeg&amp;amp;播放器&lt;/li&gt;
&lt;li&gt;7.AndroidStudio&amp;amp;Lint&amp;amp;gradle&amp;amp;maven&amp;amp;CI&amp;amp;CD&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>对 Android 开发的一点思考</title>
    <link href="http://yhaowa.gitee.io/f713728e/"/>
    <id>http://yhaowa.gitee.io/f713728e/</id>
    <published>2019-04-07T09:17:09.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>17 年毕业开始工作到现在已快两个年头，在实际项目开发的过程中，我对 Android 开发有了一些自己的思考。本着碰撞才会有火花、讨论才会进步的理念，我把对 Android 开发的一点思考分享出来，真诚的希望可以有不同的观点，在纠结反驳之中得到最优解，共同进步。</p><a id="more"></a><p>最初的时候，你是否是一个完美主义者，不容忍任何一点 warning 与叹号，if 必有 else，switch 必有 default，即使 else 和 default 中确实什么也不用处理，你也会添加一个 //do nothing 注释，表示这里的逻辑是经过充分考虑的，下次阅读程序时，告诉别人也告诉自己，这里的确什么也不用处理，可以快速跳过。</p><p>我想大多数开发者，都是经历过这种心态的，然后在繁忙的版本迭代中、在赶着回家的加班时、在愈来愈发的对自己的薪水不满时、在一次又一次看到团队中别人得过且过的代码时，渐渐的，就可能对“生活”妥协，丢掉了完美主义。</p><p>然而如果你有更高的追求，就要勇敢的战胜自己的感性。</p><h3 id="使用-IntDef、StringDef"><a href="#使用-IntDef、StringDef" class="headerlink" title="使用 IntDef、StringDef"></a>使用 IntDef、StringDef</h3><p>平时特常用的 View.setVisibility() 方法使用 IntDef 来规定参数的可选项，可以试想一下，假如没用 IntDef 会怎么样？对于初学者来说，可能要稍微阅读一下源码或查下资料才能知道 setVisibility 有哪些参数可以设置。你可能会觉得没什么差，因为你很清楚 setVisibility 方法有哪些参数可以设置。但若是程序中新增的一个方法呢？比如你新接触一个模块，某个界面有若干个跳转 Action，你得先找到定义这些 Action 的地方，而若一不小心将这些 Action 分散写在不同的地方，那对后面的维护和拓展可能就是一个灾难。</p><p>建议凡是符合语义的逻辑，都必须用 IntDef、StringDef 来约束，它比枚举节省内存，性能更优，其 RetentionPolicy.SOURCE 表示此注解只在源码中存在，编译时会剔除。你可以在 Android Studio 的 Live Templates 中添加 IntDef、StringDef 写法：<br><img src="../img/14.jpg" alt></p><h3 id="使用精准表达的变量类型"><a href="#使用精准表达的变量类型" class="headerlink" title="使用精准表达的变量类型"></a>使用精准表达的变量类型</h3><p>比如你需要声明一个变量来表示某个功能是否启用，譬如控制你的 App 是否展示广告，并且可以通过服务端在线下发开关来控制，如果没有接收到下发的开关，就根据地区来决定是否展示。</p><p>这种情况下你会使用什么类型的变量？</p><p>你可能会想到使用一个 int 类型变量来控制，然后需要给这个变量加上注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0：展示； 1：不展示； 2：未接收到在线开关，需要根据地区决定是否展示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mShouldShowAd;</span><br></pre></td></tr></table></figure><p>以后每当改动到这部分逻辑，都需要查看一下这个变量数值对应的含义，随着时间的推移和代码量的增多，在此逻辑之上可能堆积了很多代码，然后就会出现各种各样的问题，别人可能在不存在的逻辑分支做了一些事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mShouldShowAd == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mShouldShowAd == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mShouldShowAd == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可能对这个变量赋值 [0,2] 区间之外的数值！ 你可能对这个变量的意义很了解也绝不会用错，但你不能保证他人不会出现上面所说的荒唐的用法，因为这个变量类型并不能很精准的表达它的语义，也没有任何约束性。</p><p>我们可以怎样改善这种难维护、有风险的代码？</p><ul><li>可以使用 IntDef 规定这个变量的取值</li><li>可以换成 Boolean 类型，用 null 表示未获取到在线开关，恰好的表达语义并且易读、易维护</li></ul><h3 id="使用尽可能少的变量"><a href="#使用尽可能少的变量" class="headerlink" title="使用尽可能少的变量"></a>使用尽可能少的变量</h3><p>举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mDebug = BuildConfig.DEBUG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mDebug) &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你是否写过这样的逻辑？明明已经存在了一个可以直接使用的变量条件，你仍然要重新定义。这个例子逻辑还十分简单，此变量是 final 类型的，不会出错。而如果是非 final 类型的变量，那就是强行增加了一个赋值联动的逻辑，埋下了隐患，后续如果出了问题，白白的增加了定位问题的路径与复杂度。</p><p>实际开发中我们可能自己都意识不到使用了不必要的变量，比如我们的服务端接口一般会有多个接口环境，那你的代码可能是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否是测试环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sIsApiHostTest;</span><br><span class="line"><span class="comment">//是否是beta环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sIsApiHostBeta;</span><br><span class="line"><span class="comment">//正式环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line"><span class="comment">//测试环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line"><span class="comment">//beta环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sIsApiHostTest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sIsApiHostBeta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isApiTest()) &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHostTest;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isApiBeta()) &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHostBeta;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样看起来好像没什么问题，只要维护好 sIsApiHostTest、sIsApiHostBeta 这两个变量就行了。如果后面又添加了一个环境呢？又添加了三四个环境呢？是不是还要维护多个变量？这个逻辑可以通过减少变量来改善：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sCurApiHost;</span><br><span class="line"><span class="comment">//正式环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line"><span class="comment">//测试环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line"><span class="comment">//beta环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sApiHostTest.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sApiHostBeta.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sCurApiHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再加上 StringDef 就完美了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StringDef</span>(&#123;ApiHost.sApiHost, ApiHost.sApiHostTest, ApiHost.sApiHostBeta&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiHost &#123;</span><br><span class="line">    <span class="comment">//正式环境host</span></span><br><span class="line">    String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line">    <span class="comment">//测试环境host</span></span><br><span class="line">    String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line">    <span class="comment">//beta环境host</span></span><br><span class="line">    String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前环境host</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sCurApiHost = ApiHost.sApiHost;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiHost.sApiHostTest.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiHost.sApiHostBeta.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sCurApiHost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setApiHost</span><span class="params">(@ApiHost String apiHost)</span> </span>&#123;</span><br><span class="line">    sCurApiHost = apiHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道你有没有感受到易读性、可维护性、拓展性都蹭蹭蹭的往上涨呢？</p><h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h3><p>同时接受多个数据源数据的逻辑相比只接受一个数据源的数据需要考虑时序性等问题，要复杂很多。打个比方，可以把数据源当作你的直接上级，上级会不定时的分配任务给你做，如果你有多个上级，一个让你做任务 A，一个让你做任务 B，且 A 需要在 B 之前完成，你要怎么办？两个上级都让你做任务 A，但是只用做一次，你要怎么办？</p><p>在安卓中较为典型的场景就是同时加载网络和本地缓存数据到 UI 上，你的 UI 上展示的数据来自不同的地方，你需要考虑不同数据源之间如何协作。谷歌推出的 Jetpack 开发指南上推荐我们使用单一数据源，假如你的网络数据也需要缓存的话，那你的实现逻辑应该是这样：</p><ul><li>加载网络数据，返回后插入到本地<ul><li>统一从本地取数据展示到 UI 上</li></ul></li></ul><p>这点和上面说的“使用尽可能少的变量”有相通之处，都是尽量规避使用多个条件变量对程序产生影响的逻辑。</p><h3 id="职责分离"><a href="#职责分离" class="headerlink" title="职责分离"></a>职责分离</h3><p>强烈建议什么类里就干什么事，别把逻辑都揉到一块儿，这样随着代码量的增加，会愈发的难以维护，到最后就变成一颗存在重大隐患的地雷，看见就头疼。</p><p>举个例子，比如你要自定义一个 View，那就像系统控件一样，只负责一个控件该负责的事，处理一下渲染、展示，把手势交互通过接口开放出来，把数据的获取写在数据仓库中。这样如果数据展示出了问题，可以很快的定位到是数据获取出了问题，还是渲染展示出了问题；如果这个控件的渲染展示是经过验证的，之后就几乎不用改动此控件，至少你有机会可以将你的自定义 View 写的像系统的控件一样稳定。</p><p>这里再推荐一下谷歌的 Jetpack - MVVM 全家桶，MVC 真的是不易读、难维护、问题多、很简陋。</p><h3 id="回归最初的完美主义"><a href="#回归最初的完美主义" class="headerlink" title="回归最初的完美主义"></a>回归最初的完美主义</h3><p>希望你我可以战胜感性，不向“生活”妥协，让优秀成为准则和习惯，回归最初的完美主义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17 年毕业开始工作到现在已快两个年头，在实际项目开发的过程中，我对 Android 开发有了一些自己的思考。本着碰撞才会有火花、讨论才会进步的理念，我把对 Android 开发的一点思考分享出来，真诚的希望可以有不同的观点，在纠结反驳之中得到最优解，共同进步。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="开发模式" scheme="http://yhaowa.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>一个轻量的 Android 端日志打印记录库</title>
    <link href="http://yhaowa.gitee.io/f346f34f/"/>
    <id>http://yhaowa.gitee.io/f346f34f/</id>
    <published>2019-03-31T06:22:56.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p> 地址：<a href="https://github.com/yhaolpz/PLog" target="_blank" rel="noopener">https://github.com/yhaolpz/PLog</a></p><p><img src="../img/2.jpg" alt></p><p>PLog 即 Persistence Log，可持久化日志于文件，便于还原用户使用场景，解决异常问题。</p><h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><p>1.mmap 方式高效写入，规避 IO 操作带来的性能消耗</p><p>2.兼容多进程并发文件写入，日志文件保存在各自的进程目录下</p><p>3.通过 zip 压缩并加密，节省上报流量，保护日志私密性</p><p>4.内置收集 Activity/Fragment 生命周期、崩溃、网络状态等常用信息：</p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h5 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PLog.Config config = <span class="keyword">new</span> PLog.Config.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .logDir(mLogDirPath) <span class="comment">//日志存放目录，默认优先存储于SD卡</span></span><br><span class="line">        .logcatDebugLevel(PLog.DebugLevel.DEBUG) <span class="comment">//允许输出到Logcat的级别</span></span><br><span class="line">        .recordDebugLevel(PLog.DebugLevel.DEBUG) <span class="comment">//允许记录到日志文件的级别</span></span><br><span class="line">        .fileSizeLimitDay(<span class="number">15</span>) <span class="comment">//单天日志文件存储上限</span></span><br><span class="line">        .overdueDay(<span class="number">3</span>) <span class="comment">//日志文件过期天数</span></span><br><span class="line">        .cipherKey(<span class="string">"123456"</span>) <span class="comment">//日志密钥</span></span><br><span class="line">        .build();</span><br><span class="line">PLog.init(config);</span><br></pre></td></tr></table></figure><h5 id="2-打印"><a href="#2-打印" class="headerlink" title="2.打印"></a>2.打印</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通打印</span></span><br><span class="line">PLog.d(<span class="string">"wyh"</span>, <span class="string">"This is a log that can be recorded in a file"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Format</span></span><br><span class="line">PLog.d(<span class="string">"wyh"</span>, <span class="string">"This is a %s"</span>, <span class="string">"log"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组类型</span></span><br><span class="line">PLog.d(<span class="string">"wyh"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</span><br><span class="line"><span class="comment">//output: [a,b,c]</span></span><br></pre></td></tr></table></figure><h5 id="3-只记录到日志文件"><a href="#3-只记录到日志文件" class="headerlink" title="3.只记录到日志文件"></a>3.只记录到日志文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PLog.record(PLog.DebugLevel.DEBUG,<span class="string">"wyh"</span>,<span class="string">"This is a log that can only be recorded in files"</span>);</span><br></pre></td></tr></table></figure><h5 id="4-只输出到logcat"><a href="#4-只输出到logcat" class="headerlink" title="4.只输出到logcat"></a>4.只输出到logcat</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PLog.print(PLog.DebugLevel.DEBUG,<span class="string">"wyh"</span>,<span class="string">"This is a log"</span>);</span><br></pre></td></tr></table></figure><h5 id="5-触发上传"><a href="#5-触发上传" class="headerlink" title="5.触发上传"></a>5.触发上传</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PLog.upload(<span class="keyword">new</span> UploadListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">(@NonNull List&lt;File&gt; files)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上传到你的服务端</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//建议上传成功及时删除日志文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">             <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                file.delete();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="存储逻辑"><a href="#存储逻辑" class="headerlink" title="存储逻辑"></a>存储逻辑</h2><h4 id="日志文件类型"><a href="#日志文件类型" class="headerlink" title="日志文件类型"></a>日志文件类型</h4><p>为更好的区分并管理日志，将从写入到上传经历不同状态的日志文件划分为以下类型：</p><ul><li>“-mmap” 正在写入的日志文件，不可上传，文件命名为: yyyy-MM-dd-mmap</li><li>“-mmap-up” 写入完成的日志文件，可压缩上传，文件命名为: yyyy-MM-dd-mmap-up</li><li>“-mmap-up-old” 单天较早写入完成的日志大小，可压缩上传，文件命名为: yyyy-MM-dd-mmap-up-old</li><li>“-mmap-up-last” 触发上传时超出存储上限部分的日志文件，上传操作的中间态，不会长久存在，可压缩上传，文件命名为: yyyy-MM-dd-mmap-up-last</li><li>“.zip” 已压缩加密的日志文件，可直接上传，文件命名为: yyyy-MM-dd HH:mm:ss.zip</li></ul><h4 id="控制日志时效"><a href="#控制日志时效" class="headerlink" title="控制日志时效"></a>控制日志时效</h4><p>暂定保留最近三天的日志，更早的日志将会在特定时机自动清除当前进程目录所有类型过期的日志文件，这些时机包括：</p><ul><li>初始化时</li><li>触发上传重命名日志文件添加”-up”时</li><li>触发上传压缩所有标记为”-up”的可上传的日志时</li><li>触发上传扫描所有”.zip”可上传的日志时</li></ul><h4 id="控制存储上限"><a href="#控制存储上限" class="headerlink" title="控制存储上限"></a>控制存储上限</h4><p>理论上我们应该避免无意义的日志记录滥用，控制日志体积，但为避免极端情况下大量日志写入导致存储爆炸，通过将日志文件分为两片控制存储上限。</p><p>譬如规定单天日志存储体积上限为 MAX，逻辑大致为下：</p><ul><li>当天日志文件 -mmap 写入体积达 MAX/3 时就会停止写入，并命名为 -mmap-up，然后新建文件 -mmap 继续写入</li><li>当写入达 MAX/3 时，先将已存在的 -mmap-up 命名为 -mmap-up-old，再将刚写满的 -mmap 命名为 -mmap-up，然后新建文件 -mmap 继续写入</li><li>当写入达 MAX/3 时，先删除 -mmap-up-old 文件，将已存在的 -mmap-up 命名为 -mmap-up-old，再将刚写满的 -mmap 命名为 -mmap-up，然后新建文件 -mmap 继续写入</li></ul><p>按照此逻辑，假定当天写入日志体积为 SIZE，可以将单天日志存储情况划分为以下几种状态：</p><ul><li>a. SIZE &lt; MAX/3</li><li>b. MAX/3 &lt; SIZE &lt; MAX*2/3</li><li>c. MAX*2/3 &lt; SIZE &lt; MAX</li></ul><p>当处于 a 状态时触发上传： -mmap –&gt; -mmap-up –&gt; zip<br>当处于 b 状态时触发上传： -mmap-up –&gt; -mmap-up-old –&gt; zip ;  -mmap –&gt; -mmap-up –&gt; zip<br>当处于 c 状态时触发上传： -mmap-up-old –&gt; zip ;  -mmap-up –&gt; zip ;  -mmap –&gt; -mmap-up-last –&gt; zip</p><p>为了防止频繁的判断日志体积，可设置每隔一定写入条数后判断一次进行优化，目前设置间隔为 1000 条。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 地址：&lt;a href=&quot;https://github.com/yhaolpz/PLog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yhaolpz/PLog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/2.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;PLog 即 Persistence Log，可持久化日志于文件，便于还原用户使用场景，解决异常问题。&lt;/p&gt;
&lt;h2 id=&quot;特性：&quot;&gt;&lt;a href=&quot;#特性：&quot; class=&quot;headerlink&quot; title=&quot;特性：&quot;&gt;&lt;/a&gt;特性：&lt;/h2&gt;&lt;p&gt;1.mmap 方式高效写入，规避 IO 操作带来的性能消耗&lt;/p&gt;
&lt;p&gt;2.兼容多进程并发文件写入，日志文件保存在各自的进程目录下&lt;/p&gt;
&lt;p&gt;3.通过 zip 压缩并加密，节省上报流量，保护日志私密性&lt;/p&gt;
&lt;p&gt;4.内置收集 Activity/Fragment 生命周期、崩溃、网络状态等常用信息：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="日志" scheme="http://yhaowa.gitee.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>单例的线程安全及序列化问题</title>
    <link href="http://yhaowa.gitee.io/1516a551/"/>
    <id>http://yhaowa.gitee.io/1516a551/</id>
    <published>2019-03-05T15:04:44.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式可以说是最简单的设计模式了，但在使用时也有一些问题需要注意，比如线程安全性和序列化破坏。本文以几个问题为出发点，分析延迟加载、线程安全以及序列化三个方面，深入了解一下单例模式的各种姿势，以便在今后使用时追求极致性能  ⊙﹏⊙‖∣°</p><a id="more"></a><ul><li>饿汉方式单例到底有多“饿”？</li><li>静态内部类为什么是延迟加载的？</li><li>枚举方式单例是延迟加载的吗？</li><li>饿汉、静态内部类、枚举方式单例为什么是线程安全的？</li><li>序列化为什么会破坏单例模式？</li><li>怎么防止序列化破坏单例模式？</li><li>枚举方式单例是怎么避免序列化破坏的？</li></ul><p>开始正文前先思考下以上问题，如果你都掌握了，就可以点叉出去了。</p><h1 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h1><h4 id="饿汉方式"><a href="#饿汉方式" class="headerlink" title="饿汉方式"></a>饿汉方式</h4><p>先来看一下饿汉方式实现的单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与饿汉方式一并提起的往往还有懒汉方式，对比而言，懒汉方式具有延迟加载（这里的加载指创建 Singleton 实例）的优点。这容易让人对饿汉方式有一个恶劣的刻板印象：它的性能很不好！没有使用它的时候它就会初始化，白白占用资源！</p><p>现在我们来思考一下，饿汉方式单例到底有多“饿”？它到底什么时候会初始化呢？我们知道类加载的时候会初始化静态资源，所以饿汉方式的初始化时机就是类加载时机，回顾一下类加载的时机：</p><ul><li>使用new关键字实例化对象</li><li>调用一个类的静态方法</li><li>读取一个类的静态字段（被 final 修饰已在编译期把结果放在常量池的静态字段除外）</li></ul><p>当使用单例时，往往都是先调用 getInstance() 获取单例，几乎不会涉及其他的静态方法或字段，所以大多数情况下，饿汉方式同懒汉方式一样是延迟加载的！如果你的单例只暴露了 getInstance() 方法（个人感觉也是比较规范的写法），那就放心的使用饿汉方式吧！如果别人 diss 了你的饿汉方式，那就 diss 回去让他去复习类加载机制 &gt;_&lt;||| </p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类方式单例实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比饿汉方式，这种方式实现的单例即使加载了 Singleton 类，也不一定会创建 Singleton 实例，因为 Singleton 的静态引用放到了静态内部类中，只有静态内部类被加载了，Singleton 实例才会被创建。</p><p>如果 Singleton 中对外只暴露了 getInstance 方法，那和饿汉方式无异；如果还暴露了其他的静态方法或字段，那相比饿汉方式，可以更精准的实现延迟加载。</p><h4 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h4><p>枚举方式实现的单例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式或许我们无从下手，但反编译后就明白了，相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，枚举方式实现的单例和饿汉方式差不多，延迟加载时机依赖类加载时机。</p><p>这里需要搞清楚被 static、final 修饰的编译期常量、运行期常量。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>这部分内容其实十分简单。</p><p>类加载的逻辑位于 synchronized 代码块中，是线程安全的，而饿汉、静态内部类以及枚举方式实现的单例初始化都处于类加载时机，所以它们都是线程安全的。</p><p>懒汉方式的初始化与类加载时机无关，所以要自行保证线程安全。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>我们期望单例模式可以实现只创建一个实例，通过特殊手段创建出其他的实例，就对单例模式造成了破坏，序列化就会破坏单例模式。</p><p>假如我们的单例实现了 serializable 接口，序列化时会通过反射调用无参数的构造方法创建一个新的实例，这时就要重写 readResolve 方法防止序列化破坏单例，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止序列化破坏单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的 Java 类的反序列化过程中，会通过反射创建新的实例。而枚举在序列化的时候仅是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf 方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，禁用了writeObject、readObject、readObjectNoData、writeReplace 和 readResolve 等方法。</p><p>枚举的反序列化并不是通过反射实现的，所以也就不会发生由于反序列化导致的单例破坏问题。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>最后集中回答下开头的问题：</p><ul><li>饿汉方式单例到底有多“饿”？<br>大多数情况下，饿汉方式同懒汉方式一样时延迟加载的</li><li>静态内部类为什么是延迟加载的？<br>依赖类加载机制，加载静态内部类时才会初始化</li><li>枚举方式单例是延迟加载的吗？<br>与饿汉方式类似，类加载时初始化</li><li>饿汉、静态内部类、枚举方式单例为什么是线程安全的？<br>因为它们在类加载时初始化，而类加载是线程安全的</li><li>序列化为什么会破坏单例模式？<br>普通的 Java 类的反序列化过程中，会通过反射创建新的实例</li><li>怎么防止序列化破坏单例模式？<br>使用枚举或重写 readResolve 方法</li><li>枚举方式单例是怎么避免序列化破坏的？<br>依赖枚举自身特殊的序列化机制</li></ul><h6 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h6><p><a href="https://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">单例与序列化的那些事儿</a><br><a href="https://www.hollischuang.com/archives/2498" target="_blank" rel="noopener">为什么我墙裂建议大家使用枚举来实现单例</a><br><a href="https://www.hollischuang.com/archives/197" target="_blank" rel="noopener">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a><br><a href="https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized" target="_blank" rel="noopener">stackoverflow：singleton-via-enum-way-is-lazy-initialized</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式可以说是最简单的设计模式了，但在使用时也有一些问题需要注意，比如线程安全性和序列化破坏。本文以几个问题为出发点，分析延迟加载、线程安全以及序列化三个方面，深入了解一下单例模式的各种姿势，以便在今后使用时追求极致性能  ⊙﹏⊙‖∣°&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yhaowa.gitee.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yhaowa.gitee.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yhaowa.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[剑指offer] 机器人走格子之回溯法</title>
    <link href="http://yhaowa.gitee.io/e89c3ed9/"/>
    <id>http://yhaowa.gitee.io/e89c3ed9/</id>
    <published>2019-03-03T12:14:56.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><a id="more"></a><p><strong>核心思路：</strong></p><ol><li>从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 4 个方向的探索值之和。</li><li>探索时，判断当前节点是否可达的标准为：1）当前节点在矩阵内；2）当前节点未被访问过；3）当前节点满足limit限制。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">return</span> countingSteps(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countingSteps</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows || c &lt; <span class="number">0</span> || c &gt;= cols</span><br><span class="line">            || visited[r][c] || bitSum(r) + bitSum(c) &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> countingSteps(limit, rows, cols, r - <span class="number">1</span>, c, visited)</span><br><span class="line">            + countingSteps(limit, rows, cols, r, c - <span class="number">1</span>, visited)</span><br><span class="line">            + countingSteps(limit, rows, cols, r + <span class="number">1</span>, c, visited)</span><br><span class="line">            + countingSteps(limit, rows, cols, r, c + <span class="number">1</span>, visited)</span><br><span class="line">            + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitSum</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="number">0</span>) &#123;</span><br><span class="line">        count += t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;
    
    </summary>
    
      <category term="算法之美" scheme="http://yhaowa.gitee.io/categories/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="剑指offer" scheme="http://yhaowa.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>[剑指offer] 二维数组中的查找</title>
    <link href="http://yhaowa.gitee.io/ff815187/"/>
    <id>http://yhaowa.gitee.io/ff815187/</id>
    <published>2019-02-28T15:03:46.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = array[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] anArray : array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == anArray[<span class="number">0</span>] || target == anArray[len - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; anArray[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; anArray[len - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a : anArray) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
      <category term="算法之美" scheme="http://yhaowa.gitee.io/categories/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="剑指offer" scheme="http://yhaowa.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>简洁明了的刘海屏适配方案</title>
    <link href="http://yhaowa.gitee.io/2f41d4d1/"/>
    <id>http://yhaowa.gitee.io/2f41d4d1/</id>
    <published>2019-02-26T15:11:04.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于刘海屏适配的文章不少，可讲清楚的却没几篇，大多是拷贝文档、长篇大论，甚至热情的贴图告诉你什么是刘海屏，到最后你仍不确定到底是怎样的一个适配方案，才能让你的 app 真正的适配所有的刘海屏机型。</p><p>看到这篇文章你就无需再怨恨各大厂商的跟风“刘海”了，因为刘海屏的适配十分简单。</p><a id="more"></a><p>ok，废话说完了，开始适配。</p><p>首先要清楚的是哪些界面需要适配刘海屏：</p><ul><li>有状态栏的界面：刘海区域会显示状态栏，无需适配</li><li>全屏界面：刘海区域可能遮挡内容，需要适配</li></ul><p>如果你的应用里所有界面都有状态栏，那么恭喜你，你不用做任何操作，状态栏就那么自然的显示在刘海区域，毫无违和，刘海屏已适配完毕，可以点叉出去了。</p><p>不幸的是，你的应用中很大几率会有全屏界面，所谓的刘海屏适配，也正是针对这些全屏界面。</p><p>如果你什么都不做，默认规则不允许全屏界面内容显示到刘海区域，即刘海屏区域会保留一条黑边，你的全屏界面会在刘海下方展示，这看起来好像也是可以接受的，然后你竟说服产品达成共识，“无为而治”才是最强大的刘海屏适配方案！</p><p>但有些手机厂商（譬如oppo）不开心了，我辛辛苦苦研发的刘海屏手机，你们这些开发者竟直接放弃刘海区域！然后就在你的全屏界面下方加了一条提示：“全屏显示”，当用户点击开启后，强行把你的全屏界面显示到刘海区域，然后一切都乱套了…</p><p>嗯～ “无为而治”行不通。</p><p>只能允许全屏界面内容显示到刘海区域了，参考各大厂商的适配文档，我们可以知道如何允许，比如华为机型只需在 AndroidManifest 中配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;android.notch_support&quot;</span><br><span class="line">    android:value=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>配置后，华为机型上的全屏界面就会显示到刘海区域了，但这个刘海，是可能挡住我们全屏界面中的内容的。这时需要将全屏界面中的视图元素适当下移，保证不会被刘海遮挡住，就 ok 了。</p><p>这里我们搞清楚：允许全屏界面内容显示到刘海区域的机型，才需要将全屏界面中的视图元素适当下移。</p><p>比如若只允许华为机型全屏界面内容显示到刘海区域，那只有华为的刘海屏机型才需要将全屏界面中的视图元素适当下移，其他厂商的刘海屏机型则不需要下移。</p><p>如果允许华为、小米、oppo、vivo 全屏界面内容显示到刘海区域，那么华为、小米、oppo、vivo 刘海屏机型需要将全屏界面中的视图元素适当下移。</p><p>另外也不一定要通过全屏界面中的视图元素适当下移方式来适配刘海屏，如果产品形态允许的话，你也可以让该界面显示状态栏啊。</p><p>至此刘海屏适配完毕，是不是很简单！？</p><p>最后代码奉上，拿走不谢：</p><h4 id="允许全屏界面内容显示到刘海区域配置："><a href="#允许全屏界面内容显示到刘海区域配置：" class="headerlink" title="允许全屏界面内容显示到刘海区域配置："></a>允许全屏界面内容显示到刘海区域配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--允许绘制到oppo、vivo刘海屏机型的刘海区域 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;android.max_aspect&quot;</span><br><span class="line">    android:value=&quot;2.2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许绘制到华为刘海屏机型的刘海区域 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;android.notch_support&quot;</span><br><span class="line">    android:value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许绘制到小米刘海屏机型的刘海区域 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;notch.config&quot;</span><br><span class="line">    android:value=&quot;portrait&quot; /&gt;</span><br></pre></td></tr></table></figure><p>上面在 AndroidManifest 的配置在 Android 9.0 之前有效，9.0 系统针对刘海屏制定了新的 api，默认保留一条黑边，即不允许绘制到刘海区域。所以如果你还没有适配 Android 9.0，那在判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型时，就要加上版本判断。</p><h4 id="判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型："><a href="#判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型：" class="headerlink" title="判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型："></a>判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CutoutUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean sAllowDisplayToCutout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为允许全屏界面显示内容到刘海区域的刘海屏机型（与AndroidManifest中配置对应）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">allowDisplayToCutout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sAllowDisplayToCutout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.O_MR1) &#123;</span><br><span class="line">                <span class="comment">// 9.0系统全屏界面默认会保留黑边，不允许显示内容到刘海区域</span></span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutoutDevice = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Context context = App.get();</span><br><span class="line">            <span class="keyword">if</span> (hasCutout_Huawei(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasCutout_OPPO(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasCutout_VIVO(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasCutout_XIAOMI(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sAllowDisplayToCutout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是华为刘海屏机型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCutout_Huawei</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Build.MANUFACTURER.equalsIgnoreCase(<span class="string">"HUAWEI"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl = context.getClassLoader();</span><br><span class="line">            Class HwNotchSizeUtil = cl.loadClass(<span class="string">"com.huawei.android.util.HwNotchSizeUtil"</span>);</span><br><span class="line">            <span class="keyword">if</span> (HwNotchSizeUtil != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Method get = HwNotchSizeUtil.getMethod(<span class="string">"hasNotchInScreen"</span>);</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">boolean</span>) get.invoke(HwNotchSizeUtil);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是oppo刘海屏机型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCutout_OPPO</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Build.MANUFACTURER.equalsIgnoreCase(<span class="string">"oppo"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context.getPackageManager().hasSystemFeature(<span class="string">"com.oppo.feature.screen.heteromorphism"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是vivo刘海屏机型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCutout_VIVO</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Build.MANUFACTURER.equalsIgnoreCase(<span class="string">"vivo"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl = context.getClassLoader();</span><br><span class="line">            <span class="meta">@SuppressLint</span>(<span class="string">"PrivateApi"</span>)</span><br><span class="line">            Class ftFeatureUtil = cl.loadClass(<span class="string">"android.util.FtFeature"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ftFeatureUtil != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Method get = ftFeatureUtil.getMethod(<span class="string">"isFeatureSupport"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">boolean</span>) get.invoke(ftFeatureUtil, <span class="number">0x00000020</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是小米刘海屏机型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCutout_XIAOMI</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Build.MANUFACTURER.equalsIgnoreCase(<span class="string">"xiaomi"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl = context.getClassLoader();</span><br><span class="line">            <span class="meta">@SuppressLint</span>(<span class="string">"PrivateApi"</span>)</span><br><span class="line">            Class SystemProperties = cl.loadClass(<span class="string">"android.os.SystemProperties"</span>);</span><br><span class="line">            Class[] paramTypes = <span class="keyword">new</span> Class[<span class="number">2</span>];</span><br><span class="line">            paramTypes[<span class="number">0</span>] = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            paramTypes[<span class="number">1</span>] = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Method getInt = SystemProperties.getMethod(<span class="string">"getInt"</span>, paramTypes);</span><br><span class="line">            <span class="comment">//参数</span></span><br><span class="line">            Object[] params = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">            params[<span class="number">0</span>] = <span class="string">"ro.miui.notch"</span>;</span><br><span class="line">            params[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (Integer) getInt.invoke(SystemProperties, params) == <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到，不一定要通过全屏界面中的视图元素适当下移方式来适配刘海屏，如果产品形态允许的话，也可以让该界面显示状态栏。</p><p>显示状态栏的方案是较为通用简单的，或者说，在一个应用中，一些全屏界面往往是允许使用显示状态栏的方案来适配的，如果你考虑使用这种方案，那便会是这种效果：</p><ul><li>在你的应用中，你期望某些全屏界面在刘海屏机型上必须全屏展示，那你就自行将界面元素适当下移，从而避免被刘海遮挡；而某些全屏界面不是非要全屏显示，允许在刘海屏机型显示状态栏，那就通过显示状态栏的方式，从而避免被刘海遮挡。</li></ul><p>为了实现这种效果，我们需要标记区分哪些界面必须全屏展示、哪些界面允许显示状态栏。这里提供一种实现方式，让允许显示状态栏的界面 Activity 继承一个接口，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CutoutAdapt</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 ActivityLifecycleCallbacks 回调，统一适配允许通过显示状态栏的全屏界面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是允许全屏显示到刘海屏区域的刘海屏机型</span></span><br><span class="line">    <span class="keyword">if</span> (CutoutUtil.allowDisplayToCutout()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFullScreen(activity)) &#123;</span><br><span class="line">            <span class="comment">// 如果允许通过显示状态栏方式适配刘海屏</span></span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> CutoutAdapt) &#123;</span><br><span class="line">                <span class="comment">// 显示状态栏</span></span><br><span class="line">                StatusBarUtil.showStatusbar(activity.getWindow());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 需自行将该界面视图元素下移，否则可能会被刘海遮挡</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非全屏界面无需适配刘海屏</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上关于刘海屏适配的文章不少，可讲清楚的却没几篇，大多是拷贝文档、长篇大论，甚至热情的贴图告诉你什么是刘海屏，到最后你仍不确定到底是怎样的一个适配方案，才能让你的 app 真正的适配所有的刘海屏机型。&lt;/p&gt;
&lt;p&gt;看到这篇文章你就无需再怨恨各大厂商的跟风“刘海”了，因为刘海屏的适配十分简单。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="刘海屏适配" scheme="http://yhaowa.gitee.io/tags/%E5%88%98%E6%B5%B7%E5%B1%8F%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 展示 gif 原理</title>
    <link href="http://yhaowa.gitee.io/3fe9ef36/"/>
    <id>http://yhaowa.gitee.io/3fe9ef36/</id>
    <published>2019-02-17T10:03:14.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在展示 gif 时，即使不调用 asGif 方法，Glide 也能识别出 gif 类型并正常展示。解码逻辑位于 Downsampler 的 decode 方法中，我们先从这里开始，看看 Glide 是如何识别 gif 类型的。decode 方法中调用了 decodeFromWrappedStreams 方法开始实际解码逻辑：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">decodeFromWrappedStreams</span><span class="params">(InputStream is,</span></span></span><br><span class="line"><span class="function"><span class="params">    BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    DecodeFormat decodeFormat, <span class="keyword">boolean</span> isHardwareConfigAllowed, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> requestedHeight, <span class="keyword">boolean</span> fixBitmapToRequestedDimensions,</span></span></span><br><span class="line"><span class="function"><span class="params">    DecodeCallbacks callbacks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);</span><br><span class="line">  <span class="keyword">int</span> sourceWidth = sourceDimensions[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> sourceHeight = sourceDimensions[<span class="number">1</span>];</span><br><span class="line">  String sourceMimeType = options.outMimeType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap,</span></span><br><span class="line">  <span class="comment">// so we want to use a mutable Bitmap type. One way this can happen is if the image header is so</span></span><br><span class="line">  <span class="comment">// large (10mb+) that our attempt to use inJustDecodeBounds fails and we're forced to decode the</span></span><br><span class="line">  <span class="comment">// full size image.</span></span><br><span class="line">  <span class="keyword">if</span> (sourceWidth == -<span class="number">1</span> || sourceHeight == -<span class="number">1</span>) &#123;</span><br><span class="line">    isHardwareConfigAllowed = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);</span><br><span class="line">  <span class="keyword">int</span> degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);</span><br><span class="line">  <span class="keyword">boolean</span> isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;</span><br><span class="line">  <span class="keyword">int</span> targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;</span><br><span class="line"></span><br><span class="line">  ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略下面的解码逻辑代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到解码开始前，准备了图片角度、输出尺寸的信息，并通过 ImageHeaderParserUtils 获取了图片类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);</span><br></pre></td></tr></table></figure></p><p>Glide 中定义了以下图片类型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The format of the image data including whether or not the image may include transparent</span></span><br><span class="line"><span class="comment"> * pixels.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> ImageType &#123;</span><br><span class="line">  GIF(<span class="keyword">true</span>),</span><br><span class="line">  JPEG(<span class="keyword">false</span>),</span><br><span class="line">  RAW(<span class="keyword">false</span>),</span><br><span class="line">  <span class="comment">/** PNG type with alpha. */</span></span><br><span class="line">  PNG_A(<span class="keyword">true</span>),</span><br><span class="line">  <span class="comment">/** PNG type without alpha. */</span></span><br><span class="line">  PNG(<span class="keyword">false</span>),</span><br><span class="line">  <span class="comment">/** WebP type with alpha. */</span></span><br><span class="line">  WEBP_A(<span class="keyword">true</span>),</span><br><span class="line">  <span class="comment">/** WebP type without alpha. */</span></span><br><span class="line">  WEBP(<span class="keyword">false</span>),</span><br><span class="line">  <span class="comment">/** Unrecognized type. */</span></span><br><span class="line">  UNKNOWN(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> hasAlpha;</span><br><span class="line"></span><br><span class="line">  ImageType(<span class="keyword">boolean</span> hasAlpha) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasAlpha = hasAlpha;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlpha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasAlpha;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而实际获取图片类型的逻辑位于 DefaultImageHeaderParser 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ImageType <span class="title">getType</span><span class="params">(Reader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> firstTwoBytes = reader.getUInt16();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JPEG.</span></span><br><span class="line">  <span class="keyword">if</span> (firstTwoBytes == EXIF_MAGIC_NUMBER) &#123;</span><br><span class="line">    <span class="keyword">return</span> JPEG;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> firstFourBytes = (firstTwoBytes &lt;&lt; <span class="number">16</span> &amp; <span class="number">0xFFFF0000</span>) | (reader.getUInt16() &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">  <span class="comment">// PNG.</span></span><br><span class="line">  <span class="keyword">if</span> (firstFourBytes == PNG_HEADER) &#123;</span><br><span class="line">    <span class="comment">// See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha</span></span><br><span class="line">    <span class="comment">// -color-type</span></span><br><span class="line">    reader.skip(<span class="number">25</span> - <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> alpha = reader.getByte();</span><br><span class="line">    <span class="comment">// A RGB indexed PNG can also have transparency. Better safe than sorry!</span></span><br><span class="line">    <span class="keyword">return</span> alpha &gt;= <span class="number">3</span> ? PNG_A : PNG;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GIF from first 3 bytes.</span></span><br><span class="line">  <span class="keyword">if</span> (firstFourBytes &gt;&gt; <span class="number">8</span> == GIF_HEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span> GIF;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// WebP (reads up to 21 bytes). See https://developers.google.com/speed/webp/docs/riff_container</span></span><br><span class="line">  <span class="comment">// for details.</span></span><br><span class="line">  <span class="keyword">if</span> (firstFourBytes != RIFF_HEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Bytes 4 - 7 contain length information. Skip these.</span></span><br><span class="line">  reader.skip(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> thirdFourBytes =</span><br><span class="line">      (reader.getUInt16() &lt;&lt; <span class="number">16</span> &amp; <span class="number">0xFFFF0000</span>) | (reader.getUInt16() &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">  <span class="keyword">if</span> (thirdFourBytes != WEBP_HEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> fourthFourBytes =</span><br><span class="line">      (reader.getUInt16() &lt;&lt; <span class="number">16</span> &amp; <span class="number">0xFFFF0000</span>) | (reader.getUInt16() &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">  <span class="keyword">if</span> ((fourthFourBytes &amp; VP8_HEADER_MASK) != VP8_HEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((fourthFourBytes &amp; VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_EXTENDED) &#123;</span><br><span class="line">    <span class="comment">// Skip some more length bytes and check for transparency/alpha flag.</span></span><br><span class="line">    reader.skip(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> (reader.getByte() &amp; WEBP_EXTENDED_ALPHA_FLAG) != <span class="number">0</span> ? ImageType.WEBP_A : ImageType.WEBP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((fourthFourBytes &amp; VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_LOSSLESS) &#123;</span><br><span class="line">    <span class="comment">// See chromium.googlesource.com/webm/libwebp/+/master/doc/webp-lossless-bitstream-spec.txt</span></span><br><span class="line">    <span class="comment">// for more info.</span></span><br><span class="line">    reader.skip(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> (reader.getByte() &amp; WEBP_LOSSLESS_ALPHA_FLAG) != <span class="number">0</span> ? ImageType.WEBP_A : ImageType.WEBP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ImageType.WEBP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里是通过文件头标示来获取图片类型的，而 gif 文件头如下：<br><img src="https://upload-images.jianshu.io/upload_images/4679478-588f3a9d994f274a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>查看代码，Glide 中便是通过 0x474946 文件头来判断的。</p><p>Glide 中将 gif 类型图片封装成了 GifDrawable，在 ByteBufferGifDecoder 中可以看到 GifDrawable 的生成逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> GifDrawableResource <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ByteBuffer byteBuffer, <span class="keyword">int</span> width, <span class="keyword">int</span> height, GifHeaderParser parser, Options options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> GifHeader header = parser.parseHeader();</span><br><span class="line">    <span class="keyword">if</span> (header.getNumFrames() &lt;= <span class="number">0</span> || header.getStatus() != GifDecoder.STATUS_OK) &#123;</span><br><span class="line">      <span class="comment">// If we couldn't decode the GIF, we will end up with a frame count of 0.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bitmap.Config config = options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565</span><br><span class="line">        ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sampleSize = getSampleSize(header, width, height);</span><br><span class="line">    GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);</span><br><span class="line">    gifDecoder.setDefaultBitmapConfig(config);</span><br><span class="line">    gifDecoder.advance();</span><br><span class="line">    Bitmap firstFrame = gifDecoder.getNextFrame();</span><br><span class="line">    <span class="keyword">if</span> (firstFrame == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Transformation&lt;Bitmap&gt; unitTransformation = UnitTransformation.get();</span><br><span class="line"></span><br><span class="line">    GifDrawable gifDrawable =</span><br><span class="line">        <span class="keyword">new</span> GifDrawable(context, gifDecoder, unitTransformation, width, height, firstFrame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GifDrawableResource(gifDrawable);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Decoded GIF from stream in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此已经获取到 GifDrawable ，GifDrawable 中持有一个 GifFrameLoader，而 GifFrameLoader 中持有了 gif 解码器 StandardGifDecoder 。由此可以得出 gif 的展示逻辑就封装于 GifDrawable 中，主要通过 GifFrameLoader 实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在展示 gif 时，即使不调用 asGif 方法，Glide 也能识别出 gif 类型并正常展示。解码逻辑位于 Downsampler 的 decode 方法中，我们先从这里开始，看看 Glide 是如何识别 gif 类型的。decode 方法中调用了 decodeFromWrappedStreams 方法开始实际解码逻辑：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 缩略图使用及原理</title>
    <link href="http://yhaowa.gitee.io/2455213e/"/>
    <id>http://yhaowa.gitee.io/2455213e/</id>
    <published>2019-02-17T08:25:28.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>缩略图的使用可参考<a href="https://muyangmin.github.io/glide-docs-cn/doc/options.html#缩略图-thumbnail-请求" target="_blank" rel="noopener">官方文档</a>。</p><p>若使用简化方式设置缩略图：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(imgUrl).thumbnail(<span class="number">0.2f</span>).into(imageView);</span><br></pre></td></tr></table></figure><p>发起缩略图请求的关键逻辑位于 RequestBuilder 的 buildThumbnailRequestRecursive 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.</span></span><br><span class="line">  ThumbnailRequestCoordinator coordinator = <span class="keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);</span><br><span class="line"></span><br><span class="line">  Request fullRequest =</span><br><span class="line">      obtainRequest(</span><br><span class="line">          target,</span><br><span class="line">          targetListener,</span><br><span class="line">          requestOptions,</span><br><span class="line">          coordinator,</span><br><span class="line">          transitionOptions,</span><br><span class="line">          priority,</span><br><span class="line">          overrideWidth,</span><br><span class="line">          overrideHeight);</span><br><span class="line"></span><br><span class="line">  RequestOptions thumbnailOptions = requestOptions.clone()</span><br><span class="line">      .sizeMultiplier(thumbSizeMultiplier);</span><br><span class="line">  Request thumbnailRequest =</span><br><span class="line">      obtainRequest(</span><br><span class="line">          target,</span><br><span class="line">          targetListener,</span><br><span class="line">          thumbnailOptions,</span><br><span class="line">          coordinator,</span><br><span class="line">          transitionOptions,</span><br><span class="line">          getThumbnailPriority(priority),</span><br><span class="line">          overrideWidth,</span><br><span class="line">          overrideHeight);</span><br><span class="line"></span><br><span class="line">  coordinator.setRequests(fullRequest, thumbnailRequest);</span><br><span class="line">  <span class="keyword">return</span> coordinator;</span><br></pre></td></tr></table></figure></p><p>其中 fullRequest、thumbnailRequest 分别为原图、缩略图请求，ThumbnailRequestCoordinator 就是字面意思，专门用于协调原图、缩略图的请求，并合并成一个请求，可以看到在构建缩略图请求时，为了尽量让缩略图比原图加载的更快一点，调用 getThumbnailPriority 方法调整了请求优先级：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Priority <span class="title">getThumbnailPriority</span><span class="params">(@NonNull Priority current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOW:</span><br><span class="line">      <span class="keyword">return</span> Priority.NORMAL;</span><br><span class="line">    <span class="keyword">case</span> NORMAL:</span><br><span class="line">      <span class="keyword">return</span> Priority.HIGH;</span><br><span class="line">    <span class="keyword">case</span> HIGH:</span><br><span class="line">    <span class="keyword">case</span> IMMEDIATE:</span><br><span class="line">      <span class="keyword">return</span> Priority.IMMEDIATE;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unknown priority: "</span> + requestOptions.getPriority());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加载完数据后，Glide 会分别解码缩略图、原图两种尺寸的图片，具体解码实现位于 Downsampler 的 decode 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(InputStream is, <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options, DecodeCallbacks callbacks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Preconditions.checkArgument(is.markSupported(), <span class="string">"You must provide an InputStream that supports"</span></span><br><span class="line">      + <span class="string">" mark()"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();</span><br><span class="line">  bitmapFactoryOptions.inTempStorage = bytesForOptions;</span><br><span class="line"></span><br><span class="line">  DecodeFormat decodeFormat = options.get(DECODE_FORMAT);</span><br><span class="line">  DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);</span><br><span class="line">  <span class="keyword">boolean</span> fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);</span><br><span class="line">  <span class="keyword">boolean</span> isHardwareConfigAllowed =</span><br><span class="line">    options.get(ALLOW_HARDWARE_CONFIG) != <span class="keyword">null</span> &amp;&amp; options.get(ALLOW_HARDWARE_CONFIG);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,</span><br><span class="line">        downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,</span><br><span class="line">        requestedHeight, fixBitmapToRequestedDimensions, callbacks);</span><br><span class="line">    <span class="keyword">return</span> BitmapResource.obtain(result, bitmapPool);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    releaseOptions(bitmapFactoryOptions);</span><br><span class="line">    byteArrayPool.put(bytesForOptions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解码完后会调用到 DecodeJob 的 notifyComplete 方法，进一步调用到 EngineJob 的 onResourceReady 方法，在 onResourceReady 方法中通过 handle 转到主线程，然后调用到 EngineJob 的 handleResultOnMainThread 方法，接着调用 SingleRequest 的 onResourceReady 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// We must call isFirstReadyResource before setting status.</span></span><br><span class="line">   <span class="keyword">boolean</span> isFirstResource = isFirstReadyResource();</span><br><span class="line">   status = Status.COMPLETE;</span><br><span class="line">   <span class="keyword">this</span>.resource = resource;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (glideContext.getLogLevel() &lt;= Log.DEBUG) &#123;</span><br><span class="line">     Log.d(GLIDE_TAG, <span class="string">"Finished loading "</span> + result.getClass().getSimpleName() + <span class="string">" from "</span></span><br><span class="line">         + dataSource + <span class="string">" for "</span> + model + <span class="string">" with size ["</span> + width + <span class="string">"x"</span> + height + <span class="string">"] in "</span></span><br><span class="line">         + LogTime.getElapsedMillis(startTime) + <span class="string">" ms"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   isCallingCallbacks = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">boolean</span> anyListenerHandledUpdatingTarget = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (requestListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (RequestListener&lt;R&gt; listener : requestListeners) &#123;</span><br><span class="line">         anyListenerHandledUpdatingTarget |=</span><br><span class="line">             listener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     anyListenerHandledUpdatingTarget |=</span><br><span class="line">         targetListener != <span class="keyword">null</span></span><br><span class="line">             &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;</span><br><span class="line">       Transition&lt;? <span class="keyword">super</span> R&gt; animation =</span><br><span class="line">           animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">       target.onResourceRReady(result, animation);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     isCallingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   notifyLoadSuccess();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到此方法中终于将加载资源回调给 Target 了，调用栈大致如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/4679478-08af148de8e8a2c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以上不止是设置缩略图时的加载流程，没有缩略图时走的也是这个流程。我们知道图片缩略图不过是通过 BitmapFactory.Options  解码一张尺寸较小、质量较差的图罢了，而 Glide 除了支持配置图片缩略图，还支持配置本地视频缩略图。取视频缩略图的关键逻辑位于 VideoDecoder 的 decodeFrame 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">decodeFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     MediaMetadataRetriever mediaMetadataRetriever,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">long</span> frameTimeMicros,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> frameOption,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> outWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> outHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">     DownsampleStrategy strategy)</span> </span>&#123;</span><br><span class="line">   Bitmap result = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// Arguably we should handle the case where just width or just height is set to</span></span><br><span class="line">   <span class="comment">// Target.SIZE_ORIGINAL. Up to and including OMR1, MediaMetadataRetriever defaults to setting</span></span><br><span class="line">   <span class="comment">// the dimensions to the display width and height if they aren't specified (ie</span></span><br><span class="line">   <span class="comment">// getScaledFrameAtTime is not used). Given that this is an optimization only if</span></span><br><span class="line">   <span class="comment">// Target.SIZE_ORIGINAL is not used and not using getScaledFrameAtTime ever would match the</span></span><br><span class="line">   <span class="comment">// behavior of Glide in all versions of Android prior to OMR1, it's probably fine for now.</span></span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= VERSION_CODES.O_MR1</span><br><span class="line">       &amp;&amp; outWidth != Target.SIZE_ORIGINAL</span><br><span class="line">       &amp;&amp; outHeight != Target.SIZE_ORIGINAL</span><br><span class="line">       &amp;&amp; strategy != DownsampleStrategy.NONE) &#123;</span><br><span class="line">     result =</span><br><span class="line">         decodeScaledFrame(</span><br><span class="line">             mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight, strategy);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">     result = decodeOriginalFrame(mediaMetadataRetriever, frameTimeMicros, frameOption);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在 Android 8.1 系统上支持直接获取缩放的视频缩略图，8.1 以下则直接获取帧原图，分别通过 MediaMetadataRetriever 的 getScaledFrameAtTime 、getFrameAtTime 获取。MediaMetadataRetriever 是 Android 提供的类，用来获取本地和网络 Media 文件信息，提供了用于从输入媒体文件检索帧和元数据的统一接口。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缩略图的使用可参考&lt;a href=&quot;https://muyangmin.github.io/glide-docs-cn/doc/options.html#缩略图-thumbnail-请求&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;若使用简化方式设置缩略图：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 请求优先级及原理</title>
    <link href="http://yhaowa.gitee.io/aeb1195c/"/>
    <id>http://yhaowa.gitee.io/aeb1195c/</id>
    <published>2019-02-17T08:24:53.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>若一个界面中需要展示多张图片，我们可能会期望某张图片优先加载，这就需要设置 Glide 的请求优先级， Glide 中提供四种优先级：</p><a id="more"></a><ul><li>Priority.LOW</li><li>Priority.NORMAL</li><li>Priority.HIGH</li><li>Priority.IMMEDIATE</li></ul><p>使用十分简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = <span class="keyword">new</span> RequestOptions().priority(Priority.HIGH);</span><br><span class="line">Glide.with(context).load(imgUrl).apply(options).into(imageView);</span><br></pre></td></tr></table></figure></p><p>下面来分析一下我们配置的 Priority.HIGH 到底是如何生效的，跟踪发现优先级参数 priority 会被传入到 RequestBuilder 的 buildThumbnailRequestRecursive 方法，其中主要逻辑如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildThumbnailRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">     RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">     @Nullable RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">     TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">     Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">     RequestOptions requestOptions)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (thumbnailBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 缩略图相关，先忽略</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (thumbSizeMultiplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 缩略图相关，先忽略</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Base case: no thumbnail.</span></span><br><span class="line">     <span class="keyword">return</span> obtainRequest(</span><br><span class="line">         target,</span><br><span class="line">         targetListener,</span><br><span class="line">         requestOptions,</span><br><span class="line">         parentCoordinator,</span><br><span class="line">         transitionOptions,</span><br><span class="line">         priority,</span><br><span class="line">         overrideWidth,</span><br><span class="line">         overrideHeight);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>由于并未设置 thumbnail，先忽略缩略图相关逻辑，此方法中会调用到 obtainRequest 方法，继续跟踪，发现我们配置的 priority 参数在 SingleRequest 中的 onSizeReady 方法中被传入到 Engine 的 load 方法中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">     Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">     Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">     Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">     Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">     Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">     DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">     Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">     Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">     ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// ...省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">   DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">       decodeJobFactory.build(</span><br><span class="line">           glideContext,</span><br><span class="line">           model,</span><br><span class="line">           key,</span><br><span class="line">           signature,</span><br><span class="line">           width,</span><br><span class="line">           height,</span><br><span class="line">           resourceClass,</span><br><span class="line">           transcodeClass,</span><br><span class="line">           priority,</span><br><span class="line">           diskCacheStrategy,</span><br><span class="line">           transformations,</span><br><span class="line">           isTransformationRequired,</span><br><span class="line">           isScaleOnlyOrNoTransform,</span><br><span class="line">           onlyRetrieveFromCache,</span><br><span class="line">           options,</span><br><span class="line">           engineJob);</span><br><span class="line"></span><br><span class="line">   jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">   engineJob.addCallback(cb);</span><br><span class="line">   engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">     logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里在构建 DecodeJob 时将优先级配置传入，最终传入到 DecodeJob 和 DecodeHelper 中，其中 DecodeHelper 被 DecodeJob 持有。</p><p>接下来分析 priority 参数分别在什么时候被用到，首先看 DecodeJob 中持有的 priority，其仅在实现 Comparable 接口时用到，这个比较容易理解，可以通过对 DecodeJob 排序来实现优先级的调整。DecodeHelper 中持有的 priority 在 DataFetcher 的 loadData 方法中被传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority, @NonNull DataCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span></span>;</span><br></pre></td></tr></table></figure><p>DataFetch 用于加载数据，其实现有很多：</p><p><img src="https://upload-images.jianshu.io/upload_images/4679478-f7b5a4e8759e4930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>但并不是所有方法都能应用优先级的，这取决与具体的业务组件，比如 OkHttp 不支持请求优先级设置，直接忽略了 priority 参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull <span class="keyword">final</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder().url(url.toStringUrl());</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : url.getHeaders().entrySet()) &#123;</span><br><span class="line">    String key = headerEntry.getKey();</span><br><span class="line">    requestBuilder.addHeader(key, headerEntry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  Request request = requestBuilder.build();</span><br><span class="line">  <span class="keyword">this</span>.callback = callback;</span><br><span class="line"></span><br><span class="line">  call = client.newCall(request);</span><br><span class="line">  call.enqueue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 Volley 就支持请求优先级：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),</span><br><span class="line">      url.getHeaders());</span><br><span class="line">  requestQueue.add(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此也可以得出设置请求优先级并不是必然生效的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;若一个界面中需要展示多张图片，我们可能会期望某张图片优先加载，这就需要设置 Glide 的请求优先级， Glide 中提供四种优先级：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 图片格式及内存优化</title>
    <link href="http://yhaowa.gitee.io/da1371bf/"/>
    <id>http://yhaowa.gitee.io/da1371bf/</id>
    <published>2019-02-17T08:24:22.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得刚接触 Glide 时，总会看到这个描述：</p><p><em>Glide 默认的 Bitmap 格式是 RGB_565，相比于 Picasso，加载的图片质量略差，但比 ARGB_8888 格式的内存开销要小一半。</em></p><p>而现在再讲这个特性就不对了，因为在 Glide v4 中，默认的 Bitmap 格式改为了 ARGB_8888。准确来说是默认的解码格式由 PREFER_RGB_565 改为了 PREFER_ARGB_8888，具体可参考 <a href="https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#解码格式" target="_blank" rel="noopener">官方文档</a> 。</p><a id="more"></a><p>Glide 中可配置的解码格式只提供了 PREFER_RGB_565 和 PREFER_ARGB_8888 两个选项，而 Android Bitmap Config 中提供了 RGB_565、ARGB_8888、ARGB_4444 以及 HARDWARE 等 7 种格式，这让我们在使用层面上有一定程度的简化， Glide 内部自行适配了其他解码格式，比如若配置为 PREFER_ARGB_8888，在 Android 8.0 系统上就会尝试开启硬件位图编码格式，对应代码于 DecodeJob 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Options <span class="title">getOptionsWithHardwareConfig</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">  Options options = <span class="keyword">this</span>.options;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) &#123;</span><br><span class="line">    <span class="keyword">return</span> options;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isHardwareConfigSafe =</span><br><span class="line">      dataSource == DataSource.RESOURCE_DISK_CACHE || decodeHelper.isScaleOnlyOrNoTransform();</span><br><span class="line">  Boolean isHardwareConfigAllowed = options.get(Downsampler.ALLOW_HARDWARE_CONFIG);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If allow hardware config is defined, we can use it if it's set to false or if it's safe to</span></span><br><span class="line">  <span class="comment">// use the hardware config for the request.</span></span><br><span class="line">  <span class="keyword">if</span> (isHardwareConfigAllowed != <span class="keyword">null</span> &amp;&amp; (!isHardwareConfigAllowed || isHardwareConfigSafe)) &#123;</span><br><span class="line">    <span class="keyword">return</span> options;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If allow hardware config is undefined or is set to true but it's unsafe for us to use the</span></span><br><span class="line">  <span class="comment">// hardware config for this request, we need to override the config.</span></span><br><span class="line">  options = <span class="keyword">new</span> Options();</span><br><span class="line">  options.putAll(<span class="keyword">this</span>.options);</span><br><span class="line">  options.set(Downsampler.ALLOW_HARDWARE_CONFIG, isHardwareConfigSafe);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档关于 <a href="https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html" target="_blank" rel="noopener">硬件位图</a> 的介绍也比较清晰，就不过多描述了。另外 Android 端涉及到图片内存，必须了解的一个问题就是：<a href="https://zhuanlan.zhihu.com/p/20732309?refer=bennyhuo" target="_blank" rel="noopener">你的 Bitmap 究竟占多大内存？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得刚接触 Glide 时，总会看到这个描述：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Glide 默认的 Bitmap 格式是 RGB_565，相比于 Picasso，加载的图片质量略差，但比 ARGB_8888 格式的内存开销要小一半。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;而现在再讲这个特性就不对了，因为在 Glide v4 中，默认的 Bitmap 格式改为了 ARGB_8888。准确来说是默认的解码格式由 PREFER_RGB_565 改为了 PREFER_ARGB_8888，具体可参考 &lt;a href=&quot;https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#解码格式&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 加载图片到通知栏和应用小部件中</title>
    <link href="http://yhaowa.gitee.io/693b387a/"/>
    <id>http://yhaowa.gitee.io/693b387a/</id>
    <published>2019-02-17T08:23:48.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>上面说到的下载、预加载主要通过 RequestFutureTarget、PreloadTarget 实现，平时使用 Glide 直接加载图片到 ImageView 的方式则是通过 ImageViewTarget，Glide 中还提供了 NotificationTarget 和 AppWidgetTarget 来实现加载图片到通知栏和应用小部件中。使用方法十分简单，下面列出加载图片到通知栏的实现示例：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载图片到通知栏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadNotificationImg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建一个通知栏</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NOTIFICATION_ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> RemoteViews rv = <span class="keyword">new</span> RemoteViews(context.getPackageName(), R.layout.remoteview_notification);</span><br><span class="line">    rv.setImageViewResource(R.id.iv, R.mipmap.ic_launcher);</span><br><span class="line">    rv.setTextViewText(R.id.tv, <span class="string">"Short Message"</span>);</span><br><span class="line">    NotificationCompat.Builder mBuilder =</span><br><span class="line">            <span class="keyword">new</span> NotificationCompat.Builder(context, <span class="string">"channel_id"</span>)</span><br><span class="line">                    .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                    .setContentTitle(<span class="string">"Content Title"</span>)</span><br><span class="line">                    .setContentText(<span class="string">"Content Text"</span>)</span><br><span class="line">                    .setContent(rv)</span><br><span class="line">                    .setPriority(NotificationCompat.PRIORITY_HIGH);</span><br><span class="line">    <span class="keyword">final</span> Notification notification = mBuilder.build();</span><br><span class="line">    notification.bigContentView = rv;</span><br><span class="line">    NotificationManager service = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    service.notify(NOTIFICATION_ID, notification);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载图片到通知栏</span></span><br><span class="line">    NotificationTarget notificationTarget = <span class="keyword">new</span> NotificationTarget(</span><br><span class="line">            context,</span><br><span class="line">            R.id.iv,</span><br><span class="line">            rv,</span><br><span class="line">            notification,</span><br><span class="line">            NOTIFICATION_ID);</span><br><span class="line">    Glide.with(context).asBitmap().load(imgUrl).into(notificationTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的更新方法封装于 NotificationTarget 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Updates the Notification after the Bitmap resource is loaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NotificationManager manager =</span><br><span class="line">      (NotificationManager) <span class="keyword">this</span>.context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">  Preconditions.checkNotNull(manager)</span><br><span class="line">      .notify(<span class="keyword">this</span>.notificationTag, <span class="keyword">this</span>.notificationId, <span class="keyword">this</span>.notification);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 AppWidgetTarget 加载图片到应用小部件中与此类似，这些均继承自  <a href="https://muyangmin.github.io/glide-docs-cn/doc/targets.html" target="_blank" rel="noopener">Target</a> 接口，了解原理后，我们可以自定义 Target 来随意的定制功能了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上面说到的下载、预加载主要通过 RequestFutureTarget、PreloadTarget 实现，平时使用 Glide 直接加载图片到 ImageView 的方式则是通过 ImageViewTarget，Glide 中还提供了 NotificationTarget 和 AppWidgetTarget 来实现加载图片到通知栏和应用小部件中。使用方法十分简单，下面列出加载图片到通知栏的实现示例：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 下载及预加载</title>
    <link href="http://yhaowa.gitee.io/a7bea0ed/"/>
    <id>http://yhaowa.gitee.io/a7bea0ed/</id>
    <published>2019-02-17T08:21:41.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>下载的标准写法如下，也是官方示例写法：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downloadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FutureTarget&lt;File&gt; target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        target = Glide.with(context)</span><br><span class="line">                .downloadOnly()</span><br><span class="line">                .load(imgUrl)</span><br><span class="line">                .submit();</span><br><span class="line">        <span class="keyword">final</span> File cacheFile = target.get();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  默认会下载到磁盘缓存中,理论上不应对缓存文件进行编辑、删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"download: "</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 这里要调用cancel方法取消等待操作并释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.cancel(<span class="keyword">true</span>); <span class="comment">// 若传true则允许中断操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方式要自行开子线程，你可能会觉得稍显麻烦，直接调用 listener 方法监听 onResourceReady 回调岂不是更简单？其实不是的，由于要拿到 FutureTarget 调用其 cancel 方法，若监听 onResourceReady 代码逻辑会更复杂。</p><p>对于 FutureTarget.get() 方法，并不是调用时才会去加载数据，调用 submit 方法后就已经开始去加载数据了，get 方法最终会调用到 RequestFutureTarget 的 doGet 方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> R <span class="title">doGet</span><span class="params">(Long timeoutMillis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (assertBackgroundThread &amp;&amp; !isDone()) &#123;</span><br><span class="line">    Util.assertBackgroundThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadFailed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(exception);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultReceived) &#123;</span><br><span class="line">    <span class="keyword">return</span> resource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timeoutMillis == <span class="keyword">null</span>) &#123;</span><br><span class="line">    waiter.waitForTimeout(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> deadline = now + timeoutMillis;</span><br><span class="line">    <span class="keyword">while</span> (!isDone() &amp;&amp; now &lt; deadline) &#123;</span><br><span class="line">      waiter.waitForTimeout(<span class="keyword">this</span>, deadline - now);</span><br><span class="line">      now = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadFailed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(exception);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!resultReceived) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 get 方法内部并没有加载数据的逻辑， RequestFutureTarget 内部通过锁实现了 get 方法的阻塞调用，当资源加载完毕后 onResourceReady 中会解除阻塞：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">onResourceReady</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    R resource, Object model, Target&lt;R&gt; target, DataSource dataSource, <span class="keyword">boolean</span> isFirstResource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We might get a null result.</span></span><br><span class="line">  resultReceived = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.resource = resource;</span><br><span class="line">  waiter.notifyAll(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了下载 File 类型以外，还可以指定下载类型，比如下载 Bitmap：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downloadBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestOptions DOWNLOAD_ONLY_OPTIONS = RequestOptions</span><br><span class="line">            .diskCacheStrategyOf(DiskCacheStrategy.DATA) <span class="comment">//这边其实可以根据业务场景配置，如果是网络图片一般需要缓存</span></span><br><span class="line">            .priority(Priority.LOW) <span class="comment">// 设置优先级</span></span><br><span class="line">            .skipMemoryCache(<span class="keyword">true</span>);</span><br><span class="line">    FutureTarget&lt;Bitmap&gt; target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        target = Glide.with(context)</span><br><span class="line">                .asBitmap()</span><br><span class="line">                .apply(DOWNLOAD_ONLY_OPTIONS)</span><br><span class="line">                .load(imgUrl)</span><br><span class="line">                .submit();</span><br><span class="line">        <span class="keyword">final</span> Bitmap bitmap = target.get();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"download: "</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 这里要调用cancel方法取消等待操作并释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.cancel(<span class="keyword">true</span>); <span class="comment">// 若传true则允许中断操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 DOWNLOAD_ONLY_OPTIONS 配置其实就是 downloadOnly 方法应用的配置。</p><p>实现预加载十分简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(imgUrl).preload();</span><br></pre></td></tr></table></figure></p><p>关键代码位于 PreloadTarget 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreloadTarget</span>&lt;<span class="title">Z</span>&gt; <span class="keyword">extends</span> <span class="title">SimpleTarget</span>&lt;<span class="title">Z</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_CLEAR = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper(), <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (message.what == MESSAGE_CLEAR) &#123;</span><br><span class="line">        ((PreloadTarget&lt;?&gt;) message.obj).clear();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RequestManager requestManager;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;Z&gt; <span class="function">PreloadTarget&lt;Z&gt; <span class="title">obtain</span><span class="params">(RequestManager requestManager, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PreloadTarget&lt;&gt;(requestManager, width, height);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PreloadTarget</span><span class="params">(RequestManager requestManager, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(width, height);</span><br><span class="line">    <span class="keyword">this</span>.requestManager = requestManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(@NonNull Z resource, @Nullable Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>&#123;</span><br><span class="line">    HANDLER.obtainMessage(MESSAGE_CLEAR, <span class="keyword">this</span>).sendToTarget();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">  <span class="meta">@Synthetic</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    requestManager.clear(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相比于 RequestFutureTarget，PreloadTarget 里的逻辑就简单多了，可以看到加载资源结束后只是把此次请求释放掉了，不用像其他 Target 一样做额外的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下载的标准写法如下，也是官方示例写法：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 感知生命周期 </title>
    <link href="http://yhaowa.gitee.io/c135648c/"/>
    <id>http://yhaowa.gitee.io/c135648c/</id>
    <published>2019-02-17T08:20:28.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>发起一个图片加载请求后，我们期望当该请求所处的界面 onStop 时请求也随之停止，再次 onStart 时请求能够随之继续， onDestroy 时请求能够随之销毁。这就需要能够感知当前 Activity 的生命周期变化，由于 Fragment 在 onAttach 之后与 Activity 有相同的生命周期，glide 利用这一点，通过给 Activity 添加一个无界面的 Fragment 实现感知。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/4679478-ac8b2896aba7322b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>发起请求时通过 with 方法传入上下文，此方法会返回一个 RequestManager，RequestManager 用于管理和启动图片加载请求，可以感知外部 Activity 的生命周期，从而管理请求随之启动、停止和重启。</p><p>先来分析一个较为简单的流程：with 方法传入 Activity，会调用到 RequestManagerRetriever 的 get 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      <span class="keyword">return</span> fragmentGet(</span><br><span class="line">          activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>其中调用 fragmentGet 方法去新建 RequestManager ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(@NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里新建了一个无界面的 Fragment，并添加到该界面</span></span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">    <span class="comment">//这里新建了一个 requestManager，并将无界面 Fragment 的生命周期暴露给 requestManager</span></span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>当无界面 Fragment 生命周期变化时，通过接口回调出去给 requestManager，这样 requestManager 就实现了随外部生命周期变化自动启动、停止和重启请求。with 方法若传入其他参数，流程上也是大同小异，都是找到当前 Activity 或 Fragment ，给其添加一个无界面 Fragment 罢了。</p><p>而不管传入何参数，都有这样一个逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">     <span class="keyword">return</span> get(view.getContext().getApplicationContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若当前处于非主线程，则一律基于应用生命周期请求，不再关心所在 Fragment 或 Activity 的生命周期，这是因为子线程中执行的任务本身就是跟所在界面生命周期无关的。</p><p>在分析这一块时涉及 ContextWrapper 相关的逻辑，若不太熟悉，可参考：<a href="https://blog.csdn.net/guolin_blog/article/details/47028975" target="_blank" rel="noopener">ContextWrapper</a> 。</p><p>Glide 推出时谷歌还未发布 Architecture Components，而现在若要实现一个可感知生命周期的逻辑，大可不必像 Glide 一样添加一个 Fragment ，直接使用 Architecture Components 中的 Lifecycle 组件就可以很方便的实现了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发起一个图片加载请求后，我们期望当该请求所处的界面 onStop 时请求也随之停止，再次 onStart 时请求能够随之继续， onDestroy 时请求能够随之销毁。这就需要能够感知当前 Activity 的生命周期变化，由于 Fragment 在 onAttach 之后与 Activity 有相同的生命周期，glide 利用这一点，通过给 Activity 添加一个无界面的 Fragment 实现感知。&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Android 端音频变声方案</title>
    <link href="http://yhaowa.gitee.io/785f874e/"/>
    <id>http://yhaowa.gitee.io/785f874e/</id>
    <published>2018-11-01T15:23:58.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>音频变声实质上是通过调整 PCM 数据的音调、节拍等属性，实现听感上的变化。如果是 mp3、aac 等压缩音频，则需提前解码成 PCM 数据，Android 端可以通过 MediaExtractor 及 MediaCodec 解码得到 PCM，但调整音调、节拍仅靠 Android api 就无能为力了，只能集成第三方库来实现，常见的音频处理库有 <a href="https://www.fmod.com" target="_blank" rel="noopener">Fmod</a> 、  <a href="http://www.surina.net/soundtouch/" target="_blank" rel="noopener">SoundTouch</a> 。</p><a id="more"></a><h3 id="Fmod"><a href="#Fmod" class="headerlink" title="Fmod"></a>Fmod</h3><p>Fmod 是一个跨平台的音频处理引擎，官网提供了各个平台的 <a href="https://www.fmod.com/resources/documentation-api" target="_blank" rel="noopener">接入文档</a>，可以实现变调、变速变声效果以及混响、颤音等高级效果。开发调用简单，sdk 对外提供了播放器接口，传入音频文件即可直接变声播放。但不支持保存处理后的音频到文件，商业用途需要购买许可证。</p><p>如果你不需要保存处理后的音频到文件，那就使用 Fmod 吧，你会发现音频变声是如此简单，而且还支持混响、颤音等高级变声效果！</p><p>如果需要保存处理后的音频到文件，那么……我就请你再认真的思考一下，你的需求真的必须要保存处理后的音频吗？假设一个聊天 app 要实现语音消息变声，那这段语音只会在你的应用中播放，那就都可以通过 Fmod 播放器变声播放啊，要知道 Fmod 可是一个跨平台的音频引擎，不论是 Android、IOS 还是 Web 端，只要知道变声参数就可以变声播放了，不需要保存处理后的音频到文件。</p><p>能否跃过不支持保存处理后的音频到文件这一缺点，关键是要确定用户能否直接接触到处理后的音频文件，若能接触到，就无法使用 Fmod 了。</p><p>关于集成使用 Fmod 库十分简单，网上也有很多，就不再展开了。</p><h3 id="SoundTouch"><a href="#SoundTouch" class="headerlink" title="SoundTouch"></a>SoundTouch</h3><p>SoundTouch 是一个开源免费的音频处理库，可以改变音调、节拍和播放速率。开发调用时需自行将音频文件解码成 PCM 数据，传入 SoundTouch 处理后，SoundTouch 会输出处理后的 PCM 数据。基于这种使用方式，我们可以对其自由定制以适用于自己的应用。</p><p>比如你要实现一个 mp3 的变声播放，可以先用 MediaCodec 将 mp3 解码成 PCM，通过 SoundTouch 处理得到变声后的 PCM，再结合 AudioTrack 实现播放；如果你要将一个 mp3 变声后保存下来，那就在得到变声后的 PCM 后，结合 MediaCodec 将其编码保存下来。</p><p>相比 Fmod，SoundTouch 的集成会复杂点，不是随便参考一篇教程就可以跑通的了，这里提供一份亲测可行的 <a href="https://github.com/yhaolpz/AndroidSoundTouch" target="_blank" rel="noopener">SoundTouch 源码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;音频变声实质上是通过调整 PCM 数据的音调、节拍等属性，实现听感上的变化。如果是 mp3、aac 等压缩音频，则需提前解码成 PCM 数据，Android 端可以通过 MediaExtractor 及 MediaCodec 解码得到 PCM，但调整音调、节拍仅靠 Android api 就无能为力了，只能集成第三方库来实现，常见的音频处理库有 &lt;a href=&quot;https://www.fmod.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fmod&lt;/a&gt; 、  &lt;a href=&quot;http://www.surina.net/soundtouch/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SoundTouch&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="FFmpeg" scheme="http://yhaowa.gitee.io/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
</feed>
