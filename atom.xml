<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Great hopes make great man</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yhaowa.gitee.io/"/>
  <updated>2020-04-22T15:50:42.188Z</updated>
  <id>http://yhaowa.gitee.io/</id>
  
  <author>
    <name>Ahab</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>细读《深入理解 Android 内核设计思想》（三）Binder 机制 [上]</title>
    <link href="http://yhaowa.gitee.io/a7541469/"/>
    <id>http://yhaowa.gitee.io/a7541469/</id>
    <published>2020-04-12T09:58:51.000Z</published>
    <updated>2020-04-22T15:50:42.188Z</updated>
    
    <content type="html"><![CDATA[<p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em><br><a id="more"></a></p><blockquote><ol><li>必备知识<ol><li>设备驱动</li><li>文件描述符</li><li>页框</li></ol></li><li>Binder 概述</li><li>binder 驱动<ol><li>binder_open</li><li>binder_mmap</li><li>binder_ioctl</li></ol></li><li>Service Manager<ol><li>启动</li><li>注册与查询</li></ol></li><li>最后</li></ol></blockquote><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>Linux 把所有的硬件访问都抽象为对文件的读写、设置，这一”抽象”的具体实现就是驱动程序。驱动程序充当硬件和软件之间的枢纽，提供了一套标准化的调用，并将这些调用映射为实际硬件设备相关的操作，对应用程序来说隐藏了设备工作的细节。  </p><p>Linux 设备分为三类，分别是字符设备、块设备和网络设备：</p><p><strong>1.字符设备：</strong> 能够像字节流（类似文件）一样被访问的设备。对字符设备进行读/写操作时，实际硬件的 I/O 操作一般也紧接着发生。字符设备驱动程序通常都会实现 open、close、read 和 write 系统调用，比如触摸屏、键盘、串口、LCD、LED 等。<br><strong>2.块设备：</strong> 指通过传输数据块（一般为 512 或 1k）来访问的设备，比如硬盘、SD卡、U盘、光盘等。<br><strong>3.网络设备：</strong> 能够和其他主机交换数据的设备，比如网卡设备、蓝牙设备等。</p><p>通过 cat /proc/devices 命令可以查看字符设备和块设备：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Character devices:</span><br><span class="line">  <span class="number">1</span> mem</span><br><span class="line">  <span class="number">4</span> ttyS</span><br><span class="line"> <span class="number">10</span> misc</span><br><span class="line">   ...</span><br><span class="line">Block devices:</span><br><span class="line">  <span class="number">1</span> ramdisk</span><br><span class="line">  <span class="number">7</span> loop</span><br><span class="line">  <span class="number">8</span> sd</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p><p>可以看到属于字符设备的 misc 杂项设备，设备号为 10。通过  ls /dev -l 命令可以查看具体的注册设备：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crw-rw-rw- <span class="number">1</span> root   root    <span class="number">10</span>,  <span class="number">61</span> <span class="number">2020</span><span class="number">-03</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span> ashmem</span><br><span class="line">crw-rw-rw- <span class="number">1</span> root   root    <span class="number">10</span>,  <span class="number">58</span> <span class="number">2020</span><span class="number">-03</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span> binder</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>其中 Ashmem、Binder 的设备号是 10，都属于 misc 杂项设备，10 是 <strong>主设备号</strong>，61、58 叫做 <strong>从设备号</strong>，有了主、从设备号，就可以唯一标识一个设备。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。</p><p>文件描述符与文件是什么关系呢？下图 Linux 中的三张表可以体现：<br><img src="../img/fd.png" alt></p><ul><li><p><strong>进程级别的文件描述符表</strong>：内核为每个进程维护一个文件描述符表，该表记录了文件描述符的相关信息，包括文件描述符、指向打开文件表中记录的指针。</p></li><li><p><strong>系统级别的打开文件表</strong>：内核对所有打开文件维护的一个进程共享的打开文件描述表，表中存储了处于打开状态文件的相关信息，包括文件类型、访问权限、文件操作函数(file_operations)等。</p></li><li><p><strong>系统级别的 i-node 表</strong>：i-node 结构体记录了文件相关的信息，包括文件长度，文件所在设备，文件物理位置，创建、修改和更新时间等，”ls -i” 命令可以查看文件 i-node 节点</p></li></ul><p>文件描述符是一种系统资源，可以通过以下命令来查看文件描述符的上限：<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有进程允许打开的最大 fd 数量</span></span><br><span class="line">126|generic_x86:/ # cat /proc/sys/fs/file-max</span><br><span class="line">174139</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有进程已经打开的 fd 数量以及允许的最大数量</span></span><br><span class="line">generic_x86:/ # cat /proc/sys/fs/file-nr</span><br><span class="line">11040   0       174139</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看单个进程允许打开的最大 fd 数量.</span></span><br><span class="line">generic_x86:/ # ulimit -n</span><br><span class="line">32768</span><br></pre></td></tr></table></figure></p><p>也可以查看某进程当前已使用的 fd ：<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看某进程（进程 id 为 15077）已经打开的 fd</span></span><br><span class="line">generic_x86:/ # ls -l /proc/15077/fd/</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 0 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 1 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 35 -&gt; /dev/binder</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-09 01:01 44 -&gt; socket:[780404]</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 55 -&gt; /dev/ashmem</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 60 -&gt; /dev/ashmem</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>上面这个进程是一个 Android 应用进程，所以能看到 ashmem、binder 等 Android 特有设备文件相关的 fd 。再来看一个实际打开磁盘文件的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(getCacheDir(), <span class="string">"testFdFile"</span>);</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br></pre></td></tr></table></figure></p><p>执行上面代码后会申请一个对应的 fd：<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -l /proc/&#123;pid&#125;/fd/</span></span><br><span class="line">...</span><br><span class="line">l-wx------ u0_a55   u0_a55  2020-04-16 00:24 995 -&gt; /data/data/com.example.test/cache/testFdFile</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>实际开发中，可能会遇到 fd 资源超过上限导致的 “Too many open files” 之类的问题，一般都是因为没有及时释放掉 fd，比如上面代码中 FileOutputStream 没有关闭，若循环执行超过单个进程允许打开的最大 fd 数量，程序就会出现异常。</p><h3 id="页框"><a href="#页框" class="headerlink" title="页框"></a>页框</h3><p>页框（Page Frame）是指一块实际的物理内存块，页是指程序的一块内存数据单元。内存数据一定是存储在实际的物理内存上，即页必然对应于一个页框，页数据实际是存储在页框上的。</p><p>页框和页一样大，都是内核对内存的分块单位。一个页框可以映射给多个页，也就是说一块实际的物理存储空间可以映射给多个进程的多个虚拟内存空间，这也是 mmap 机制依赖的基础规则。</p><h2 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h2><p>不同进程处于不同的内存空间，具有不同的虚拟地址映射规则，所以不能直接通信。 Binder 是 Android 中使用最广泛的 IPC 机制，正因为有了 Binder，Android 系统中形形色色的进程与组件才能真正统一成有机的整体。Binder 通信机制与 TCP/IP 有共通之处，其组成元素可以这样来类比：</p><ul><li>binder 驱动  -&gt;  路由器</li><li>Service Manager  -&gt; DNS</li><li>Binder Client  -&gt;  客户端</li><li>Binder Server  -&gt;  服务器</li></ul><p>Binder 的本质目标就是客户端要与服务器通信，但由于是不同的进程，必须通过 binder 驱动（路由器）把请求正确投递到对方进程中，所以通信的进程需要持有一个唯一的 Binder 标志（IP 地址）。</p><p>而 Binder 标志可能是会动态更新的 “IP 地址”，对通信进程来说获取难度较大且可读性差，这就需要一个 Service Manager（DNS）来解决这个问题。但 Service Manager 自身也是一个 Binder Server（服务器），怎么找到它的 “IP 地址”呢？Binder 机制对此做了特别规定：Service Manager 在 Binder 通信过程中的唯一标志永远是 0。</p><h2 id="binder-驱动"><a href="#binder-驱动" class="headerlink" title="binder 驱动"></a>binder 驱动</h2><p>binder 驱动运行在内核态，向上层提供 /dev/binder 设备节点，并不对应真实的硬件设备。binder 驱动的注册逻辑在 Binder.c 中：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/staging/android/Binder.c</span></span><br><span class="line"><span class="keyword">static</span> init __init binder_init(<span class="keyword">void</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = misc_register(&amp;binder_miscdev); <span class="comment">//注册为 misc 驱动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>binder_miscdev 即 Binder 设备描述如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice binder_miscdev = &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR, <span class="comment">//自动分配次设备号</span></span><br><span class="line">    .name = <span class="string">"binder"</span>, <span class="comment">//驱动名称</span></span><br><span class="line">    .fops = &amp;binder_fops <span class="comment">//binder 驱动支持的文件操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>binder_fops 为 Binder 设备支持的操作函数，如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>与 Ashmem 设备类似，最关键的是 binder_open()、binder_mmap()、binder_ioctl()，下面分别介绍这三个函数。</p><h3 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h3><p>用户应用程序通过 Binder 通信时，需先调用 binder_open() 方法打开 binder 驱动，binder_open() 中主要做了两个工作，对应的分为两部分来看：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//binder.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_open(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc;</span><br><span class="line">    ...</span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); <span class="comment">//创建 binder_proc</span></span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo); <span class="comment">//初始化 todo 队列</span></span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait); <span class="comment">//初始化 todo 队列</span></span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br></pre></td></tr></table></figure></p><p>上面代码的主要工作是 <strong>创建及初始化 binder_proc</strong>，binder_proc 就是用来存放 binder 相关数据的结构体，每个进程独有一份。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    binder_lock(__func__);</span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个主要工作是 <strong>将 binder_proc 记录起来</strong>，方便后续使用，如上代码所示，通过 hlist_add_head() 方法将 binder_proc 记录到了内核的 binder_procs 表中，另外还将 binder_proc 存放在 filp 的 private_data 域，以便于在后续调用 mmap、ioctl 等方法时获取。</p><h3 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h3><p>对于 binder 驱动来说，上层应用调用的 mmap() 最终会执行到 binder_mmap() 方法，binder_mmap() 的主要工作是<strong>将上层应用的虚拟内存块和 Binder 申请的物理内存块建立映射</strong>，应用程序和 Binder 就拥有了共享的内存空间，这样不同的应用程序之间可以通过 Binder 实现数据共享。举个例子：</p><ul><li>Binder 中有一物理内存块 P；A 进程中有一内存块 a ；B 进程中有一内存块 b</li><li>将 P 分别与 a、b 建立映射，这样 a、b 就可以看作同一块内存</li><li>若 A 进程想要发送数据给 B 进程，只需将数据拷贝到 a 内存，B 进程就能直接读取到了</li></ul><p>所以 Binder 只需一次拷贝，binder_mmap() 要做的就是将 P 与 a 建立映射，该方法代码较长，分段看关键部分代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_mmap(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)&#123;</span><br><span class="line">    <span class="keyword">struct</span> vm_struct *area;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</span><br><span class="line">    <span class="comment">//映射空间至多 4M</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">          vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line">    <span class="comment">//检查 vma 是否被禁用</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">          ret = -EPERM;</span><br><span class="line">          failure_string = <span class="string">"bad vm_flags"</span>;</span><br><span class="line">          <span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>vma(vm_area_struct) 是<strong>用户态虚拟内存地址空间</strong>，也就是 a</li><li>area(vm_struct) 是<strong>内核态虚拟地址空间</strong>，指向 P</li><li>proc(binder_proc) 即 binder_open() 中创建的、存放 binder 相关数据的结构体</li><li>另外还做了限制映射空间至多 4M 等映射规则的检查和处理</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> mutex_lock(&amp;binder_mmap_lock);</span><br><span class="line"><span class="comment">//检查是否已执行过 binder_mmap 映射过</span></span><br><span class="line"><span class="keyword">if</span> (proc-&gt;buffer) &#123; </span><br><span class="line">      ret = -EBUSY;</span><br><span class="line">      failure_string = <span class="string">"already mapped"</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//申请内核虚拟内存地址空间</span></span><br><span class="line">area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line"><span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将内核虚拟内存地址记录在 proc 中 </span></span><br><span class="line">proc-&gt;buffer = area-&gt;addr;</span><br><span class="line"><span class="comment">//记录用户态虚拟内存地址和内核态虚拟内存地址的偏移量</span></span><br><span class="line">proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;</span><br><span class="line">mutex_unlock(&amp;binder_mmap_lock);</span><br></pre></td></tr></table></figure><ul><li>proc-&gt;buffer 用于存储最终映射的内核态虚拟地址，并通过此变量控制只能映射一次</li><li>get_vm_area() 方法申请了与用户态空间大小一致的内核态虚拟地址空间，注意此时还没分配实际的物理内存</li><li>proc-&gt;user_buffer_offset 记录了用户态虚拟内存和内核态虚拟内存地址的偏移量，这样后续方便获取用户态虚拟内存地址</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配存放物理页地址的数组</span></span><br><span class="line">proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"><span class="comment">//申请一页物理内存</span></span><br><span class="line"><span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      failure_string = <span class="string">"alloc small buf"</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后的收尾工作：将内存记录到相应链表中，设置状态等</span></span><br><span class="line">INIT_LIST_HEAD(&amp;proc-&gt;buffers);</span><br><span class="line">list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</span><br><span class="line">buffer-&gt;free = <span class="number">1</span>;</span><br><span class="line">binder_insert_free_buffer(proc, buffer);</span><br><span class="line">proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">proc-&gt;files = get_files_struct(current);</span><br><span class="line">proc-&gt;vma = vma;</span><br></pre></td></tr></table></figure><ul><li>proc-&gt;pages 是一个二维指针，用于存放管理物理页面</li><li>binder_update_page_range() 方法真正的申请物理页面，并分别映射到内核态和用户态的虚拟内存地址空间</li></ul><p>至此 binder_mmap 方法执行结束，书中并没有对 <strong>binder_update_page_range()</strong> 方法具体展开介绍，但个人认为此方法代码非常有助于我们理解页框以及与虚拟内存地址的映射逻辑，所以继续分析，先了解此方法的参数：</p><ul><li>proc：申请内存的进程所持有的 binder_proc 对象</li><li>allocate：1 表示申请内存，0 表示释放内存</li><li>start：虚拟内存地址起点</li><li>end：虚拟内存地址终点</li><li>vma：用户态虚拟内存地址空间</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_update_page_range(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">int</span> allocate,</span><br><span class="line">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</span><br><span class="line">                    <span class="keyword">struct</span> vm_area_struct *vma)&#123;</span><br><span class="line">    <span class="keyword">if</span> (allocate == <span class="number">0</span>)  <span class="comment">//区分是申请还是释放</span></span><br><span class="line">         <span class="keyword">goto</span> free_range;</span><br><span class="line">    <span class="comment">//依据 start、end 循环分配物理页</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">          <span class="comment">//每次分配 1 个页框*/</span></span><br><span class="line">         *page = **alloc_page**(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);</span><br><span class="line">         <span class="comment">//将页框映射到内核态虚拟内存地址</span></span><br><span class="line">         ret = **map_kernel_range_noflush**((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr, PAGE_SIZE, PAGE_KERNEL, page);</span><br><span class="line">         <span class="comment">//根据 binder_mmap 方法中记录的偏移量计算出用户态虚拟内存地址</span></span><br><span class="line">         user_page_addr = (uintptr_t)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line">         <span class="comment">//将页框映射到用户态虚拟内存地址</span></span><br><span class="line">         ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>binder_mmap() 的 allocate 参数传入 1 为申请内存，执行上面的代码。若为释放则执行以下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">free_range:</span><br><span class="line">    <span class="comment">//依据 start、end 从后往前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = end - PAGE_SIZE; page_addr &gt;= start; page_addr -= PAGE_SIZE) &#123;</span><br><span class="line">        page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line">        <span class="keyword">if</span> (vma)</span><br><span class="line">            <span class="comment">//解除用户态虚拟地址和物理页框的映射</span></span><br><span class="line">            zap_page_range(vma, (uintptr_t)page_addr + proc-&gt;user_buffer_offset, PAGE_SIZE, <span class="literal">NULL</span>);</span><br><span class="line">err_vm_insert_page_failed:</span><br><span class="line">        <span class="comment">//解除内核态虚拟地址和物理页框的映射</span></span><br><span class="line">        unmap_kernel_range((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr, PAGE_SIZE);</span><br><span class="line">err_map_kernel_failed:</span><br><span class="line">        <span class="comment">//释放页框物理内存</span></span><br><span class="line">        __free_page(*page);</span><br><span class="line">        *page = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h3><p>binder 驱动并不提供常规的 read()、write() 等文件操作，全部通过 binder_ioctl() 实现，所以 binder_ioctl() 是 binder 驱动中工作量最大的一个，它承担了 binder 驱动的大部分业务。这里不深入分析源码，只列出 binder_ioctl() 支持的命令列表：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>BINDER_WRITE_READ</td><td>向 binder 驱动写入或读取数据</td></tr><tr><td>BINDER_SET_MAX_THREADS</td><td>设置支持的最大线程数</td></tr><tr><td>BINDER_SET_CONTEXT_MGR</td><td>Service Manager 专用的注册命令</td></tr><tr><td>BINDER_THREAD_EXIT</td><td>通知 binder 驱动某线程退出，释放相应资源</td></tr><tr><td>BINDER_VERSION</td><td>获取 Binder 版本号</td></tr></tbody></table><p>其中 BINDER_WRITE_READ 最为关键，分为若干子命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>BC_INCREFS、BC_ACQUIRE、BC_RELEASE、BC_DECREFS</td><td>管理 binder_ref 的引用计数</td></tr><tr><td>BC_INCREFS_DONE、BC_ACQUIRE_NODE</td><td>管理 binder_node 的引用计数</td></tr><tr><td>BC_FREE_BUFFER</td><td>释放 Binder 内存缓冲区</td></tr><tr><td>BC_TRANSACTION</td><td>向 binder 驱动发送通信数据(主动调用)</td></tr><tr><td>BC_REPLY</td><td>向 binder 驱动发送通信数据(返回结果)</td></tr><tr><td>BC_REGISTER_LOOPER、BC_ENTER_LOOPER、BC_EXIT_LOOPER</td><td>设置 Binder looper 状态</td></tr><tr><td>BC_REQUEST_DEATH_NOTIFICATION</td><td>注册 Binder 死亡通知</td></tr><tr><td>BC_CLEAR_DEATH_NOTIFICATION</td><td>清除 Binder 死亡通知</td></tr><tr><td>BC_DEAD_BINDER_DONE</td><td>告知 Binder 已处理完 Binder 死亡通知</td></tr></tbody></table><p>以上均为 binder 驱动作为接收方 binder_ioctl() 方法接收的命令，还有一些与之对应的 BR_ 开头的命令，由 binder 驱动主动发出，比如 BR_TRANSACTION、BR_REPLY，在一次 IPC 调用中是这样应用的：</p><div id="sequence-0"></div><h2 id="Service-Manager"><a href="#Service-Manager" class="headerlink" title="Service Manager"></a>Service Manager</h2><p>Service Manager 是为了完成 Binder Server Name（域名）和 Service Handle（IP 地址）之间对应关系的查询而存在的，可以推测它主要包含的功能：<br><strong>注册</strong>：当一个 Binder Server 创建后，应该将这个 Server 的 name 和 Handle 对应关系记录到 Service Manager 中<br><strong>查询</strong>：其他应用可以根据 Server 的 name 查询到对应的 Service Handle</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Android 系统第一个启动的 init 进程解析 init.rc 脚本时构建出系统的初始运行状态，Android 系统服务程序大多是在这个脚本中描述并被相继启动的，包括 zygote、mediaserver、surfaceflinger 以及 servicemanager 等，其中 servicemanager 描述如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#init.rc</span></span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="keyword">class</span> core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br></pre></td></tr></table></figure></p><p>可以看到，当 servicemanager 发生问题重启时，其他 healthd、zygote、media 等服务也会被重启。servicemanager 服务启动后执行 service_manager.c 的 main 函数，关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/cmds/servicemanager/service_manager.c</span></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_state *bs;</span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中三个函数对应了 servicemanager 初始化的三个关键工作：</p><ol><li>binder 驱动并映射内存块大小为 128KB ：binder_open()</li><li>将自己设置为 Binder “DNS” 管理者 ：binder_become_context_manager()</li><li>进入循环，等待 binder 驱动发来消息 ：binder_loop()</li></ol><p>下面分别来分析这三个函数，binder_open() 关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_state *binder_open(size_t mapsize)&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_state *bs;</span><br><span class="line">    <span class="keyword">struct</span> binder_version vers;</span><br><span class="line">    bs = malloc(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开 binder 驱动，最终调用 binder_open() 函数</span></span><br><span class="line">    bs-&gt;fd = open(<span class="string">"/dev/binder"</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取 Binder 版本，最终调用 binder_ioctl() 函数</span></span><br><span class="line">    ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将虚拟内存映射到 Binder，最终调用 binder_mmap() 函数</span></span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>binder_become_context_manager() ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binder_become_context_manager(<span class="keyword">struct</span> binder_state *bs)&#123;</span><br><span class="line">    <span class="comment">//发送 BINDER_SET_CONTEXT_MGR 命令，最终调用 binder_ioctl() 函数</span></span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>binder_loop() 关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> binder_loop(<span class="keyword">struct</span> binder_state *bs, binder_handler func)&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">//执行 BINDER_WRITE_READ 命令所需的数据格式：</span></span><br><span class="line">    <span class="keyword">struct</span> binder_write_read bwr;</span><br><span class="line">    uint32_t readbuf[<span class="number">32</span>]; <span class="comment">//每次读取数据的大小</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER; </span><br><span class="line">    <span class="comment">//先将 binder 驱动的进入循环命令发送给 binder 驱动：</span></span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(uint32_t));</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//进入循环</span></span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_buffer = (uintptr_t) readbuf; <span class="comment">//读取到的消息数据存储在 readbuf</span></span><br><span class="line">        <span class="comment">//执行 BINDER_WRITE_READ 命令读取消息数据</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理读取到的消息数据</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, (uintptr_t) readbuf, bwr.read_consumed, func);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BINDER_WRITE_READ 命令既可以用来读取数据也可以写入数据，具体是写入还是读取依赖 binder_write_read 结构体的 write_size 和 read_size 哪个大于 0，上面代码通过 bwr.read_size = sizeof(readbuf) 赋值，所以是读取消息。</p><p>binder_parse() 方法内部处理由 binder 驱动主动发出的、一系列 BR_ 开头的命令，包括上面提到过的 BR_TRANSACTION、BR_REPLY 等，简化后的代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binder_parse(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</span><br><span class="line">                 uintptr_t ptr, size_t size, binder_handler func)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            ...</span><br><span class="line">            res = func(bs, txn, &amp;msg, &amp;reply); <span class="comment">//处理消息</span></span><br><span class="line">            <span class="comment">//返回处理结果</span></span><br><span class="line">            inder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); </span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY: &#123;...&#125;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_BINDER: &#123;...&#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于 BR_TRANSACTION 命令主要做了两个工作，一是调用 func() 具体处理消息；二是调用 inder_send_reply() 将消息处理结果告知给 binder 驱动，注意这里的 func 是由 service_manager.c main 函数中传过来的方法指针，也就是 svcmgr_handler() 方法。</p><h3 id="注册与查询"><a href="#注册与查询" class="headerlink" title="注册与查询"></a>注册与查询</h3><p>经过上面 Service Manager 服务启动的过程分析，已经知道由 binder 驱动主动发过来的 BR_TRANSACTION 命令最终在 service_manager.c 的 svcmgr_handler() 方法中处理，那服务的注册与查询请求想必就是在这个方法中实现的了，确实如此，简化后的关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> svcmgr_handler(<span class="keyword">struct</span> binder_state *bs,</span><br><span class="line">                   <span class="keyword">struct</span> binder_transaction_data *txn,</span><br><span class="line">                   <span class="keyword">struct</span> binder_io *msg,</span><br><span class="line">                   <span class="keyword">struct</span> binder_io *reply)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">         <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">         <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">              <span class="comment">//查询服务，根据 name 查询 Server Handle</span></span><br><span class="line">              handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">             <span class="comment">//注册服务，记录服务的 name(下面的参数 s) 与 handle</span></span><br><span class="line">             <span class="keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">                 allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> SVC_MGR_LIST_SERVICES: &#123;</span><br><span class="line">             <span class="comment">//查询所有服务，返回存储所有服务的链表 svclist</span></span><br><span class="line">             si = svclist;</span><br><span class="line">             <span class="keyword">while</span> ((n-- &gt; <span class="number">0</span>) &amp;&amp; si)</span><br><span class="line">                 si = si-&gt;next;</span><br><span class="line">             <span class="keyword">if</span> (si) &#123;</span><br><span class="line">                 bio_put_string16(reply, si-&gt;name);</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 bio_XX 系列函数的作用是方便读写数据。注册的服务都会存储在 svclist 链表上，do_find_service() 方法遍历 svclist 查找对应的服务，do_add_service() 则是将服务插入到 svclist 链表上记录下来。</p><p>svcmgr_handler() 方法执行完后会进一步调用 inder_send_reply() 将执行结果回复给 binder 驱动，然后进入下一轮的循环继续等待处理消息。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>非常认可书中一个观点：或许我们不应该从已经完善的架构类图去推导它们各自的作用，而是从 Binder 设计者的角度出发，去思考如果要提供某个功能，应该怎么做？</p><p>通过上面的分析知道，Service Manager 开始工作后等待执行 binder 驱动发来的命令就行了，那其他进程如何访问 Service Manager 呢？无非就是以下步骤：</p><ul><li>1.打开 binder 驱动，将进程内虚拟内存块与 binder 驱动进行 mmap</li><li>2.通过 ioctl 通信，让 binder 驱动向 Service Manager 发送命令</li><li>3.binder 驱动返回结果</li></ul><p>不要怀疑，核心工作确实只有这些，只是还有一些细节待商榷，比如：</p><ul><li>打开并映射 binder 驱动需占用进程内存，可以限制一下打开次数或映射大小</li><li>binder 驱动的操作比较繁琐，native 层应该封装一下</li><li>Java 层也需要封装接口，方便上层应用调用…</li></ul><p>然后 ProcessState、IPCThreadState、BBinder、BpBinder 等等相继出现…</p><blockquote><p>链接：<a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzA5OTAxNDEyNg==&amp;hid=1&amp;sn=ebe1c61ff758e51e9e92fd907a99f342&amp;scene=18#wechat_redirect" target="_blank" rel="noopener">细读《深入理解 Android 内核设计思想》系列</a></p></blockquote><p><img src="../img/qrcode.jpg" alt></p><p><center>关注公众号，Get 更多知识点</center></p><p><script src="https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js"></script><script src="https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js"></script><script src="https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js"></script><script src="https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Client->Binder Driver:BC_TRANSACTIONBinder Driver->Client:BR_TRANSACTION_COMPLETEBinder Driver->Server:BR_TRANSACTIONServer->Binder Driver:BC_REPLYBinder Driver->Server:BR_TRANSACTION_COMPLETEBinder Driver->Client:BR_REPLY</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://yhaowa.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>细读《深入理解 Android 内核设计思想》（二）内存管理</title>
    <link href="http://yhaowa.gitee.io/2d9a78ad/"/>
    <id>http://yhaowa.gitee.io/2d9a78ad/</id>
    <published>2020-04-06T06:18:55.000Z</published>
    <updated>2020-04-12T15:24:38.120Z</updated>
    
    <content type="html"><![CDATA[<p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em><br><a id="more"></a></p><blockquote><ol><li>操作系统内存管理基础<ol><li>虚拟内存</li><li>内存分配与回收</li><li>mmap</li><li>Copy on Write</li></ol></li><li>Android 内存管理<ol><li>Low Memory Killer</li><li>Ashmem 驱动</li><li>MemoryFile 原理</li></ol></li><li>总结</li></ol></blockquote><h2 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h2><p>不论什么操作系统，内存管理都是绝对的重点和难点。内存管理旨在为系统中所有 Task 提供稳定可靠的内存分配、释放和保护机制。你可能会疑问，学习 Android 系统有必要了解 Linux Kernel 的内存管理机制吗？</p><p>是的！不论是 Android 的音频系统、GUI 系统，还是 Binder 的实现机理等，都是和内存管理息息相关的。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存就是当内存资源不足时，借用硬盘中的一部分的空间，充当内存使用。系统会挑选优先级低的内存数据放入硬盘，后续若要用到硬盘中的数据，系统会产生一次<strong>缺页中断</strong>，然后把数据交换回内存中。</p><p>要理解虚拟内存机制，就要理解三种地址空间，分别是逻辑地址、线性地址和物理地址：</p><p><strong>1.逻辑地址(Logical Address)</strong><br>逻辑地址是程序编译后产生的地址，也称为相对地址，由两部分组成：</p><ul><li>段选择子(Segment Selector)：描述逻辑地址所处的段</li><li>Offset：描述所在段内的偏移值</li></ul><p><strong>2.线性地址(Linear Address)</strong><br>线性地址是由逻辑地址经过<strong>分段机制转换</strong>后得到的。</p><p>大致转换过程为：通过段选择子确定段的基地址，然后结合 Offset 得到线性地址。</p><p><strong>3.物理地址(Physical Address)</strong><br>物理地址就是指机器真实的物理内存地址，任何操作系统，最终都要通过物理地址来访问内存。</p><p>若系统开启了分页机制，则在得到线性地址后需要通过<strong>分页机制转换</strong>后，才能得到物理地址。</p><p>简单来说，由逻辑地址得到物理地址过程如下：</p><ul><li>逻辑地址 -&gt; 分段机制转换 -&gt; 线性地址 -&gt; 分页机制转换 -&gt; 物理地址</li></ul><h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><p>内存的分配与回收是操作系统的重要组成部分，需要解决的核心问题包括：</p><ul><li>操作系统应保证应用程序的硬件无关性，硬件差异不能体现在应用程序上</li><li>内存划分的区域、分配粒度、最小单位，管理区分已使用和未使用的内存，回收等等</li><li>优化内存碎片，考虑整体机制的高效性</li></ul><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>mmap(Memory Map) 可以将某个设备或文件映射到应用进程的内存空间中，这样应用程序访问这块内存，相当于直接对设备/文件读写，不再需要 read、write 等 IO 操作。</p><p>mmap 函数如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射成功返回0，否则返回错误码</span></span><br><span class="line"><span class="keyword">void</span> *mmap(<span class="keyword">void</span> *addr, size_t len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, off_t offset);</span><br></pre></td></tr></table></figure></p><ul><li>addr：指文件/设备应该映射到进程空间的哪个起始地址</li><li>len：指被映射到进程空间的内存块大小</li><li>prot：指定被映射内存的访问权限，包括 PROT_READ(可读)、PROT_WRITE(可写) 等</li><li>flags：指定程序对内存块所做改变造成的影响，包括 MAP_SHARED(保存到文件) 等</li><li>fd：被映射到进程空间的文件描述符</li><li>offset：指定从文件的哪一部分开始映射</li></ul><p>源码见 <a href="http://androidxref.com/9.0.0_r3/xref/bionic/libc/bionic/mmap.cpp" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/bionic/libc/bionic/mmap.cpp</a> 。mmap 可用于跨进程通信，Linux Kernel 和 Android 中就频繁的用到了这个函数，比如 Android 的 Binder 驱动，下面分析 MemoryFile 原理时还会提到这个函数。</p><h3 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h3><p>Copy on Write(写时拷贝) 是指如果有多个调用者要请求同一资源，他们会获取到相同的指向这一资源的指针，直到某个调用者需修改资源时，系统才会复制一份副本给该调用者，而其他调用者仍使用最初的资源。</p><p>如果调用者不需要修改资源，就不会建立副本，多个调用者共享读取同一份资源。</p><p>Linux 的 fork() 函数就是 Copy on Write 的，实际开销很小，主要是给子进程创建进程描述符等，并且推迟甚至免除了数据拷贝操作。比如 fork() 后子进程需立即调用 exec() 装载新程序到进程的内存空间，即不需要父进程的任何数据，这种情况 Copy on Write 技术就避免了不必要的数据拷贝，从而提升了运行速度。</p><h2 id="Android-内存管理"><a href="#Android-内存管理" class="headerlink" title="Android 内存管理"></a>Android 内存管理</h2><h3 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h3><p>Linux Kernel 有自己的内存监控机制，即 OOMKiller。当系统的可用内存达到临界值时，OOMKiller 就会按照优先级从低到高杀掉进程。优先级该如何衡量呢？OOMKiller 会综合进程当前消耗内存、进程占用 CPU 时间、进程类型等因素，对进程实时评分。分值存储在 /proc/{PID}/oom_score 中，可通过 cat 命令查看。分值越低的进程，优先级越高，被杀死的概率越小。</p><p>基于 Linux 内核 OOMKiller 的核心思想，Android 系统拓展出了自己的内存监控体系，相比 Linux 达到临界值才触发，Android 实现了<strong>不同梯级</strong>的 Killer。Android 系统为此开发了专门的驱动，名为 Low Memory Killer，源码在内核的 /drivers/staging/android/Lowmemorykiller.c 中。</p><p>Lowmemorykiller.c 中有如下定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_adj[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_adj_size = <span class="number">4</span>; <span class="comment">//页大小</span></span><br><span class="line"><span class="keyword">static</span> size_t lowmem_minfree[<span class="number">6</span>] = &#123; <span class="comment">//元素使用时以 lowmem_adj_size 为单位</span></span><br><span class="line">    <span class="number">3</span> * <span class="number">512</span>, <span class="comment">//6MB</span></span><br><span class="line">    <span class="number">2</span> * <span class="number">1024</span>, <span class="comment">//8MB</span></span><br><span class="line">    <span class="number">4</span> * <span class="number">1024</span>, <span class="comment">//16MB</span></span><br><span class="line">    <span class="number">16</span> * <span class="number">1024</span>，<span class="comment">//64MB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>lowmem_minfree 定义了可用内存容量对应的不同梯级。lowmem_adj 与 lowmem_minfree 中的梯级一一对应，表示处于某梯级时需要被处理的 adj 值。adj 值用来描述进程的优先级，取值范围为 -17~15，数字越小表示进程优先级越高，被杀死的概率越小。</p><p>比如当可用内存低于 64MB 时，即 lowmem_minfree 第 4 梯级，对应于 lowmem_adj 的 12，那就会清理掉优先级低于 12（即 adj&gt;12）的进程。</p><p>上面这两个数组中梯级的定义只是系统的预定义值，Android 系统还提供了相应的文件供我们修改这两组值，路径为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sys/module/lowmemorykiller/parameters/adj</span><br><span class="line">/sys/module/lowmemorykiller/parameters/minfree</span><br></pre></td></tr></table></figure><p>可以在 init.rc(系统启动时由 init 进程解析的一个脚本) 中，这样修改：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write /sys/module/lowmemorykiller/parameters/adj        <span class="number">0</span>, <span class="number">8</span></span><br><span class="line">write /sys/module/lowmemorykiller/parameters/minfree <span class="number">1024</span>, <span class="number">4096</span></span><br></pre></td></tr></table></figure></p><p>另外 ActivityManagerService 中有一个 updateOomLevels 方法也是通过修改这两个文件来实现的，AMS 在运行时会根据当前的系统配置自动调整 adj 和 minfree，以尽可能适配不同的硬件设备。 </p><p>了解了 Low Memory Killer 的梯级规则后，来看下 Android 进程的 adj 值含义：</p><table><thead><tr><th>ADJ</th><th>说明</th></tr></thead><tbody><tr><td>HIDDEN_APP_MAX_AD = 15</td><td>只运行了不可见 Activity 的进程</td></tr><tr><td>HIDDEN_APP_MIN_ADJ = 9</td><td>只运行了不可见 Activity 的进程</td></tr><tr><td>SERVICE_B_ADJ = 8</td><td>B list of Service</td></tr><tr><td>PREVIOUS_APP_ADJ = 7</td><td>用户的上一个产生交互的进程</td></tr><tr><td>HOME_APP_ADJ = 6</td><td>Launcher 进程</td></tr><tr><td>SERVICE_ADJ = 5</td><td>当前运行了 application service 的进程</td></tr><tr><td>BACKUP_APP_ADJ = 4</td><td>用于承载 backup 相关操作的进程</td></tr><tr><td>HEAVY_WEIGHT_APP_ADJ = 3</td><td>重量级应用程序进程</td></tr><tr><td>PERCEPTIBLE_APP_ADJ = 2</td><td>能被用户感觉但不可见，如后台运行的音乐播放器</td></tr><tr><td>VISIBLE_APP_ADJ = 1</td><td>有前台可见的 Activity</td></tr><tr><td>FOREGROUND_APP_ADJ = 0</td><td>当前正在前台运行与用户交互的进程</td></tr><tr><td>PERSISTENT_PROC_ADJ = -12</td><td>Persistent 性质的进程，如 telephony</td></tr><tr><td>SYSTEM_ADJ = -16</td><td>系统进程</td></tr></tbody></table><p>除了表格中系统的评定标准，有没有办法改变某一进程的 adj 值呢？和修改上面的 adj、minfree 梯级类似，进程的 adj 值也可以通过写文件的方式来修改，路径为 /proc/{PID}/oom_adj，比如 init.rc 中：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write /proc/<span class="number">1</span>/oom_adj <span class="number">-16</span></span><br></pre></td></tr></table></figure></p><p>另外还可以在 AndroidManifest.xml 中给 application 添加 “android:persistent=true” 属性。</p><h3 id="Ashmem-驱动"><a href="#Ashmem-驱动" class="headerlink" title="Ashmem 驱动"></a>Ashmem 驱动</h3><p>Anonymous Shared Memory 匿名共享内存是 Android 特有的内存共享机制，它可以将指定的物理内存分别映射到各个进程自己的虚拟地址空间中，从而便捷的实现进程间内存共享，Ashmem 的实现依赖 Ashmem 设备节点。</p><p>怎么理解设备节点呢？Linux 抽象了对硬件的处理，所有的硬件设备都可以当作普通文件一样来看待，设备节点文件是设备驱动的逻辑文件，其中对设备的描述包括文件操作函数集合，应用程序可以通过这些函数来访问硬件设备。</p><p>除了磁盘等真正的硬件设备，还可以通过内存抽象，使用设备节点文件的方式来描述一个”设备”并使用它，Ashmem、Binder 驱动都是属于这种内存抽象的”设备”。</p><p>介绍 Ashmem 设备节点前，先了解下 ueventd 进程。ueventd 就是 Android 中负责创建和管理设备节点的进程，创建设备节点文件有两种方式：<br><strong>1</strong>.静态节点文件：以预先定义的设备信息为基础，当 ueventd 进程启动后，统一创建设备节点文件<br><strong>2</strong>.动态节点文件：即在系统运行中，当有设备插入 USB 端口时，ueventd 进程就会接收到这一事件，为插入的设备动态创建设备节点文件</p><p>Ashmem 设备节点就属于静态节点文件，创建过程如下：<br><strong>1</strong>.Android 系统启动，解析 init.rc，启动 ueventd 进程<br><strong>2</strong>.ueventd 进程会去解析 ueventd.rc，读取 ashmem 设备节点信息到系统中</p><p>其中 ueventd.rc 文件格式如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/dev/null                 <span class="number">0666</span>   root       root</span><br><span class="line">/dev/zero                 <span class="number">0666</span>   root       root</span><br><span class="line">/dev/random               <span class="number">0666</span>   root       root</span><br><span class="line">/dev/ashmem               <span class="number">0666</span>   root       root</span><br><span class="line">/dev/binder               <span class="number">0666</span>   root       root</span><br></pre></td></tr></table></figure></p><p>可以看到包括 binder、ashmem 在内的一系列设备节点信息都会在这里读取到系统中。</p><p>随后 ashmem 会调用 ashmem.c 文件的 ashmem_init 进行初始化：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _init ashmem_init(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ashmem_area_cachep = kmem_cache_create(<span class="string">"ashmem_area_cache"</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ashmem_area),<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>); </span><br><span class="line">    ashmem_range_cachep = kmem_cache_create(<span class="string">"ashmem_range_cache"</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ashmem_range),<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    ret = misc_register(&amp;ashmem_misc);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 kmem_cache_create() 函数创建了两个 cache，后面申请内存时需要用到。对于 kmem_cache_create() 函数，书中提及 Slab、Slub、Slob 三种机制，这里不再延伸，仅理解： kmem_cache_create() 并没有真正的分配内存，后续还要调用 kmem_cache_alloc() 。</p><p>由于 ashmem 属于 misc 杂项设备，所以调用 misc_register(&amp;ashmem_misc) 进行设备注册。ashmem_misc 就是 Ashmem 的设备描述，定义如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice ashmem_misc = &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR, <span class="comment">//自动分配次设备号</span></span><br><span class="line">    .name = <span class="string">"ashmem"</span>, <span class="comment">//设备节点的名称</span></span><br><span class="line">    .fops = &amp;ashmem_fops, <span class="comment">//文件操作集合</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>.fops 就是上面提到的”文件操作函数集合”，即 Ashmem 设备的操作函数集，如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> file_operations ashmem_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = ashmem_open,</span><br><span class="line">    .release = ashmem_release,</span><br><span class="line">    .read = ashmem_read,</span><br><span class="line">    .llseek = ashmem_llseek,</span><br><span class="line">    .mmap = ashmem_mmap,</span><br><span class="line">    .unlocked_ioctl = ashmem_ioctl,</span><br><span class="line">    .compat_ioctl = ashmem_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中 ashmem_open、ashmem_mmap 及 ashmem_ioctl 函数比较重要，依次来看：</p><p><strong>1.ashmem_open</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)&#123;</span><br><span class="line">    <span class="keyword">struct</span> ashmem_area *asma;</span><br><span class="line">    ...</span><br><span class="line">    asma = kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL)；</span><br><span class="line">    ...</span><br><span class="line">    file-&gt;private_data = asma;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//申请成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ashmem_open 主要做了两个工作，1.调用 kmem_cache_zalloc 方法从 ashmem_area_cachep 分配了一块内存，这个方法和 cache 上面都提到过；2.将 ashmem_area 记录在 file 中 。</p><p><strong>2.ashmem_mmap</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_mmap(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)&#123;</span><br><span class="line">    <span class="keyword">struct</span> ashmem_area *asma = file-&gt;private_data;</span><br><span class="line">    ...</span><br><span class="line">    mutex_lock(&amp;ashmem_mutex);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!asma-&gt;file)&#123;</span><br><span class="line">        shmem_file_setup(name, asma-&gt;size, vma-&gt;vm_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    shmem_set_file(vma, asma-&gt;file);</span><br><span class="line">    ...</span><br><span class="line">    mutex_unlock(&amp;ashmem_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先拿到在 ashmem_open 函数中创建的 ashmem_area，然后判断如果 asma-&gt;file 为空，说明这是第一个访问该共享内存的进程，调用 shmem_file_setup() 函数在 tmpfs 中创建一个临时文件，用于进程间的内存共享；如果 asma-&gt;file 不为空，直接调用 shmem_set_file 进行内存映射。</p><p><strong>3.ashmem_ioctl</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> ashmem_ioctl(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)&#123;</span><br><span class="line">    <span class="keyword">struct</span> ashmem_area * asma = file-&gt;private_data;</span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">    <span class="keyword">case</span> ASHMEM_SET_NAME:<span class="comment">//设置名称</span></span><br><span class="line">    set_name(asma, (<span class="keyword">void</span> __user *) arg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ASHMEM_GET_NAME:<span class="comment">//获取名称</span></span><br><span class="line">    get_name(asma, (<span class="keyword">void</span> __user *) arg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ASHMEM_SET_NAME:<span class="comment">//设置大小</span></span><br><span class="line">    <span class="keyword">if</span>(!asma-&gt;file)&#123;</span><br><span class="line">        asma-&gt;size = (size_t) arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ashmem_ioctl 即根据 ioctl 命令做相应的操作，设置或获取 size、名称等。</p><h3 id="MemoryFile-原理"><a href="#MemoryFile-原理" class="headerlink" title="MemoryFile 原理"></a>MemoryFile 原理</h3><p>书中通过 MemoryDealer 讲解了 Ashmem 示例，触类旁通，我来分析一下 Ashmem 的另一个应用示例：MemoryFile。MemoryFile 是 Java 层对 Ashmem 的一个封装，使用方法大致如下：</p><p><strong>进程 A 中申请一块共享内存写入数据，并准备好文件描述符：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MemoryFile memoryFile = <span class="keyword">new</span> MemoryFile(name, size);</span><br><span class="line">memoryFile.getOutputStream().write(data);</span><br><span class="line">Method method = MemoryFile.class.getDeclaredMethod("getFileDescriptor");</span><br><span class="line">FileDescriptor des = (FileDescriptor) method.invoke(memoryFile);</span><br><span class="line">ParcelFileDescriptor pfd = ParcelFileDescriptor.dup(des);</span><br></pre></td></tr></table></figure></p><p><strong>进程 B 中通过 binder 拿到 A 进程中准备好的文件描述符，然后直接读取数据：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileDescriptor descriptor = pfd.getFileDescriptor();</span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(descriptor);</span><br><span class="line">fileInputStream.read(data);</span><br></pre></td></tr></table></figure></p><p>使用起来和文件读写一样很简单，如果不了解 Ashmem 机制，也就只能停留在仅会使用的浅显层面了。现在有了 Ashmem 驱动知识的铺垫，来看 MemoryFile 是怎么从 Java API 调用到 Ashmem 驱动函数的，先来看 MemoryFile 的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryFile</span><span class="params">(String name, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSharedMemory = SharedMemory.create(name, length);</span><br><span class="line">        mMapping = mSharedMemory.mapReadWrite();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        ex.rethrowAsIOException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到构造 MemoryFile 时通过 SharedMemory create 方法申请了一块匿名共享内存，SharedMemory create 方法中调用了 nCreate native 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> FileDescriptor <span class="title">nCreate</span><span class="params">(String name, <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> ErrnoException</span>;</span><br></pre></td></tr></table></figure></p><p>对应的 native 实现在 android_os_SharedMemory.cpp 中，源码见 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_os_SharedMemory.cpp" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_os_SharedMemory.cpp</a> ，具体 native 实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> jobject SharedMemory_create(JNIEnv* env, jobject, jstring jname, jint size) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = jname ? env-&gt;GetStringUTFChars(jname, nullptr) : nullptr;</span><br><span class="line">    <span class="keyword">int</span> fd = ashmem_create_region(name, size); <span class="comment">//创建匿名共享内存</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> jniCreateFileDescriptor(env, fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ashmem_create_region 方法的对应实现在 ashmem-dev.cpp 中，源码见 <a href="http://androidxref.com/9.0.0_r3/xref/system/core/libcutils/ashmem-dev.cpp#ashmem_create_region" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/system/core/libcutils/ashmem-dev.cpp#ashmem_create_region</a> ，其中 ashmem_create_region 的后续调用链如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASHMEM_DEVICE <span class="meta-string">"/dev/ashmem"</span> <span class="comment">//Ashmem 设备驱动</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ashmem_create_region(<span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size)&#123;</span><br><span class="line">    <span class="keyword">int</span> ret, save_errno;</span><br><span class="line">    <span class="keyword">int</span> fd = __ashmem_open(); <span class="comment">//创建匿名共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[ASHMEM_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        strlcpy(buf, name, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        ret = TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_SET_NAME, buf)); <span class="comment">//设置 Ashmem 名字</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __ashmem_open()&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;__ashmem_lock);</span><br><span class="line">    fd = __ashmem_open_locked(); <span class="comment">//创建匿名共享内存</span></span><br><span class="line">    pthread_mutex_unlock(&amp;__ashmem_lock);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __ashmem_open_locked()&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> stat st;</span><br><span class="line">    <span class="keyword">int</span> fd = TEMP_FAILURE_RETRY(open(ASHMEM_DEVICE, O_RDWR | O_CLOEXEC)); <span class="comment">//创建匿名共享内存</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直到 __ashmem_open_locked 方法中调用到 open(ASHMEM_DEVICE, O_RDWR | O_CLOEXEC) 方法，终于是到 Ashmem 设备驱动函数了，对应于上面的 <strong>ashmem_open</strong> 函数。另外 <strong>ashmem_ioctl</strong> 函数也被调用到了，即 ioctl(fd, ASHMEM_SET_NAME, buf)。</p><p>通过上面的分析知道 Ashmem 驱动的 ashmem_open 函数是由 SharedMemory 的 create 方法触发一步一步调用到的，那 ashmem_mmap 驱动函数是怎么被调用到的呢？看 MemoryFile 的构造方法，只可能是通过 SharedMemory 的 mapReadWrite 方法触发，下面来分析这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.os.SharedMemory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ByteBuffer <span class="title">mapReadWrite</span><span class="params">()</span> <span class="keyword">throws</span> ErrnoException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map(OsConstants.PROT_READ | OsConstants.PROT_WRITE, <span class="number">0</span>, mSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ByteBuffer <span class="title">map</span><span class="params">(<span class="keyword">int</span> prot, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> ErrnoException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> address = Os.mmap(<span class="number">0</span>, length, prot, OsConstants.MAP_SHARED, mFileDescriptor, offset);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(length, address, mFileDescriptor, unmapper, readOnly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的是 mFileDescriptor，它是执行 SharedMemory create 方法申请匿名共享内存后，返回的文件描述符。SharedMemory 中直接调用了系统的通用 mmap 函数，并没有对应的 native 实现，那它最终真的能调用到 ashmem_mmap 函数吗？ 继续来跟踪 mmap 调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.system.Os.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mmap</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> byteCount, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, FileDescriptor fd, <span class="keyword">long</span> offset)</span> <span class="keyword">throws</span> ErrnoException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Libcore.os.mmap(address, byteCount, prot, flags, fd, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//libcore.io.Libcore.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Libcore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Libcore</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Os rawOs = <span class="keyword">new</span> Linux();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Os os = <span class="keyword">new</span> BlockGuardOs(rawOs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//libcore.io.Linux.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">mmap</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> byteCount, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, FileDescriptor fd, <span class="keyword">long</span> offset)</span> <span class="keyword">throws</span> ErrnoException</span>;</span><br></pre></td></tr></table></figure></p><p>Libcore 中使用 BlockGuardOs 对 Linux 进行了一层包装，但实际还是通过 Linux 来执行的，最后调用到 Linux 中的 native mmap 方法，native 中对应的实现是 mmap.cpp，源码见 <a href="http://androidxref.com/9.0.0_r3/xref/bionic/libc/bionic/mmap.cpp#mmap" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/bionic/libc/bionic/mmap.cpp#mmap</a> ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* mmap(<span class="keyword">void</span>* addr, size_t size, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, off_t offset) &#123;</span><br><span class="line">    <span class="keyword">return</span> mmap64(addr, size, prot, flags, fd, static_cast&lt;off64_t&gt;(offset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此为止，由 SharedMemory 的 mapReadWrite 方法调用到 native mmap 函数，传递的关键参数是文件描述符，后续它将这样调用到 ashmem_mmap：<br><strong>1.</strong>通过 fd 可以找到所属设备，也就是 Ashmem 设备<br><strong>2.</strong>调用 Ashmem 设备的 ashmem_mmap 驱动函数</p><p>这属于 mmap 函数的内部实现，调用链比较复杂就不再具体展开，关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(file)&#123;</span><br><span class="line">    ...</span><br><span class="line">    error = file-&gt;f_op-&gt;mmap(file,vma);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>file 代表文件或设备驱动，这里指的就是 Ashmem 设备，f_op 就是 Ashmem 设备驱动函数集，也就是上文提过的通过 misc_register 注册的 Ashmem 设备描述，至此便是 ashmem_mmap 驱动函数的调用过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不知你是否会觉得本文介绍的虚拟内存无用，起初我有这样的想法，作者在原书中是这样描述的：本小节为读者完整地还原了操作系统虚拟地址的概念与转换原理，相信大家会在后续<strong> Android 各子系统的学习中受益匪浅</strong>。 这让我想到前几天看到的一个问题 “为什么要分析算法的时间复杂度和空间复杂度，是因为现在的计算机都是冯诺依曼结构吗？”，基于基础知识能有自己的理解和发散才是可贵的。</p><p>所以谦虚一点别自以为是，对知识保持敬畏、渴望。技术知识的价值不在于是否会被用到，而在于它能否对你的技术体系建设有帮助，能否让你对本质有更清晰的认知，能否让你的上层建筑更牢固。如果只盯着自己的那一点墨水坐井观天，实力没随年龄上涨，迟早会迎来焦虑的中年危机，被行业淘汰。</p><p>那本文涉及的知识点对上层建筑有什么帮助呢？比如学习了 Ashmem 后，再遇到跨进程传输大数据的问题，是不是更有底气了呢？比如学习了 Android 的 Low Memory Killer 机制原理后，才知道应用保活本质到底是在解决什么问题，相比只是知道从网上搜来的几个保活方案，是不是更加胸有成竹呢？比如在阅读本文涉及的源码时发现 mutex_lock 随处可见，是不是很庆幸自己掌握了本系列第一章中的 <strong>进程间同步机制</strong> 呢？</p><blockquote><p>链接：<a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzA5OTAxNDEyNg==&amp;hid=1&amp;sn=ebe1c61ff758e51e9e92fd907a99f342&amp;scene=18#wechat_redirect" target="_blank" rel="noopener">细读《深入理解 Android 内核设计思想》系列</a></p></blockquote><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://yhaowa.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>细读《深入理解 Android 内核设计思想》（一）进程间通信与同步机制</title>
    <link href="http://yhaowa.gitee.io/12a8b16b/"/>
    <id>http://yhaowa.gitee.io/12a8b16b/</id>
    <published>2020-03-31T16:50:13.000Z</published>
    <updated>2020-04-11T15:04:47.666Z</updated>
    
    <content type="html"><![CDATA[<p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em><br><a id="more"></a></p><blockquote><ol><li>进程间通信的经典实现<ol><li>共享内存</li><li>管道</li><li>UNIX Domain Socket</li><li>Remote Procedure Calls</li></ol></li><li>同步机制的经典实现<ol><li>信号量</li><li>Mutex</li><li>管程</li><li>Linux Futex</li></ol></li><li>Android 中的进程间同步机制<ol><li>进程间同步 Mutex</li><li>条件判断 Condition</li><li>加解锁的自动化操作 Autolock</li><li>Mutex+Autolock+Condition 示例</li></ol></li><li>最后</li></ol></blockquote><h2 id="进程间通信的经典实现"><a href="#进程间通信的经典实现" class="headerlink" title="进程间通信的经典实现"></a>进程间通信的经典实现</h2><p>进程间通信（Inter-process communication，IPC）指运行在不同进程中的若干线程间的数据交换，可发生在同一台机器上，也可通过网络跨机器实现，以下几种因高效稳定的优点几乎被应用在所有操作系统中，分别是共享内存、管道、UNIX Domain Socket 和 RPC 。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是一种常用的进程间通信机制，不同进程可以直接共享访问同一块内存区域，避免了数据拷贝，速度较快。实现步骤：</p><ol><li><p>创建内存共享区<br>Linux 通过 shmget 方法创建与特定 key 关联的共享内存块：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回共享内存块的唯一 Id 标识</span></span><br><span class="line"><span class="keyword">int</span> shmget(key_t key, size_t size, <span class="keyword">int</span> shmflg);</span><br></pre></td></tr></table></figure></li><li><p>映射内存共享区<br>Linux 通过 shmat 方法将某内存块与当前进程某内存地址映射</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功返回指向共享存储段的指针　</span></span><br><span class="line"><span class="keyword">void</span> *shmat(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg);</span><br></pre></td></tr></table></figure></li><li><p>访问内存共享区<br>其他进程要访问一个已存在的内存共享区的话，可以通过 key 调用 shmget 获取到共享内存块 Id，然后调用 shmat 方法映射</p></li><li>进程间通信<br>当两个进程都实现对同一块内存共享区做映射后，就可以利用此内存共享区进行数据交换，但要自己实现同步机制</li><li><p>撤销内存映射<br>进程间通信结束后，各个进程需要撤销之前的映射，Linux 可以调用 shmdt 方法撤销映射：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功则返回 0，否则出错</span></span><br><span class="line"><span class="keyword">int</span> shmdt(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr);</span><br></pre></td></tr></table></figure></li><li><p>删除内存共享区<br>最后需要删除内存共享区，以便回收内存，Linux 可以调用 shctl 进行删除：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功则返回 0，否则出错，删除操作 cmd 需传 IPC_RMID</span></span><br><span class="line"><span class="keyword">int</span> shmctl(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf);</span><br></pre></td></tr></table></figure></li></ol><p>shmget 方法名言简意赅，share memory get ！其中 get 还有一层含义，为什么不叫 create 呢？之前如果创建过某一 key 的共享内存块，再次调用便直接返回该内存块，不会发生创建操作了。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道（Pipe）是操作系统中常见的一种进程间通信方式，一根管道有”读取”和”写入”两端，读、写操作和普通文件操作类似，并且是单向的。管道有容量限制，当写满时，写操作会被阻塞；为空时读操作会被阻塞。</p><p>Linux 通过 pipe 方法打开一个管道：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pipe_fd[0] 代表读端，pipe_fd[1] 代表写端，</span></span><br><span class="line"><span class="keyword">int</span> pipe(<span class="keyword">int</span> pipe_fd[<span class="number">2</span>], <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure></p><p>以上方式只能用于父子进程，因为只有一个进程中定义的 pipe_fd 文件描述符只有通过 fork 方式才能传给另一个进程继承获取到，也正是因为这个限制，Named Pipe 得以发展，改变了前者匿名管道的方式，可以在没有任何关系的两个进程间使用。</p><h3 id="UNIX-Domain-Socket"><a href="#UNIX-Domain-Socket" class="headerlink" title="UNIX Domain Socket"></a>UNIX Domain Socket</h3><p>UNIX Domain Socket（UDS）是专门针对单机内的进程间通信，也称 IPC Socket，与 Network Socket 使用方法基本一致，但实现原理区别很大：</p><ul><li>Network Socket 基于 TCP/IP 协议，通过 IP 地址或端口号进行跨进程通信</li><li>UDS 基于本机 socket 文件，不需要经过网络协议栈，不需要打包拆包、计算校验等</li></ul><p>Android 中使用最多的 IPC 是 Binder，其次就是 UDS。</p><h3 id="Remote-Procedure-Calls"><a href="#Remote-Procedure-Calls" class="headerlink" title="Remote Procedure Calls"></a>Remote Procedure Calls</h3><p>RPC 即远程过程调用（Remote Procedure Call），RPC 是指计算机 A 上的进程，调用另外一台计算机 B 上的进程，其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行，当值返回给 A 时，A 进程继续执行。调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。</p><p>Java RMI 就是一种 RPC 框架，指的是远程方法调用 (Remote Method Invocation)。它能够让一个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象的方法。</p><p>RPC 可以理解为一种编程模型，就像 IPC 一样，比如我们常说 Android AIDL 是一种 IPC 实现方式，也可以称为一种 RPC 方式。</p><h2 id="同步机制的经典实现"><a href="#同步机制的经典实现" class="headerlink" title="同步机制的经典实现"></a>同步机制的经典实现</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量与 PV 原语操作是一种广泛使用的实现进程/线程互斥与同步的有效方法，Semaphore S 信号量用于指示共享资源的可用数量。<br><strong>P 操作：</strong></p><ol><li>S = S - 1</li><li>然后判断若 S 大于等于 0，代表共享资源允许访问，进程继续执行</li><li>若 S 小于 0，代表共享资源被占用，需等待别人主动释放资源，该进程阻塞放入等待该信号量的队列中，等待被唤醒</li></ol><p><strong>V 操作：</strong></p><ol><li>S = S + 1</li><li>然后判断若 S 大于 0，代表没有正在等待访问该资源的进程，无需处理</li><li>若 S 小于等于 0，从该信号的等待队列中唤醒一个进程</li></ol><p>Java 中的信号量的实现类为 Semaphore，P、V 操作分别对应 acquire、release 方法。</p><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Mutex 即互斥锁，可以和信号量对比来理解，信号量可以使资源同时被多个线程访问，而互斥锁同时只能被一个线程访问，也就是说，互斥锁相当于一个只允许取值 0 或 1 的信号量。</p><p>Java 中 ReentrantLock 就是互斥锁的一种实现。</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>采用 Semaphore 机制的程序中 P、V 操作大量分散在程序中，代码易读性差，不易管理，容易发生死锁，所以引入了管程 Monitor。</p><p>管程把分散在各进程中的临界区集中起来进行管理，防止进程有意或无意的违法同步操作，便于用高级语言来书写程序，也便于程序正确性验证。</p><p>管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。</p><p>Java 中 synchronized 同步代码块就是 Monitor 的一种实现。</p><h3 id="Linux-Futex"><a href="#Linux-Futex" class="headerlink" title="Linux Futex"></a>Linux Futex</h3><p>Futex 全称 Fast Userspace muTexes，直译为<strong>快速用户空间互斥体</strong>，那他比普通的 Mutex 快在哪里呢？</p><p>Semaphore 等传统同步机制需要从用户态进入到内核态，通过一个提供了共享状态信息和原子操作的内核对象来完成同步。但大多数场景同步是无竞争的，不需要进入互斥区等待就可以直接获取到锁，但依然进行了内核态的切换操作，这造成了大量的性能开销。</p><p>Futex 通过 mmap 让进程间共享一段内存，当进程尝试进入互斥区或退出互斥区的时候，先查看共享内存中的 Futex 变量，如果没有竞争发生，则只修改 Futex 变量而不执行系统调用切换内核态。</p><p>Futex 的 Fast 就体现在对于大多数不存在竞争的情况，可以在用户态就完成锁的获取，而不需要进入内核态，从而提高了效率。</p><p>如果说 Semaphore 等传统同步机制是一种内核态同步机制，那 Futex 就是一种用户态和内核态混合的同步机制。</p><p>Futex 在 Android 中的一个重要应用场景是 ART 虚拟机，如果 Android 版本开启了 ART_USE_FUTEXES 宏，那 ART 虚拟机中的同步机制就会以 Futex 为基石来实现，省略后的关键代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art/runtime/base/mutex.cc</span></span><br><span class="line"><span class="keyword">void</span> Mutex::ExclusiveLock(Thread* <span class="keyword">self</span>)&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> ART_USE_FUTEXES</span></span><br><span class="line">        <span class="comment">//若开启 Futex 宏就通过 Futex 实现互斥加锁</span></span><br><span class="line">        futex(...) </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">//否则通过传统 pthread 实现</span></span><br><span class="line">        CHECK_MUTEX_CALL(pthread_mutex_lock,(&amp;mutex_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码见 <a href="http://androidxref.com/7.0.0_r1/xref/art/runtime/base/mutex.cc" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/art/runtime/base/mutex.cc</a></p><h2 id="Android-中的进程间同步机制"><a href="#Android-中的进程间同步机制" class="headerlink" title="Android 中的进程间同步机制"></a>Android 中的进程间同步机制</h2><p>了解了操作系统经典的同步机制后，再来看 Android 中是怎么实现的。</p><h3 id="进程间同步-Mutex"><a href="#进程间同步-Mutex" class="headerlink" title="进程间同步 Mutex"></a>进程间同步 Mutex</h3><p>Mutex 实现类源码很短，见 <a href="http://androidxref.com/7.0.0_r1/xref/system/core/include/utils/Mutex.h" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/system/core/include/utils/Mutex.h</a></p><p>注意这里说的 Mutex 和上面的 mutex.cc 是两个东西，mutex.cc 是 ART 中的实现类，支持 Futex 方式； 而 Mutex.h 只是对 pthread 的 API 进行了简单封装，函数声明和实现都在 Mutex.h 一个文件中。</p><p>源码中可以看到一个枚举类型定义：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Mutex &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        PRIVATE = <span class="number">0</span>,</span><br><span class="line">        SHARED = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>其中 PRIVATE 代表进程内同步，SHARED 代表进程间同步。Mutex 相比 Semaphore 较简单，只有 0 和 1 两种状态，关键方法为：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> status_t Mutex::lock() &#123;<span class="comment">//获取资源锁，可能阻塞等待</span></span><br><span class="line">    <span class="keyword">return</span> -pthread_mutex_lock(&amp;mMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Mutex::unlock() &#123;<span class="comment">//释放资源锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> status_t Mutex::tryLock() &#123;<span class="comment">//获取资源锁，不论成功与否都立即返回</span></span><br><span class="line">    <span class="keyword">return</span> -pthread_mutex_trylock(&amp;mMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当要访问临界资源时，需先通过 lock() 获得资源锁，如果资源可用会此函数会立即返回，否则阻塞等待，直到其他进程(线程)调用 unlock() 释放了资源锁从而被唤醒。</p><p>tryLock() 函数存在有什么意义呢？它在资源被占用的情况下，不会像 lock() 一样进入等待，而是立即返回，所以可以用来试探性查询资源锁是否被占用。</p><h3 id="加解锁的自动化操作-Autolock"><a href="#加解锁的自动化操作-Autolock" class="headerlink" title="加解锁的自动化操作 Autolock"></a>加解锁的自动化操作 Autolock</h3><p>Autolock 为 Mutex.h 中的一个嵌套类，实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manages the mutex automatically. It'll be locked when Autolock is</span></span><br><span class="line"><span class="comment">// constructed and released when Autolock goes out of scope.</span></span><br><span class="line"><span class="keyword">class</span> Autolock &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">inline</span> Autolock(Mutex&amp; mutex) : mLock(mutex)  &#123; mLock.lock(); &#125;</span><br><span class="line">    <span class="keyword">inline</span> Autolock(Mutex* mutex) : mLock(*mutex) &#123; mLock.lock(); &#125;</span><br><span class="line">    <span class="keyword">inline</span> ~Autolock() &#123; mLock.unlock(); &#125;</span><br><span class="line">private:</span><br><span class="line">    Mutex&amp; mLock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如注释所示，Autolock 会在构造时主动去获取锁，在析构时会自动释放掉锁，也就是说，在生命周期结束时会自动把资源锁释放掉。</p><p>这就可以在一个方法开始时为某 Mutex 构造一个 Autolock，当方法执行完后此锁会自动释放，无需再主动调用 unlock，这让 lock/unlock 的配套使用更加简便，不易出错，</p><h3 id="条件判断-Condition"><a href="#条件判断-Condition" class="headerlink" title="条件判断 Condition"></a>条件判断 Condition</h3><p>条件判断的核心思想是判断某 “条件” 是否满足，满足的话马上返回，否则阻塞等待，直到条件满足时被唤醒。</p><p>你可能会疑问，Mutex 不就可以实现吗，干嘛又来一个 Condition，它有什么特别之处？</p><p>Mutex 确实可以实现基于条件判断的同步，假如条件是 a 为 0，实现代码会是这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  acquire_mutex_lock(a); <span class="comment">//获取 a 的互斥锁</span></span><br><span class="line">  <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">    release_mutex_lock(a); <span class="comment">//释放锁</span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//条件满足，退出死循环</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    release_mutex_lock(a); <span class="comment">//释放锁</span></span><br><span class="line">    sleep()；<span class="comment">//休眠一段时间后继续循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>什么时候满足 a==0 是未知的，可能是很久之后，但上面方式无限循环去判断条件，极大浪费 CPU。</p><p>而条件判断不需要死循环，可以在满足条件时才去通知唤醒等待者。</p><p>Condition 源码见 <a href="http://androidxref.com/7.0.0_r1/xref/system/core/include/utils/Condition.h" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/system/core/include/utils/Condition.h</a> ，它和 Mutex 一样也有 PRIVATE、SHARED 类型，PRIVATE 代表进程内同步，SHARED 为进程间同步。关键方法为：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某个条件上等待</span></span><br><span class="line">status_t wait(Mutex&amp; mutex)</span><br><span class="line"><span class="comment">//在某个条件上等待，增加超时机制</span></span><br><span class="line">status_t waitRelative(Mutex&amp; mutex, nsecs_t reltime)</span><br><span class="line"><span class="comment">//条件满足时通知相应等待者</span></span><br><span class="line"><span class="keyword">void</span> signal()</span><br><span class="line"><span class="comment">//条件满足时通知所有等待者</span></span><br><span class="line"><span class="keyword">void</span> broadcast()</span><br></pre></td></tr></table></figure></p><h3 id="Mutex-Autolock-Condition-示例"><a href="#Mutex-Autolock-Condition-示例" class="headerlink" title="Mutex+Autolock+Condition 示例"></a>Mutex+Autolock+Condition 示例</h3><p>书中通过 Barrier 呈现 Condition 使用示例，还有一个我们更为熟知的 LinkedBlockingQueue 也很适合，源码见 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/av/media/libstagefright/webm/LinkedBlockingQueue.h。" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/frameworks/av/media/libstagefright/webm/LinkedBlockingQueue.h。</a></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedBlockingQueue &#123;</span><br><span class="line">    List&lt;T&gt; mList;</span><br><span class="line">    Mutex mLock;</span><br><span class="line">    Condition mContentAvailableCondition;</span><br><span class="line"></span><br><span class="line">    T front(<span class="keyword">bool</span> remove) &#123;</span><br><span class="line">        Mutex::Autolock autolock(mLock);</span><br><span class="line">        <span class="keyword">while</span> (mList.empty()) &#123;</span><br><span class="line">            mContentAvailableCondition.wait(mLock);</span><br><span class="line">        &#125;</span><br><span class="line">        T e = *(mList.begin());</span><br><span class="line">        <span class="keyword">if</span> (remove) &#123;</span><br><span class="line">            mList.erase(mList.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> push(T e) &#123;</span><br><span class="line">        Mutex::Autolock autolock(mLock);</span><br><span class="line">        mList.push_back(e);</span><br><span class="line">        mContentAvailableCondition.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 front 方法出队元素时，首先获取 mLock 锁，然后判断若列表为空就调用 wait 方法进入等待状态，待 push 方法入队元素后通过 signal 方法唤醒。</p><p>front 方法占有了 mLock 锁，push 方法不应该阻塞在第一行代码无法往下执行吗？</p><p>很简单，wait 方法中释放了 mLock 锁，见 pthread_cond.cpp：<a href="http://androidxref.com/7.0.0_r1/xref/bionic/libc/bionic/pthread_cond.cpp#173" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/bionic/libc/bionic/pthread_cond.cpp#173</a></p><p>可以不依赖 Mutex 仅通过 Condition 的 wait/signal 实现吗？</p><p>不行，因为对 mList 的访问需要加互斥锁，否则可能出现 signal 无效的情况。比如 A 进程调用 front ，判断 mList 为空，即将执行 wait 方法时，B 进程调用 push 方法并执行完，那么 A 进程将得不到唤醒，尽管此队列中有元素。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>书中说到：不论什么样的操作系统，其技术本质都类似，而更多的是把这些核心的理论应用到符合自己需求的场景中。</p><p>不知道在讲这句话时，作者脑中一闪而过的，是怎样庞大而深厚的技术栈。</p><blockquote><p>链接：<a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzA5OTAxNDEyNg==&amp;hid=1&amp;sn=ebe1c61ff758e51e9e92fd907a99f342&amp;scene=18#wechat_redirect" target="_blank" rel="noopener">细读《深入理解 Android 内核设计思想》系列</a></p></blockquote><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://yhaowa.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>焦虑与知识输出</title>
    <link href="http://yhaowa.gitee.io/af0c2fe0/"/>
    <id>http://yhaowa.gitee.io/af0c2fe0/</id>
    <published>2020-03-29T09:06:33.000Z</published>
    <updated>2020-04-07T15:34:42.769Z</updated>
    
    <content type="html"><![CDATA[<p>今年很重要，对于工作年限将迈过两年、步入三年的程序员、我。</p><a id="more"></a><p>程序员岗位往往会以 3 年为分界点，一个任务你无法解决或不尽人意：</p><p>“他刚毕业两年，经验不太足，没关系”</p><p>“他都毕业三年多了，怎么跟刚毕业的一样，这都不懂，好菜啊”</p><p>这份焦虑从去年开始，伴随了我很久，直到现在，准确说是在本周它消失了。</p><p>它是什么时候来的呢？</p><p>去年身边的几个同事都成功进入心仪大厂而我却碰壁的时候，我是一个要强的人，认识到某方面不如别人会刺痛我，尤其是对程序员来说最重要的技术饭碗，那时候每当空下来的时候，就会意识我比别人菜的事实仍然是事实，焦虑不仅是焦虑，而是折磨。</p><p>大多数程序员都是很自信的，技术好的知道自己比别人懂得多，自然而然自信；技术差的不知道比别人懂得少，还是很自信。虽然我说出 “比别人菜的事实” 这种话，但我心底并不认同这是事实，不觉得我比同龄人差。</p><p>为什么会碰壁呢？</p><p>认清原因之前，尽管内心深处还是不认同 “比别人菜的事实”，但一直处于低谷找不到出口。逐渐开始怀疑我的不认同是错误的执念，为什么努力不比别人少，但是比别人菜，为什么呢？智商问题吗？ 不能再想下去，no! 智商问题就没救了！ 一定不是智商问题，一定不是智商问题！一定是因为不够努力，我这样告诉自己。</p><p><img src="../img/weixin.png" alt></p><p>复盘之后，终于找到了原因：我那业余而薄弱的音视频、JNI 技能点。我确实也花了时间在这上面，定制编译 FFmpeg、集成 mp3/h264 编码，实现变声、视频编辑等功能，但事实上这些东西毫无用处，还给我减了不少分。</p><p>我本想作为加分项，却减了分，为什么呢？</p><p>过多时间准备这个技能，却几乎没有问到，浪费时间浪费精力，从而其他准备不够充分，其实远不如学习其他技能点的收益高。</p><p>一旦被问到，便不会是业余浅显的问题，但我只是业余级别的了解，没在工作中实践，没有系统的认知，专业深入的问题回答上不来。</p><p>知道原因之后，雨过天晴，一切都释然了，我重新相信只要持续不断的付出、输入知识，我就没什么可怕的，但现在的状态还不够，远远不够，这份焦虑还在，最怕的是间歇性努力，持续性堕落。</p><p>解决焦虑的根本是认清自己的目标，并实施靠谱的计划不断向目标接近。之前目标只有一个模糊的样子，慢慢的，我的目标清晰起来，原来很简单。现在的待遇、心仪的大厂、当前的状况，这些都不是，也都不重要，都只是附属品而已，真正重要的东西从来都只有一个：技术实力。 稍长远点看就能明白，决定 3、5 年之后能否处于我理想状况的是技术实力；10 年之后呢？ 还是； 15 年之后呢？可能不再是直接原因，但绝对是主要的影响因素。</p><p>在三月份开始了学习计划，安排了学习内容并规划投入时间：</p><p>32.5h/周<br>工作日    21.30-24.00（2.5x5=12.5h）<br>周末    13.00-23.00（10x2=20h）</p><p>起初，写出来就笑了，间歇性努力的典型，坚持一周恐怕都难，万万没想到我竟快坚持过 3 月份了，并慢慢产生了一些惯性，甚至不再需要”坚持”这样的字眼，而仅是”日常”而已，这是一个好兆头。</p><p>期间就是大量的知识不断的输入，输入，当我越来越多的需要对一个知识点反复时，我意识到，是输入过多了，而学习留存最高的方式就是消化理解整理输出，所以我利用博客、公众号输出。</p><p>学生时代的输出就是课后练习、应试；程序员的输出就是应用、写博客、教学。知识的输入和输出需要找到一个平衡点，输入输出过多或过少都会影响学习效率。</p><p>常会看到鼓励程序员写博客的话：以输出的成就感为由，倒逼输入。这是我写博客的初衷，也是我一直以来笃信的。但现在发现这种方式是有问题的，首先它假定了人是处于堕落、懒散状态的，尽管它更符合人的本性，但它绝不是最大化学习效率的方式。</p><p>试想一下，如果老师不系统的讲授课本知识，而是直接给你练习题册去做，是不是不太合理？回想我的博客，就存在这样的问题，从而导致一个知识点的学习周期很长。</p><p>所以对于博客、公众号这样的输出方式，限死周更或月更都是不合理的，它应该结合你的输入状况寻找一个平衡点。当然前提是没有处于一个零输入的堕落状态，否则输出倒逼输入肯定是有利无弊的。</p><p>谨此深化当前状态。</p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年很重要，对于工作年限将迈过两年、步入三年的程序员、我。&lt;/p&gt;
    
    </summary>
    
      <category term="思考" scheme="http://yhaowa.gitee.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="输出倒逼输入" scheme="http://yhaowa.gitee.io/tags/%E8%BE%93%E5%87%BA%E5%80%92%E9%80%BC%E8%BE%93%E5%85%A5/"/>
    
      <category term="焦虑" scheme="http://yhaowa.gitee.io/tags/%E7%84%A6%E8%99%91/"/>
    
  </entry>
  
  <entry>
    <title>Framework &amp; startActivity</title>
    <link href="http://yhaowa.gitee.io/a608ff50/"/>
    <id>http://yhaowa.gitee.io/a608ff50/</id>
    <published>2019-09-15T11:42:33.000Z</published>
    <updated>2020-04-07T15:34:42.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>源码基于 <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:" target="_blank" rel="noopener">Android 10</a></p></blockquote><a id="more"></a><p><img src="../img/startActivity-Android10.jpg" alt="Android 10.0 startActivity 流程图"><br><a href="../img/startActivity-Android10.jpg">大图</a></p><p>此图着重提炼了生命周期的部分，Android 10 中 新增了 ActivityTaskManager ，专门用于管理 Activity，接替了 ActivityManager 的一部分工作</p><h3 id="理解-Instrumentation"><a href="#理解-Instrumentation" class="headerlink" title="理解 Instrumentation"></a>理解 Instrumentation</h3><p>Activity 首先会通过 Instrumentation 去调用，Instrumentation 中包含 callActivityOnCreate、callActivityOnPause、callApplicationOnCreate 等调用，具有强大的跟踪 Activity 及 Application 生命周期的功能，所以也被作为应用测试框架中的基类使用。一个进程有一个 ActivityThread 对象，ActivityThread 对象持有一个 Instrumentation 对象，每个 Activity 都持有 Instrumentation</p><h3 id="IPC-发生在何处？"><a href="#IPC-发生在何处？" class="headerlink" title="IPC 发生在何处？"></a>IPC 发生在何处？</h3><p>在 Instrumentation 中通过 IActivityTaskManager.aidl 接口由 App 进程进入到 system_server 进程；在 ClientTransaction 中通过 IApplicationThread.aidl 接口由 system_server 回到 App 进程</p><h3 id="Activity-栈是如何管理的？"><a href="#Activity-栈是如何管理的？" class="headerlink" title="Activity 栈是如何管理的？"></a>Activity 栈是如何管理的？</h3><p>ActivityRecord：Activity 以 ActivityRecord 形式记录，一个 ActivityRecord 对应一个 Activity 实例<br>TaskRecord：这个才是一个真正的 Activity 栈，内部持有 ArrayList&lt; ActivityRecord &gt;，记录当前栈中所有的 Activity<br>ActivityStack：负责管理 Activity 栈，存放了多个 TaskRecord</p><h3 id="何处读取-manifest-中-Activity-节点的启动模式等配置"><a href="#何处读取-manifest-中-Activity-节点的启动模式等配置" class="headerlink" title="何处读取 manifest 中 Activity 节点的启动模式等配置"></a>何处读取 manifest 中 Activity 节点的启动模式等配置</h3><p><img src="../img/startActivity-Android10-2.jpg" alt="读取 manifest 配置图"></p><p>如图通过 PackageManagerService#resolveIntentInternal 方法返回 ResolveInfo ，ResolveInfo 包括 ActivityInfo、ServiceInfo、ProviderInfo 等信息，此调用已经处于 system_server 进程了，所以并不是 IPC，PackageManagerService 主要负责解析 AndroidManifest.xml、扫描本地 apk 目录、管理 App 安装删除等</p><h3 id="何处检测-Activity-是否在-manifest-注册？"><a href="#何处检测-Activity-是否在-manifest-注册？" class="headerlink" title="何处检测 Activity 是否在 manifest 注册？"></a>何处检测 Activity 是否在 manifest 注册？</h3><p>关键代码在 ActivityStarter#startActivity 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">    <span class="comment">// Also the end of the line.</span></span><br><span class="line">    err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>aInfo 就是 ActivityInfo ，而 ActivityInfo 为空导致后续报错返回。那 aInfo 是从哪来的呢？当然就是通过 PackageManagerService#resolveIntentInternal 方法解析出来的。然后在 Instrumentation#checkStartActivityResult 方法中检测到 ActivityManager.START_CLASS_NOT_FOUND 返回值后，就抛出 “Unable to find explicit activity class {xxx}; have you declared this activity in your AndroidManifest.xml? “异常了 </p><h3 id="为什么单独配置-taskAffinity-不会生效"><a href="#为什么单独配置-taskAffinity-不会生效" class="headerlink" title="为什么单独配置 taskAffinity 不会生效"></a>为什么单独配置 taskAffinity 不会生效</h3><p>关键代码在 ActivityStarter#startActivityUnchecked 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mStartActivity.resultTo == <span class="keyword">null</span> &amp;&amp; mInTask == <span class="keyword">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">              &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">       newTask = <span class="keyword">true</span>;</span><br><span class="line">       result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">       result = setTaskFromSourceRecord();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">       result = setTaskFromInTask();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       result = setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只有 mLaunchFlags 标记为 FLAG_ACTIVITY_NEW_TASK 才会去创建一个新的 Activity 栈即 TaskRecord，而系统并没有对单独配置一个 taskAffinity 的情况做处理。那在 AndroidManifest.xml 中配置的 launchMode 是在何处处理，并反应到 mLaunchFlags 中的呢？<br>ActivityStarter#startActivityUnchecked 方法中调用了 ActivityStarter#computeLaunchingTaskFlags 方法，该方法中配置 mLaunchFlags 的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span> &amp;&amp; mInTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Slog.w(TAG, <span class="string">"startActivity called from non-Activity context; forcing "</span> +</span><br><span class="line">                     <span class="string">"Intent.FLAG_ACTIVITY_NEW_TASK for: "</span> + mIntent);</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 LAUNCH_SINGLE_INSTANCE 模式会在一个新的栈中启动等我们早已熟知的规则</p><h3 id="理解-ClientTransactionItem-与-ActivityLifecycleItem"><a href="#理解-ClientTransactionItem-与-ActivityLifecycleItem" class="headerlink" title="理解 ClientTransactionItem 与 ActivityLifecycleItem"></a>理解 ClientTransactionItem 与 ActivityLifecycleItem</h3><p>ClientLifecycleManager 可以将一或多个生命周期事件组合到一起作为一个事务即 ClientTransaction 来执行，startActivity 时新 Activity 的 onCreate、onStart、onResume 事件就是存放在一个事务中被执行的</p><p>startActivity 时新 Activity 的 onCreate 事件存放在 ClientTransaction 的 List &lt; ClientTransactionItem &gt; 类型的成员变量中，载体为 LaunchActivityItem。 LaunchActivityItem 也是 ClientTransactionItem 的子类，即启动 Activity 事件。另外还有 NewIntentItem（触发 onNewIntent 回调）、ActivityResultItem（触发 onActivityResult）、ConfigurationChangeItem（触发 onConfigurationChanged 回调）等事件</p><p>startActivity 时新 Activity 的 onResume 事件存放在 ClientTransaction 的 ActivityLifecycleItem 类型的变量成员变量中，这个变量也表示最终的生命周期状态，载体为 ResumeActivityItem。ActivityLifecycleItem 也是 ClientTransactionItem 的一个子类</p><h3 id="为什么不能在-Activity-的-onPause-方法中做耗时操作？"><a href="#为什么不能在-Activity-的-onPause-方法中做耗时操作？" class="headerlink" title="为什么不能在 Activity 的 onPause 方法中做耗时操作？"></a>为什么不能在 Activity 的 onPause 方法中做耗时操作？</h3><p>ClientTransaction 为 Parcelable 数据，会通过 IApplicationThread.aidl 的 scheduleTransaction 方法发送到 App 端，然后加入到主线程 ActivityThread.H 消息队列中等待执行。startActivity 时会依次发送前一个 Activity 的 pause 和新 Activity 的 resume 事务，然后这两个事务会通过 ActivityThread.H 依次执行，所以不能在 Activity 的 onPause 方法中做耗时操作，因为只有 onPause 方法执行完后，下一个 Activity 的生命周期事件才能被执行，否则会阻塞新界面显示</p><h3 id="activity-实例在何处创建？"><a href="#activity-实例在何处创建？" class="headerlink" title="activity 实例在何处创建？"></a>activity 实例在何处创建？</h3><p>在 ActivityThread#performLaunchActivity 方法中，会通过 Instrumentation#newActivity 方法创建 Activity 的实例对象，随后就调用了 Instrumentation#callActivityOnCreate 方法回调 Activity 的 onCreate 方法</p><h3 id="Launcher-中点击图标启动-App"><a href="#Launcher-中点击图标启动-App" class="headerlink" title="Launcher 中点击图标启动 App"></a>Launcher 中点击图标启动 App</h3><p>Launcher 中点击图标启动同样是调用 startActivity 方法，但需要创建进程，关键代码在 ActivityStackSupervisor#startSpecificActivityLocked 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowProcessController wpc =</span><br><span class="line">        mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"><span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">     <span class="comment">//判断进程存在，继续启动</span></span><br><span class="line">     realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程不存在，创建进程</span></span><br><span class="line"><span class="keyword">final</span> Message msg = PooledLambda.obtainMessage(</span><br><span class="line">        ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,</span><br><span class="line">        r.info.applicationInfo, knownToBeDead, <span class="string">"activity"</span>, r.intent.getComponent());</span><br><span class="line">mService.mH.sendMessage(msg);</span><br></pre></td></tr></table></figure><p><img src="../img/startActivity-Android10-3.jpg" alt="startProcess 流程图"></p><p>与 zygote 进程通信采取了 Socket 方式，为什么不使用更安全、数据只需拷贝一次的 binder 呢？zygote 作为 Android 的受精卵进程，通过 fork 方法创建进程，而 fork 是不允许多线程的，否则会因为 Copy-on-Write 机制导致死锁，而 binder 正是基于多线程运行的</p><p>在 ProcessList#startProcessLocked 方法中，传入了值为 “android.app.ActivityThread” 的 entryPoint 参数，后续会透传给 zygote 进程，zygote fork 新进程成功后，新进程的 ActivityThread#main 函数会被调用，即 App 真正的启动入口</p><p><img src="../img/startActivity-Android10-4.jpg" alt="ActivityThread.main 流程图"><br><a href="../img/startActivity-Android10-4.jpg">大图</a></p><p>在 ActivityManagerService#attachApplicationLocked 方法中执行了两个关键逻辑，一是通过 IApplicationThread 回到 App 进程中创建 Application 实例并回调 onCreate 方法；二是调用 ActivityTaskManagerService#attachApplication 方法，进一步去启动首页 Activity 。<br>启动 Activity 和普通的 startActivity 一样，都会调用到 ActivityStackSupervisor#realStartActivityLocked 方法</p><h3 id="理解-ActivityThread-与-ApplicationThread"><a href="#理解-ActivityThread-与-ApplicationThread" class="headerlink" title="理解 ActivityThread 与 ApplicationThread"></a>理解 ActivityThread 与 ApplicationThread</h3><p>ActivityThread.main() 方法是程序的启动入口，初始化了主线程 Looper，在 ActivityThread.H 中处理消息。ApplicationThread 是 ActivityThread 的内部类，实现了 IApplicationThread.aidl 接口以接受 AMS 等系统服务的回调，而大多数都是四大组件相关的任务，所以发送 Handler 消息到 ActivityThread.H ，即从 binder 线程切换到主线程中处理</p><h3 id="如何启动一个未在-manifest-中注册的-Activity-？"><a href="#如何启动一个未在-manifest-中注册的-Activity-？" class="headerlink" title="如何启动一个未在 manifest 中注册的 Activity ？"></a>如何启动一个未在 manifest 中注册的 Activity ？</h3><p>加载 manifest 信息及检测注册在 system_server 进程，即无法干扰检测逻辑。常见做法是在 manifest 中注册一个占位 Activity，在进入 system_server 进程之前把未注册的 Activity 修改为占位 Activity，然后等从 system_server 返回到 App 进程后再修改回未注册的 Activity，然后去创建、启动，也就是说需 hook 两处：</p><p>hook ActivityTaskManager：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Field singletonField = ActivityTaskManager<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">             .getDeclaredField("IActivityTaskManagerSingleton");</span><br><span class="line">singletonField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton singleton = (Singleton) singletonField.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">final</span> Object activityTaskManagerObject = singleton.get();</span><br><span class="line">final Field mInstanceField = Singleton.class.getDeclaredField("mInstance");</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object value = Proxy.newProxyInstance(ActivityTaskManager<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span></span><br><span class="line">     , new Class[]&#123;Class.forName("android.app.IActivityTaskManager")&#125;</span><br><span class="line">     , <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">                  Intent raw;</span><br><span class="line">                  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">                        index = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (!(args[index] <span class="keyword">instanceof</span> Intent)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">                  raw = (Intent) args[index];</span><br><span class="line">                  <span class="keyword">if</span> (raw.getComponent().getClassName()</span><br><span class="line">                         .equals(<span class="string">"com.yinghao.test.UnRegisterActivity"</span>)) &#123;</span><br><span class="line">                      ntent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">                      <span class="comment">//将未注册的 UnRegisterActivity 替换为占位 FakeActivity</span></span><br><span class="line">                      newIntent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.yinghao.test"</span>, </span><br><span class="line">                                   FakeActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">                      <span class="comment">//记录 UnRegisterActivity</span></span><br><span class="line">                      newIntent.putExtra(EXTRA_TARGET_INTENT, raw); </span><br><span class="line">                      args[index] = newIntent;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(activityTaskManagerObject, args);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mInstanceField.set(singleton, value);</span><br></pre></td></tr></table></figure></p><p>hook ActivityThread：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread activityThread = ActivityThread.currentActivityThread();</span><br><span class="line">Field mH1 = activityThread.getClass().getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mH1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">final</span> Handler mH = (Handler) mH1.get(activityThread);</span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField("mCallback");</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (msg.what == <span class="number">159</span>) &#123; <span class="comment">// ActivityThread.H.EXECUTE_TRANSACTION</span></span><br><span class="line">    <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">    Field mActivityCallbacksField = transaction</span><br><span class="line">               .getClass().getDeclaredField(<span class="string">"mActivityCallbacks"</span>);</span><br><span class="line">    mActivityCallbacksField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    List&lt;ClientTransactionItem&gt; clientTransactionItems = </span><br><span class="line">        (List&lt;ClientTransactionItem&gt;) mActivityCallbacksField.get(transaction);</span><br><span class="line">    <span class="keyword">if</span> (clientTransactionItems != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (ClientTransactionItem c : clientTransactionItems) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c <span class="keyword">instanceof</span> LaunchActivityItem) &#123;</span><br><span class="line">       <span class="comment">//修正 Activity 启动事件实体 LaunchActivityItem</span></span><br><span class="line">       LaunchActivityItem item = (LaunchActivityItem) c;</span><br><span class="line">       Field intentField = item.getClass().getDeclaredField(<span class="string">"mIntent"</span>);</span><br><span class="line">       intentField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Intent intent = (Intent) intentField.get(item);</span><br><span class="line">       Field mInfoField = item.getClass().getDeclaredField(<span class="string">"mInfo"</span>);</span><br><span class="line">       mInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       ActivityInfo aInfo = (ActivityInfo) mInfoField.get(item);</span><br><span class="line">       Intent realIntent = intent.getParcelableExtra(EXTRA_TARGET_INTENT);</span><br><span class="line">       <span class="keyword">if</span> (realIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//将占位 FakeActivity 改回未注册的 UnRegisterActivity</span></span><br><span class="line">         intent.setComponent(realIntent.getComponent());</span><br><span class="line">         aInfo.packageName = realIntent.getComponent().getPackageName();</span><br><span class="line">         aInfo.name = realIntent.getComponent().getClassName();</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//返回 false 正好可以让 ActivityThread 继续处理</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>实现启动未注册 Activity 的前提必然是已掌握 startActivity 流程，这也是插件化的入门，实际应用需要去兼容各个 Android 版本</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>带着问题去分析、学习源码，自然的就会聚焦出一条主线</p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center><div style="display: none"><br>participant Activity<br>participant Instrumentation<br>participant ActivityTaskManager<br>participant IActivityTaskManager<br>Note over IActivityTaskManager:AIDL<br>participant ActivityTaskManagerService<br>participant ActivityStartController<br>participant ActivityStarter<br>participant RootActivityContainer<br>participant ActivityStack<br>participant ActivityStackSupervisor<br>participant ClientLifecycleManager<br>participant ClientTransaction<br>participant IApplicationThread<br>Note over IApplicationThread:AIDL<br>participant ApplicationThread<br>participant ActivityThread<br>participant ActivityThread.H<br>participant TransactionExecutor<br>participant PauseActivityItem<br>participant LaunchActivityItem<br>participant ResumeActivityItem<br>Activity-&gt; Instrumentation:startActivityAsUser()<br>Instrumentation-&gt; ActivityTaskManager:execStartActivity()<br>ActivityTaskManager-&gt; IActivityTaskManager:startActivity()<br><br>IActivityTaskManager-&gt; ActivityTaskManagerService:startActivity()<br>ActivityTaskManagerService-&gt; ActivityStartController:getActivityStartController()<br>ActivityStartController-&gt; ActivityStarter:obtainStarter()<br>ActivityStarter-&gt; ActivityStarter:startActivityMayWait()<br>ActivityStarter-&gt; ActivityStarter:startActivity()<br>ActivityStarter-&gt;RootActivityContainer:startActivityUnchecked()<br>RootActivityContainer-&gt;ActivityStack:resumeFocusedStacksTopActivities()<br>ActivityStack-&gt;ActivityStack: resumeTopActivityUncheckedLocked()<br>ActivityStack–&gt;ClientLifecycleManager:startPausingLocked()<br>ClientLifecycleManager-&gt;ClientTransaction:scheduleTransaction(PauseActivityItem)<br>ClientTransaction-&gt;IApplicationThread:schedule()<br>IApplicationThread-&gt;ApplicationThread:scheduleTransaction()<br>ApplicationThread-&gt;ActivityThread:scheduleTransaction()<br>ActivityThread-&gt;ActivityThread.H:sendMessage(EXECUTE_TRANSACTION)<br>ActivityStack-&gt;ActivityStackSupervisor:resumeTopActivityInnerLocked()<br>ActivityStackSupervisor-&gt;ActivityStackSupervisor:startSpecificActivityLocked()<br>ActivityStackSupervisor-&gt;ClientLifecycleManager:realStartActivityLocked()<br>ClientLifecycleManager-&gt;ClientTransaction:scheduleTransaction(ResumeActivityItem)<br>ClientTransaction-&gt;IApplicationThread:schedule()<br>IApplicationThread-&gt;ApplicationThread:scheduleTransaction()<br>ApplicationThread-&gt;ActivityThread:scheduleTransaction()<br>ActivityThread-&gt;ActivityThread.H:sendMessage(EXECUTE_TRANSACTION)<br><br>ActivityThread.H-&gt;TransactionExecutor:handleMessage()<br>TransactionExecutor-&gt;TransactionExecutor:execute()<br>TransactionExecutor-&gt;PauseActivityItem:executeLifecycleState()<br>PauseActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handlePauseActivity()<br>ActivityThread-&gt;ActivityThread:performPauseActivity()<br>ActivityThread–&gt;Instrumentation:performPauseActivityIfNeeded()<br>Instrumentation-&gt;Activity:callActivityOnPause()<br>Activity-&gt;Activity:performPause()<br>Activity-&gt;Activity:onPause()<br><br>ActivityThread.H-&gt;TransactionExecutor:handleMessage()<br>TransactionExecutor-&gt;TransactionExecutor:execute()<br>TransactionExecutor–&gt;LaunchActivityItem:executeCallbacks()<br>LaunchActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handleLaunchActivity()<br>ActivityThread–&gt;Instrumentation:performLaunchActivity()<br>Instrumentation-&gt;Activity:callActivityOnCreate()<br>Activity-&gt;Activity:performCreate()<br>Activity-&gt;Activity:onCreate()<br><br>TransactionExecutor–&gt;ResumeActivityItem:executeLifecycleState()<br>ResumeActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handleResumeActivity()<br>ActivityThread–&gt;Activity:performResumeActivity()<br>Activity-&gt;Instrumentation:performResume()<br>Instrumentation-&gt;Activity:callActivityOnResume()<br>Activity-&gt;Activity:onResume()<br></div><div style="display: none"><br><div id="sequence-0"></div><br></div><div style="display: none"><br><div id="sequence-1"></div><br></div><div style="display: none"><br><br>ActivityThread-&gt;ActivityThread:Loop#prepareMainLooper()<br>ActivityThread–&gt;IActivityManager:attach()<br>Note over IActivityManager:AIDL<br>IActivityManager-&gt;ActivityManagerService:attachApplication()<br>ActivityManagerService-&gt;IApplicationThread:attachApplicationLocked()<br>Note over IApplicationThread:AIDL<br>IApplicationThread-&gt;ApplicationThread:bindApplication()<br>ApplicationThread-&gt;ActivityThread.H:sendMessage(BIND_APPLICATION)<br><br>ActivityManagerService–&gt;ActivityTaskManagerService.LocalService:attachApplicationLocked()<br>ActivityTaskManagerService.LocalService-&gt;RootActivityContainer:attachApplication()<br>RootActivityContainer-&gt;ActivityStackSupervisor:attachApplication()<br>ActivityStackSupervisor-&gt;ClientLifecycleManager:realStartActivityLocked()<br>ClientLifecycleManager-&gt;ClientLifecycleManager:scheduleTransaction()<br><br>ActivityThread-&gt;ActivityThread:Looper#loop()<br><br>ActivityThread.H–&gt;ActivityThread:handleMessage(BIND_APPLICATION)<br>ActivityThread–&gt;LoadedApk:handleBindApplication()<br>LoadedApk-&gt;Instrumentation:makeApplication()<br>Instrumentation-&gt;CoreComponentFactory:newApplication()<br>CoreComponentFactory-&gt;CoreComponentFactory:instantiateApplication()<br>Instrumentation–&gt;Application:callApplicationOnCreate()<br>Application-&gt;Application:onCreate()<br><br></div><p><script src="https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js"></script><script src="https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js"></script><script src="https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js"></script><script src="https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">ActivityStarter->ActivityStackSupervisor:startActivityMayWait()ActivityStackSupervisor->ActivityTaskManagerService:resolveIntent()ActivityTaskManagerService->PackageManagerInternalImpl:getPackageManagerInternalLocked()PackageManagerInternalImpl->PackageManagerService:resolveIntent()PackageManagerService->PackageManagerService:resolveIntentInternal()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">ActivityStackSupervisor->ActivityManagerInternal(ActivityManagerService.LocalService):startSpecificActivityLocked()ActivityManagerInternal(ActivityManagerService.LocalService)->ActivityManagerService:startProcess()ActivityManagerService->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->Process:startProcess()Process->ZygoteProcess:start()ZygoteProcess->ZygoteProcess:startViaZygote()ZygoteProcess->ZygoteProcess:openZygoteSocketIfNeeded()ZygoteProcess->ZygoteProcess:zygoteSendArgsAndGetResult()</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;源码基于 &lt;a href=&quot;https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 10&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/categories/Framework/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/tags/Framework/"/>
    
      <category term="AMS" scheme="http://yhaowa.gitee.io/tags/AMS/"/>
    
  </entry>
  
  <entry>
    <title>Android 集成 FFmpeg (四) 轻松实现一个音视频编辑 App</title>
    <link href="http://yhaowa.gitee.io/798144ac/"/>
    <id>http://yhaowa.gitee.io/798144ac/</id>
    <published>2019-06-16T12:07:18.000Z</published>
    <updated>2020-04-07T15:34:42.792Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看到一篇关于 FFmpeg 的文章，讲的大概是基于 FFmpeg 实现了一个 App，支持视频拼图等强大炫酷的音视频编辑功能，其原理是在 Android 端集成 FFmpeg，通过命令方式调用 FFmpeg。</p><p>尽管在 Android 端集成命令方式调用并不复杂，但一个具有强大炫酷音视频编辑功能的 App 是有价值的。由此启发，并决定敲下 Android 集成 FFmpeg 系列的第四篇，以一个实际应用的方式展现 FFmpeg 强大的音视频编辑功能。</p><a id="more"></a><p>应用截图：</p><p><img src="../img/19.jpg" alt></p><blockquote><p>源码：<a href="https://github.com/yhaolpz/FFmpegCmd" target="_blank" rel="noopener">https://github.com/yhaolpz/FFmpegCmd</a></p></blockquote><p>若想实现更多效果，见 <a href="http://ffmpeg.org/ffmpeg.html" target="_blank" rel="noopener">ffmpeg Documentation</a>，应用代码非常简单，这里就不再过多阐述，直接查看源码，一看即懂，理论知识及编译实现见前三篇：</p><blockquote><p><a href="https://yhaolpz.github.io/e0b4d9fc/" target="_blank" rel="noopener">Android 集成 FFmpeg (一) 基础知识及简单调用</a><br><a href="https://yhaolpz.github.io/ddeb5551/" target="_blank" rel="noopener">Android 集成 FFmpeg (二) 以命令方式调用 FFmpeg</a><br><a href="https://yhaolpz.github.io/8837781/" target="_blank" rel="noopener">Android 集成 FFmpeg (三) 获取 FFmpeg 执行进度</a></p></blockquote><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看到一篇关于 FFmpeg 的文章，讲的大概是基于 FFmpeg 实现了一个 App，支持视频拼图等强大炫酷的音视频编辑功能，其原理是在 Android 端集成 FFmpeg，通过命令方式调用 FFmpeg。&lt;/p&gt;
&lt;p&gt;尽管在 Android 端集成命令方式调用并不复杂，但一个具有强大炫酷音视频编辑功能的 App 是有价值的。由此启发，并决定敲下 Android 集成 FFmpeg 系列的第四篇，以一个实际应用的方式展现 FFmpeg 强大的音视频编辑功能。&lt;/p&gt;
    
    </summary>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="FFmpeg" scheme="http://yhaowa.gitee.io/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES（二）绘制三角形</title>
    <link href="http://yhaowa.gitee.io/2296ca3/"/>
    <id>http://yhaowa.gitee.io/2296ca3/</id>
    <published>2019-06-16T08:39:50.000Z</published>
    <updated>2020-04-07T15:34:42.740Z</updated>
    
    <content type="html"><![CDATA[<p>通过上篇文章的学习，现在已经了解到，要想在 Android 端使用 OpenGL ES 绘制图形，必须创建 OpenGL ES 环境和视图窗口，具体来说就是构建 EGL 环境，即 OpenGL ES 和 Android 底层平台视窗系统之间的接口。另外 OpenGL ES 2.0 版本为可编程管线，我们就可以编写着色器程序来确定绘制内容，即编写 Vertex Shader 顶点着色器和 Fragment Shader 片元着色器。</p><p>而这些工作可以通过 GLSurfaceView 非常简单的实现。</p><a id="more"></a><p>在介绍 GLSurfaceView 之前先来看下 Android 系统提供的与 OpenGL ES 相关的包：</p><ul><li>javax.microedition.khronos.opengles： 存放 GL 绘图指令相关代码</li><li>javax.microedition.khronos.egl： 存放 EGL 管理相关代码，包括 Display、surface 等</li><li>android.opengl： 存放 GL 辅助类，连接 OpenGL 与 Android View，Activity 等</li></ul><p>其中 GLSurfaceView 处于 android.opengl 包中，GLSurfaceView 具有以下特性：</p><ul><li>内置 EGL 管理，自带 GL 上下文环境和 GLThread 绘制线程</li><li>起到连接 OpenGL ES 与 Android 的 View 层次结构之间的桥梁作用</li><li>使得 OpenGL ES 库适应于 Activity 生命周期</li><li>继承自 SurfaceView，拥有 SurfaceView 的全部特性，绘制结果会输出到 SurfaceView 所提供的 Surface 上</li><li>提供了方便使用的调试工具来跟踪 OpenGL ES 函数调用以帮助检查错误</li></ul><p>通过 GLSurfaceView 的 setRenderer 方法可设置要渲染的效果，即 GLSurfaceView.Renderer 渲染器接口，该接口方法：</p><ul><li>onSurfaceCreated：渲染线程开启时调用，可做初始化背景色、初始化纹理资源等工作</li><li>onSurfaceChanged：窗口尺寸改变时调用，通常会设置视窗范围或投影矩阵等</li><li>onDrawFrame：外部请求渲染一次就调用一次，可在此载入着色器程序、激活绑定纹理以及调用绘制</li></ul><p>下面来看具体如何绘制一个三角形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String vertexShaderResource =</span><br><span class="line">            <span class="string">"attribute vec3 vPosition;"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;"</span> +</span><br><span class="line">                    <span class="string">"  gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);"</span> +</span><br><span class="line">                    <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String fragmentShaderResource =</span><br><span class="line">            <span class="string">"precision mediump float;"</span> +</span><br><span class="line">                    <span class="string">"uniform vec4 vColor;"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;"</span> +</span><br><span class="line">                    <span class="string">"  gl_FragColor = vColor;"</span> +</span><br><span class="line">                    <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] vertexCoords = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">            <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// top</span></span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom left</span></span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// bottom right</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> color[] = &#123;<span class="number">1.0f</span>, <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">1.0f</span>&#125;; <span class="comment">//red</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 着色器程序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mProgram;</span><br><span class="line">    <span class="comment">// 顶点坐标数据</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer vertexFloatBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置清空屏幕后的背景色</span></span><br><span class="line">        GLES30.glClearColor(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">//构建顶点着色器</span></span><br><span class="line">        <span class="keyword">int</span> vertexShader = GLES30.glCreateShader(GLES30.GL_VERTEX_SHADER);</span><br><span class="line">        GLES30.glShaderSource(vertexShader, vertexShaderResource);</span><br><span class="line">        GLES30.glCompileShader(vertexShader);</span><br><span class="line">        <span class="comment">//构建片段着色器</span></span><br><span class="line">        <span class="keyword">int</span> fragmentShader = GLES30.glCreateShader(GLES30.GL_FRAGMENT_SHADER);</span><br><span class="line">        GLES30.glShaderSource(fragmentShader, fragmentShaderResource);</span><br><span class="line">        GLES30.glCompileShader(fragmentShader);</span><br><span class="line">        <span class="comment">//构建着色器程序，并将顶点着色器和片段着色器链接进来</span></span><br><span class="line">        mProgram = GLES30.glCreateProgram();</span><br><span class="line">        GLES30.glAttachShader(mProgram, vertexShader);</span><br><span class="line">        GLES30.glAttachShader(mProgram, fragmentShader);</span><br><span class="line">        GLES30.glLinkProgram(mProgram);</span><br><span class="line">        <span class="comment">//顶点着色器和片段着色器链接到着色器程序后就无用了</span></span><br><span class="line">        GLES30.glDeleteShader(vertexShader);</span><br><span class="line">        GLES30.glDeleteShader(fragmentShader);</span><br><span class="line">        <span class="comment">//转换为需要的顶点数据格式</span></span><br><span class="line">        vertexFloatBuffer = floatToBuffer(vertexCoords);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置视窗</span></span><br><span class="line">        GLES30.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//清空屏幕，擦除屏幕上所有的颜色，用 glClearColor 定义的颜色填充</span></span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">//在当前 EGL 环境激活着色器程序</span></span><br><span class="line">        GLES30.glUseProgram(mProgram);</span><br><span class="line">        <span class="comment">//获取顶点着色器的 vPosition 成员句柄</span></span><br><span class="line">        <span class="keyword">int</span> positionHandle = GLES30.glGetAttribLocation(mProgram, <span class="string">"vPosition"</span>);</span><br><span class="line">        <span class="comment">//启用句柄</span></span><br><span class="line">        GLES30.glEnableVertexAttribArray(positionHandle);</span><br><span class="line">        <span class="comment">//设置顶点坐标数据</span></span><br><span class="line">        GLES30.glVertexAttribPointer(positionHandle, <span class="number">3</span>, GLES30.GL_FLOAT,</span><br><span class="line">                <span class="keyword">false</span>, <span class="number">3</span> * <span class="number">4</span>, vertexFloatBuffer);</span><br><span class="line">        <span class="comment">//获取片元着色器的 vColor 成员句柄</span></span><br><span class="line">        <span class="keyword">int</span> colorHandle = GLES30.glGetUniformLocation(mProgram, <span class="string">"vColor"</span>);</span><br><span class="line">        <span class="comment">//设置颜色</span></span><br><span class="line">        GLES30.glUniform4fv(colorHandle, <span class="number">1</span>, color, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//绘制三角形</span></span><br><span class="line">        GLES30.glDrawArrays(GLES30.GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//禁止顶点数组的句柄</span></span><br><span class="line">        GLES30.glDisableVertexAttribArray(positionHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FloatBuffer <span class="title">floatToBuffer</span><span class="params">(<span class="keyword">float</span>[] a)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(a.length * <span class="number">4</span>); <span class="comment">//float占4个字节</span></span><br><span class="line">        buffer.order(ByteOrder.nativeOrder());</span><br><span class="line">        FloatBuffer byteBuffer = buffer.asFloatBuffer();</span><br><span class="line">        byteBuffer.put(a);</span><br><span class="line">        byteBuffer.position(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> byteBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h4><p>要绘制一个三角形，就要确定三个顶点的 3D 坐标（OpenGL 是一个 3D 图形库，在 OpenGL 中指定的所有坐标都需要是 3D 坐标，即 x、y 和 z）。而顶点坐标起始于局部坐标，需要为标准化设备坐标，即 x、y、z 的范围限定于 -1 到 1 之间，任何落在范围外的坐标都会被丢弃。上面代码中输入的顶点数据为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] vertexCoords = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里将 z 坐标都设置为 0，表示三角形每一点的深度都为 0（通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源），这样定义的顶点数据反应到标准化设备坐标系中就是这样的：</p><p><img src="../img/17.jpg" alt></p><h4 id="解释顶点数据"><a href="#解释顶点数据" class="headerlink" title="解释顶点数据"></a>解释顶点数据</h4><p>可以看到调用 glVertexAttribPointer 设置顶点数据时并不是直接把 float[] 数组传递进去，而是转换成 FloatBuffer 传入，所谓的解释顶点数据就是说明输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。对于 glVertexAttribPointer 函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glVertexAttribPointer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> indx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> normalized,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> stride,</span></span></span><br><span class="line"><span class="function"><span class="params">    java.nio.Buffer ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>indx：指定要配置的顶点属性，这里传入顶点着色器的 vPosition 成员句柄</li><li>size：指定顶点属性的大小，顶点属性是一个 vec3，它由 3 个值（x、y、z）组成，所以大小传入 3</li><li>type：指定数据的类型为 float 类型</li><li>normalized：是否希望数据被标准化</li><li>stride：指定连续的顶点数据之间的间隔，由于一个顶点数据长度为 3 个 float，所以把步长设置为 3 * 4（一个 float 占 4 个字节）</li><li>ptr：顶点数据</li></ul><p>下图很好的阐释这个逻辑：</p><p><img src="../img/18.jpg" alt></p><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String vertexShaderResource =</span><br><span class="line">    <span class="string">"attribute vec3 vPosition;"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;"</span> +</span><br><span class="line">        <span class="string">"  gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><p>由于每个顶点都有一个 3D 坐标，这里就创建一个 vec3 变量输入顶点坐标。而内置变量 gl_Position 为 vec4 类型，所以需要将三维向量转换为四维向量，最后 gl_Position 设置的值会成为该顶点着色器的输出。</p><p>onDrawFrame 方法中在获取顶点着色器的 vPosition 成员句柄后，需要调用 glEnableVertexAttribArray、glDisableVertexAttribArray 分别启用、禁止顶点数据，而片段着色器的 vColor 成员句柄就不需要。这是因为出于性能考虑，所有顶点着色器的属性默认都是关闭的。<br>glVertexAttribPointer 只是建立 CPU 和 GPU 之间的逻辑连接实现将 CPU 数据上传至 GPU，但是，数据在 GPU 端是否可见，即着色器能否读取到数据，还要取决于 glEnableVertexAttribArray 方法。</p><h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String fragmentShaderResource =</span><br><span class="line"><span class="string">"precision mediump float;"</span> +</span><br><span class="line">        <span class="string">"uniform vec4 vColor;"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;"</span> +</span><br><span class="line">        <span class="string">"  gl_FragColor = vColor;"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><p>在 OpenGL 中定义一个颜色的数据格式为 RGBA 四个 0.0 到 1.0 之间强度的分量，片段着色器所做的是计算像素最后的颜色输出，也只有 gl_FragColor 这一个输出变量。</p><h4 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vertexShader = GLES30.glCreateShader(GLES30.GL_VERTEX_SHADER);</span><br><span class="line">GLES30.glShaderSource(vertexShader, vertexShaderResource);</span><br><span class="line">GLES30.glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p>为了让 OpenGL 能够使用我们编写的着色器源码，必须在运行时动态编译。首先通过 glCreateShader 创建一个着色器对象，返回该着色器的 ID，然后通过 glShaderSource、glCompileShader 方法将源码附着在着色器对象上并编译它。</p><p>编译着色器可能失败，一般编译时会通过如下方法判断是否编译成功并输出编译信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] compileStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">GLES20.glGetShaderiv(shaderObjectId, GLES20.GL_COMPILE_STATUS, compileStatus, <span class="number">0</span>);</span><br><span class="line">Log.d(TAG, <span class="string">"glCompileStatus: "</span> + compileStatus[<span class="number">0</span>] </span><br><span class="line">            + <span class="string">" log:"</span> + GLES20.glGetShaderInfoLog(shaderObjectId));</span><br><span class="line"><span class="keyword">if</span> (compileStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="comment">//编译失败</span></span><br><span class="line">    GLES20.glDeleteShader(shaderObjectId);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mProgram = GLES30.glCreateProgram();</span><br><span class="line">GLES30.glAttachShader(mProgram, vertexShader);</span><br><span class="line">GLES30.glAttachShader(mProgram, fragmentShader);</span><br><span class="line">GLES30.glLinkProgram(mProgram);</span><br></pre></td></tr></table></figure><p>着色器程序对象是多个着色器合并之后并最终链接完成的版本，它将编译好的顶点着色器和片段着色器链接为一个着色器程序对象，链接后顶点着色器和片段着色器就没用了，可以通过 glDeleteShader 删除。就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">GLES20.glGetProgramiv(mProgram, GLES20.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">Log.d(TAG, <span class="string">"glCompileStatus："</span> + linkStatus[<span class="number">0</span>]</span><br><span class="line">            + <span class="string">" log:"</span> + GLES20.glGetProgramInfoLog(mProgram));</span><br><span class="line"><span class="keyword">if</span> (linkStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="comment">//链接失败</span></span><br><span class="line">    GLES20.glDeleteProgram(mProgram);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链接成功后，在渲染的时候通过 glUseProgram 方法激活着色器程序，已激活着色器程序的着色器就会在渲染时被使用，最后通过 glDrawArrays 方法触发绘制。</p><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://item.jd.com/12292642.html" target="_blank" rel="noopener">《音视频开发进阶指南 - 基于Android与IOS平台的实践》</a><br><a href="https://blog.csdn.net/TuGeLe/article/details/79199161" target="_blank" rel="noopener">Android GLSurfaceView详解</a><br><a href="http://wiki.jikexueyuan.com/project/opengl-es-guide/glsurfaceview.html" target="_blank" rel="noopener">GLSurfaceView</a><br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">你好，三角形</a><br><a href="https://www.jianshu.com/p/b05884a0ff8e" target="_blank" rel="noopener">OpenGL ES 3.0 glEnableVertexAttribArray的作用</a></p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过上篇文章的学习，现在已经了解到，要想在 Android 端使用 OpenGL ES 绘制图形，必须创建 OpenGL ES 环境和视图窗口，具体来说就是构建 EGL 环境，即 OpenGL ES 和 Android 底层平台视窗系统之间的接口。另外 OpenGL ES 2.0 版本为可编程管线，我们就可以编写着色器程序来确定绘制内容，即编写 Vertex Shader 顶点着色器和 Fragment Shader 片元着色器。&lt;/p&gt;
&lt;p&gt;而这些工作可以通过 GLSurfaceView 非常简单的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES（一）开发入门</title>
    <link href="http://yhaowa.gitee.io/eeb650a2/"/>
    <id>http://yhaowa.gitee.io/eeb650a2/</id>
    <published>2019-06-09T12:40:06.000Z</published>
    <updated>2020-04-07T15:34:42.743Z</updated>
    
    <content type="html"><![CDATA[<p>早就听过大名鼎鼎的 OpenGL，却迟迟没有实践学习，有些惭愧。今天开始通过实践+博文方式学习掌握 OpenGL。此文对于 OpenGL 的学习分为以下部分：</p><ul><li>OpenGL 基础概念</li><li>OpenGL 坐标系理解</li><li>OpenGL 渲染管线</li><li>OpenGL 着色语言</li></ul><a id="more"></a><h1 id="OpenGL-基础概念"><a href="#OpenGL-基础概念" class="headerlink" title="OpenGL 基础概念"></a>OpenGL 基础概念</h1><h4 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h4><p>OpenGL 即 Open Graphics Library，是一个功能强大、调用方便的底层图形库，它定义了跨编程语言、跨平台的专业图形程序接口，可用于二维或三维图像的处理与渲染。</p><p>OpenGL 是跨平台的，除了它纯粹专注的渲染外，其他内容在每个平台上都要有它的具体实现，比如上下文环境和窗口的管理就交由各个设备自己来完成。</p><h4 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h4><p>OpenGL ES （OpenGL for Embedded Systems）是三维图形 API OpenGL 的子集，针对手机、PDA 和游戏主机等嵌入式设备而设计。</p><p>Android 对应 OpenGL ES 的版本支持如下：</p><ul><li>Android 1.0 开始支持 OpenGL ES 1.0 及 1.1</li><li>Android 2.2 开始支持 OpenGL ES 2.0</li><li>Android 4.3 开始支持 OpenGL ES 3.0</li><li>Android 5.0 开始支持 OpenGL ES 3.1</li></ul><p>其中 OpenGL ES 1.0 是以 OpenGL 1.3 规范为基础的，OpenGL ES 1.1 是以 OpenGL 1.5 规范为基础的，而 OpenGL ES 2.0 基于 OpenGL 2.0 实现。2.x 版本相比 1.x 版本有较大差异，1.x 版本为 fixed function pipeline，即固定管线硬件，而 2.x 版本为 programmable pipeline，可编程管线硬件。</p><p>固定管线中原本由系统做的一部分工作，在可编程管线中必须需要自己写程序实现，具体程序为 vertex shader（顶点着色器）和 fragment shader（片元着色器）。</p><h4 id="OpenGL-上下文"><a href="#OpenGL-上下文" class="headerlink" title="OpenGL 上下文"></a>OpenGL 上下文</h4><p>OpenGL 是一个仅仅关注图像渲染的图像接口库，在渲染过程中它需要将顶点信息、纹理信息、编译好的着色器等渲染状态信息存储起来，而存储这些信息的数据结构就可以看作 OpenGL 的上下文。</p><p>调用任何 OpenGL 函数前，必须已经创建了 OpenGL Context，GL Context 存储了OpenGL 的状态变量以及其他渲染有关的信息。OpenGL 是个状态机，有很多状态变量，是个标准的过程式操作过程，改变状态会影响后续所有操作，这和面向对象的解耦原则不符，毕竟渲染本身就是个复杂的过程。OpenGL 采用 Client-Server 模型来解释 OpenGL 程序，即 Server 存储 GL Context（可能不止一个），Client 提出渲染请求，Server 给予响应，一般 Server 和 Client 都在我们的 PC 上，但 Server 和 Client 也可以是通过网络连接。</p><p>之后的渲染工作就要依赖这些渲染状态信息来完成，当一个上下文被销毁时，它所对应的 OpenGL 渲染工作也将结束。</p><h4 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h4><p>在 OpenGL 的设计中，OpenGL 是不负责管理窗口的，窗口的管理交由各个设备自己来完成，具体来讲，IOS 平台上使用 EAGL 提供本地平台对 OpenGL 的实现，在 Android 平台上使用 EGL 提供本地平台对 OpenGL 的实现。EGL 是 OpenGL ES 和 Android 底层平台视窗系统之间的接口，在 OpenGL 的输出与设备屏幕之间架接起一个桥梁，承担了为 OpenGL 提供上下文环境以及管理窗口的职责。</p><p>EGL 为双缓冲工作模式，即有一个 Back Frame Buffer 和一个 Front Frame Buffer，正常绘制的目标都是 Back Frame Buffer，绘制完成后再调用 eglSwapBuffer API，将绘制完毕的 FrameBuffer 交换到 Front Frame Buffer 并显示出来。</p><p>从代码层面来看，OpenGL ES 的 opengles 包下定义了平台无关的绘图指令，EGL（javax.microedition.khronos.egl）<br>则定义了控制 displays，contexts 以及 surfaces 的统一的平台接口。</p><ul><li>Display（EGLDisplay） 是对实际显示设备的抽象</li><li>Surface（EGLSurface）是对用来存储图像的内存区域 FrameBuffer 的抽象，包括 Color Buffer、Stencil Buffer、Depth Buffer</li><li>Context（EGLContext）存储 OpenGL ES 绘图的一些状态信息</li></ul><p><img src="../img/1.jpeg" alt></p><blockquote><p>使用 EGL 绘图的一般步骤：<br>获取 EGLDisplay 对象<br>初始化与 EGLDisplay 之间的连接<br>获取 EGLConfig 对象<br>创建 EGLContext 实例<br>创建 EGLSurface 实例<br>连接 EGLContext 和 EGLSurface<br>使用 GL 指令绘制图形<br>断开并释放与 EGLSurface 关联的 EGLContext 对象<br>删除 EGLSurface 对象<br>删除 EGLContext 对象<br>终止与 EGLDisplay 之间的连接</p></blockquote><p>一般来说在 Android 平台上开发 OpenGL ES 应用，无需按照上述步骤来绘制图形，可以直接使用 GLSurfaceView 控件，该控件提供了对 Display、Surface 以及 Context 的管理，大大简化了开发流程。</p><h4 id="OpenGL-纹理"><a href="#OpenGL-纹理" class="headerlink" title="OpenGL 纹理"></a>OpenGL 纹理</h4><p>纹理（Texture）是一个 2D 图片（甚至也有 1D 和 3D 的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的 3D 的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><h1 id="OpenGL-坐标系理解"><a href="#OpenGL-坐标系理解" class="headerlink" title="OpenGL 坐标系理解"></a>OpenGL 坐标系理解</h1><p>OpenGL 要求输入的顶点坐标都是标准化设备坐标，即每个顶点的 x、y、z 都在 -1 到 1 之间，由标准化设备坐标转换为屏幕坐标的过程中会经历变换多个坐标系统，在这些特定的坐标系中，一些操作和计算可以更加方便。</p><p><img src="../img/15.jpg" alt></p><ul><li><strong>1. 局部坐标</strong><br>顶点坐标起始于局部空间（Local Space），在这里称为局部坐标，是以物体某一点为原点而建立的，该坐标系仅对该物体适用，用来简化对物体各部分坐标的描述。物体放到场景中时，各部分经历的坐标变换相同，相对位置不变。</li><li><strong>2. 世界坐标</strong><br>局部坐标通过模型矩阵进行位移、缩放、旋转，将物体从局部变换到世界空间，并和其他物体一起相对于世界的原点摆放。</li><li><strong>3. 观察坐标</strong><br>将世界空间坐标转化为用户视野前方的坐标，通常是由一系列的位移和旋转的组合（观察矩阵）来完成。</li><li><strong>4. 裁剪坐标</strong><br>坐标到达观察空间之后，通过投影矩阵会将指定范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)，所有在范围外的坐标会被裁剪掉。</li><li><strong>5. 屏幕坐标</strong><br>将裁剪坐标位于(-1.0, 1.0)范围的坐标变换到由 glViewport 函数所定义的坐标范围内，最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ul><h1 id="OpenGL-渲染管线"><a href="#OpenGL-渲染管线" class="headerlink" title="OpenGL 渲染管线"></a>OpenGL 渲染管线</h1><p>OpenGL 渲染管线流程为：顶点数据 -&gt; 顶点着色器 -&gt; 图元装配 -&gt; 几何着色器 -&gt; 光栅化 -&gt; 片段着色器 -&gt; 逐片段处理 -&gt; 帧缓冲 </p><p><img src="../img/16.jpg" alt></p><p>OpenGL 渲染管线的流程其实就是 OpenGL 引擎渲染图像的流程，也就是说 OpenGL 引擎一步一步的将图片渲染到屏幕上的过程，渲染管线可以分为以下几个阶段：</p><ul><li><p><strong>1. 指定几何对象</strong><br>首先要了解几何图元的概念，几何图元就是点、直线、三角线等几何对象，在提供了顶点坐标后，还要确定具体要画的是点、线段还是三角形，这就要确定具体执行的绘制指令。比如 OpenGL 提供给开发者的绘制方法 glDrawArrays，这个方法的第一个参数就是指定绘制方式，可选值有：<br><strong>GL_POINTS</strong>：以点的形式进行绘制，通常用在绘制粒子效果的场景。<br><strong>GL_LINES</strong>：以线的形式进行绘制，通常用于绘制直线的场景。<br><strong>GL_TRIANGLE_STRIP</strong>：以三角形的形式进行绘制，所有二维图像的渲染都会使用这种方式。<br>具体选用哪一种绘制方式决定了 OpenGL 渲染管线的第一阶段应如何去绘制几何图元，这就是第一阶段指定几何对象。</p></li><li><p><strong>2. 顶点处理</strong><br>不论上面的几何图元是如何指定的，所有的几何数据都将会通过这个阶段。这个阶段的操作内容有：根据模型视图（即根据几何图元创建的物体）和投影矩阵进行变换来改变顶点的位置，根据纹理坐标与纹理矩阵来改变纹理坐标的位置，如果设计三维的渲染，还要处理光照计算和法线变换。<br>关键的操作就是顶点坐标变换及光照处理，每个顶点是分别单独处理的。这个阶段所接受的数据是每个顶点的属性特征，输出的则是变换后的顶点数据。</p></li><li><p><strong>3. 图元组装</strong><br>在顶点处理之后，顶点的全部属性都已经被确定。在这个阶段顶点将会根据应用程序设定的图元规则如 GL_POINTS 、GL_TRIANGLES(三角形) 等被组装成图元。</p></li><li><p><strong>4. 珊格化操作</strong><br>在图元组装后会传递过来图元数据，到目前为止，这些图元信息还只是顶点而已：顶点处都还没有“像素点”、直线段端点之间是空的、多边形的边和内部也是空的，光栅化的任务就是构造这些。<br>这个阶段会将图元数据分解成更小的单元并对应于帧缓冲区的各个像素，这些单元称为片元，一个片元可能包含窗口颜色、纹理坐标等属性。片元的属性则是图元上的顶点数据等经过插值而确定的，这就是珊格化操作，也就是确定好每一个片元是什么。</p></li><li><p><strong>5. 片元处理</strong><br>珊格化操作构造了像素点，这个阶段就是处理这些像素点，根据自己的业务处理（比如提亮、饱和度调节、对比度调节、高斯模糊等）来变换这个片元的颜色。</p></li><li><p><strong>6. 逐片段处理</strong><br>进行剪切、Alpha 测试、 模版测试、深度测试、混合等处理，这些操作将会最后影响其在帧缓冲区的颜色值。</p></li><li><p><strong>7. 帧缓冲操作</strong><br>此阶段主要执行帧缓冲的写入操作，也是渲染管线的最后一步，负责将最终的像素点写到帧缓冲区。</p></li></ul><p>上面提到 OpenGL ES 2.0 版本相比之前版本，提供了可编程的着色器来代替 1.x 版本渲染管线的某些阶段，具体为：</p><ul><li>Vertex Shader（顶点着色器）用于替换顶点处理阶段</li><li>Fragment Shader（片元着色器）用于替换片元处理阶段</li></ul><h1 id="OpenGL-着色语言"><a href="#OpenGL-着色语言" class="headerlink" title="OpenGL 着色语言"></a>OpenGL 着色语言</h1><p>OpenGL 着色语言 GLSL 全称为 OpenGL Shading Language，是为了实现着色器的功能而向开发人员提供的一种开发语言，语法与 C 语言类似，下面分为以下几点来学习 GLSL：</p><ul><li><strong>1. 基本数据类型</strong></li></ul><blockquote><p>void：空类型，即不返回任何值<br>bool：布尔类型，true/false<br>int：带符号的整数，signed integer<br>float：带符号的浮点数，signed scalar<br>vec2、vec3、vec4：n-维浮点数向量<br>bvec2、bvec3、bvec4：n-维布尔向量<br>ivec2、ivec3、ivec4：n-维整数向量<br>mat2、mat3、mat4：2x2、3x3、4x4 浮点数矩阵<br>sampler2D：2D 纹理<br>samplerCube：盒纹理</p></blockquote><p>其中 float 可指定精度：</p><blockquote><p>high：32bit，一般用于顶点坐标（vertex Coordinate）<br>medium：16bit，一般用于纹理坐标（texture Coordinate）<br>low：8bit，一般用于颜色表示（color）</p></blockquote><ul><li><strong>2. 变量修饰符</strong></li></ul><blockquote><p>none：(默认的可省略)本地变量，可读可写，函数的输入参数既是这种类型<br>const：声明变量或函数的参数为只读类型<br>attribute：用于保存顶点或法线数据,它可以在数据缓冲区中读取数据，仅能用于顶点着色器<br>uniform：在运行时 shader 无法改变 uniform 变量，一般用来放置程序传递给 shader 的变换矩阵，材质，光照参数等等，可用于顶点着色器和片元着色器<br>varying：用于修饰从顶点着色器向片元着色器传递的变量</p></blockquote><p>要注意全局变量限制符只能为 const、attribute、uniform 和 varying 中的某一个，不可复合。</p><ul><li><strong>3. 内置变量</strong></li></ul><p>GLSL 程序使用一些特殊的内置变量与硬件进行沟通，他们大致分成两种，一种是 input 类型,他负责向硬件(渲染管线)发送数据；另一种是 output 类型，负责向程序回传数据，以便编程时需要。<br>顶点着色器中 output 类型的内置变量如下：</p><blockquote><p>highp vec4  gl_Position：放置顶点坐标信息<br>mediump float gl_PointSize：需要绘制点的大小,(只在gl.POINTS模式下有效)</p></blockquote><p>片元着色器中 input 类型的内置变量如下：</p><blockquote><p>mediump vec4 gl_FragCoord;：片元在 framebuffer 画面的相对位置<br>bool gl_FrontFacing：标志当前图元是不是正面图元的一部分<br>mediump vec2 gl_PointCoord：经过插值计算后的纹理坐标,点的范围是0.0到1.0</p></blockquote><p>片元着色器中 output 类型的内置变量如下：</p><blockquote><p>mediump vec4 gl_FragColor：设置当前片点的颜色<br>mediump vec4 gl_FragData[n]：设置当前片点的颜色,使用glDrawBuffers数据数组</p></blockquote><ul><li><strong>4. 内置常量</strong></li></ul><p>GLSL 提供了一些内置的常量，用来说明当前系统的一些特性。有时我们需要针对这些特性，对 shader 程序进行优化，让程序兼容度更好。</p><p>顶点着色器中的内置常量如下：</p><blockquote><p>const mediump int gl_MaxVertexAttribs &gt;= 8：顶点着色器中可用的最大 attributes 数<br>const mediump int gl_MaxVertexUniformVectors &gt;= 128：顶点着色器中可用的最大 uniform vectors 数<br>const mediump int gl_MaxVaryingVectors &gt;= 8：顶点着色器中可用的最大 varying vectors 数<br>const mediump int gl_MaxVertexTextureImageUnits &gt;= 0：顶点着色器中可用的最大纹理单元数<br>const mediump int gl_MaxCombinedTextureImageUnits &gt;= 8：表示最多支持多少个纹理单元</p></blockquote><p>片元着色器中的内置常量如下：</p><blockquote><p>const mediump int gl_MaxTextureImageUnits &gt;= 8：片元着色器中能访问的最大纹理单元数<br>const mediump int gl_MaxFragmentUniformVectors &gt;= 16：片元着色器中可用的最大 uniform vectors 数<br>const mediump int gl_MaxDrawBuffers = 1：表示可用的 drawBuffers 数,在 OpenGL ES 2.0 中这个值为 1, 在将来的版本可能会有所变化</p></blockquote><p>上面这些值的大小取决于 OpenGL ES 在某设备上的具体实现。</p><ul><li><strong>5. 内置函数</strong></li></ul><blockquote><p>通用函数：abs、floor、min、max 等，参数可传入 float/vec2/vec3/vec4 类型<br>角度函数：sin、cos 等，参数可传入 float/vec2/vec3/vec4 类型<br>指数函数：pow、log 等，参数可传入 float/vec2/vec3/vec4 类型<br>几何函数：distance、dot 等，参数可传入 float/vec2/vec3/vec4 类型<br>矩阵函数：matrixCompMult，参数传入 mat 类型<br>向量函数：lessThan、equal 等，参数可传入 vec2/vec3/vec4 类型<br>纹理函数：texture2D、texture2DProj 等</p></blockquote><p>更详细的内置函数介绍可去官方文档查看，在此只简单列一下大致种类。</p><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://item.jd.com/12292642.html" target="_blank" rel="noopener">《音视频开发进阶指南 - 基于Android与IOS平台的实践》</a><br><a href="https://baike.baidu.com/item/OpenGL/238984?fr=aladdin" target="_blank" rel="noopener">OpenGL 百度百科</a><br><a href="https://blog.csdn.net/qq_36383623/article/details/89315921" target="_blank" rel="noopener">OpenGL Context（渲染上下文）</a><br><a href="https://baike.baidu.com/item/OpenGL%20ES" target="_blank" rel="noopener">OpenGL ES 百度百科</a><br><a href="https://blog.csdn.net/weixin_41101173/article/details/80036809" target="_blank" rel="noopener">在Android中使用OpenGL ES进行开发第（一）节：概念先行</a><br><a href="https://blog.csdn.net/jackie03/article/details/7298682" target="_blank" rel="noopener">Android OpenGL ES（四）:关于EGL</a><br><a href="https://blog.csdn.net/qq_35370018/article/details/80156643" target="_blank" rel="noopener">初学OpenGL（4）：纹理</a><br><a href="https://blog.csdn.net/u011153817/article/details/51899091" target="_blank" rel="noopener">OpenGL各坐标系及模型矩阵、投影矩阵等的深入理解</a><br><a href="https://www.cnblogs.com/liangliangh/p/4116164.html" target="_blank" rel="noopener">OpenGL管线（用经典管线代说着色器内部）</a><br><a href="https://blog.csdn.net/jeffasd/article/details/77989274" target="_blank" rel="noopener">OpenGL shader GLSL 中文手册</a><br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/" target="_blank" rel="noopener">坐标系统</a></p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就听过大名鼎鼎的 OpenGL，却迟迟没有实践学习，有些惭愧。今天开始通过实践+博文方式学习掌握 OpenGL。此文对于 OpenGL 的学习分为以下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenGL 基础概念&lt;/li&gt;
&lt;li&gt;OpenGL 坐标系理解&lt;/li&gt;
&lt;li&gt;OpenGL 渲染管线&lt;/li&gt;
&lt;li&gt;OpenGL 着色语言&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android 知识简记</title>
    <link href="http://yhaowa.gitee.io/c75061d/"/>
    <id>http://yhaowa.gitee.io/c75061d/</id>
    <published>2019-06-01T12:42:37.000Z</published>
    <updated>2020-04-07T15:34:42.790Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1.网络&amp;算法&amp;数据结构</li><li>2.Java 基础&amp;容器&amp;同步&amp;设计模式</li><li>3.Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理</li><li>4.Android 基础&amp;性能优化&amp;Framwork</li><li>5.Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩&amp;AOP</li><li>6.JNI&amp;音视频&amp;FFmpeg&amp;播放器</li><li>7.AndroidStudio&amp;Lint&amp;gradle&amp;maven&amp;CI&amp;CD</li></ul><a id="more"></a><h1 id="1-网络-amp-算法-amp-数据结构"><a href="#1-网络-amp-算法-amp-数据结构" class="headerlink" title="1.网络&amp;算法&amp;数据结构"></a>1.网络&amp;算法&amp;数据结构</h1><h4 id="网络协议模型"><a href="#网络协议模型" class="headerlink" title="网络协议模型"></a>网络协议模型</h4><ul><li>应用层：负责处理特定的应用程序细节，如 HTTP、FTP、DNS</li><li>运输层：为两台主机提供端到端的基础通信，如 TCP、UDP</li><li>网络层：控制分组传输、路由选择等，如 IP</li><li>链路层：操作系统设备驱动程序、网卡相关接口</li></ul><h4 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h4><ul><li>TCP 连接；可靠；有序；面向字节流；速度慢；较重量；全双工；适用于文件传输、浏览器等<br>全双工：A 给 B 发消息的同时，B 也能给 A 发<br>半双工：A 给 B 发消息的同时，B 不能给 A 发</li><li>UDP 无连接；不可靠；无序；面向报文；速度快；轻量；适用于即时通讯、视频通话等</li></ul><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><ol><li>A：你能听到吗？</li><li>B：我能听到，你能听到吗？</li><li>A：我能听到，开始吧</li></ol><ul><li>A 和 B 两方都要能确保：我说的话，你能听到；你说的话，我能听到。所以需要三次握手</li></ul><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><ol><li>A：我说完了</li><li>B：我知道了，等一下，我可能还没说完</li><li>B：我也说完了</li><li>A：我知道了，结束吧</li></ol><ul><li>B 收到 A 结束的消息后 B 可能还没说完，没法立即回复结束标示，只能等说完后再告诉 A ：我说完了</li></ul><h4 id="POST-和-GET-区别"><a href="#POST-和-GET-区别" class="headerlink" title="POST 和 GET 区别"></a>POST 和 GET 区别</h4><ul><li>Get 参数放在 url 中；Post 参数放在 request Body 中</li><li>Get 可能不安全，因为参数放在 url 中</li></ul><h4 id="HTTP-请求过程"><a href="#HTTP-请求过程" class="headerlink" title="HTTP 请求过程"></a>HTTP 请求过程</h4><ol><li>DNS 域名解析</li><li>TCP 三次握手建立连接</li><li>发起 HTTP 请求</li></ol><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ul><li>HTTP 是超文本传输协议，明文传输；HTTPS 使用 SSL 协议对 HTTP 传输数据进行了加密</li><li>HTTP 默认 80 端口；HTTPS 默认 443 端口</li><li>优点：安全</li><li>缺点：费时、SSL 证书收费，加密能力还是有限的，但是比 HTTP 强多了</li><li>加密过程：</li></ul><h4 id="平衡二叉树、二叉查找树、红黑树"><a href="#平衡二叉树、二叉查找树、红黑树" class="headerlink" title="平衡二叉树、二叉查找树、红黑树"></a>平衡二叉树、二叉查找树、红黑树</h4><h1 id="2-Java-基础-amp-容器-amp-同步-amp-设计模式"><a href="#2-Java-基础-amp-容器-amp-同步-amp-设计模式" class="headerlink" title="2.Java 基础&amp;容器&amp;同步&amp;设计模式"></a>2.Java 基础&amp;容器&amp;同步&amp;设计模式</h1><h4 id="StringBuilder、StringBuffer、-、String-concat-链接字符串："><a href="#StringBuilder、StringBuffer、-、String-concat-链接字符串：" class="headerlink" title="StringBuilder、StringBuffer、+、String.concat 链接字符串："></a>StringBuilder、StringBuffer、+、String.concat 链接字符串：</h4><ul><li>StringBuffer 线程安全，StringBuilder 线程不安全</li><li>+实际上是用 StringBuilder 来实现的，所以非循环体可以直接用 +，循环体不行，因为会频繁创建 StringBuilder</li><li>String.concat 实质是 new String ，效率也低，耗时排序：StringBuilder &lt; StringBuffer &lt; concat &lt; +</li></ul><h4 id="Java-泛型擦除"><a href="#Java-泛型擦除" class="headerlink" title="Java 泛型擦除"></a>Java 泛型擦除</h4><ul><li>修饰成员变量等类结构相关的泛型不会被擦除</li><li>容器类泛型会被擦除</li></ul><h4 id="Exception-和-Error"><a href="#Exception-和-Error" class="headerlink" title="Exception 和 Error"></a>Exception 和 Error</h4><ul><li>Exception 和 Error 都继承自 Throwable</li><li>Error 大部分是指不可恢复的错误状态，比如 OOM，所以也不需要捕获</li><li>Exception 分为 CheckedException 和 UnCheckedException<ul><li>CheckedException：必须显式捕获，受编译器检查，比如 io 操作</li><li>UnCheckedException：不用显示捕获，比如空指针、数组越界等</li></ul></li></ul><h4 id="IO-、-NIO、-OKIO"><a href="#IO-、-NIO、-OKIO" class="headerlink" title="IO 、 NIO、 OKIO"></a>IO 、 NIO、 OKIO</h4><ul><li>IO 是面向流的，一次一个字节的处理，NIO 是面向缓冲区的，一次产生或消费一个数据块</li><li>IO 是阻塞的，NIO 是非阻塞的</li><li>NIO 支持内存映射方式</li><li>okio 相比 io 和 nio，api 更简单易用</li><li>okio 支持超时机制</li><li>okio 引入 ByteString 空间换时间提高性能</li><li>okio 采用 segment 机制进行内存共享，节省 copy 时间消耗</li></ul><h4 id="ArrayList、LinkedList"><a href="#ArrayList、LinkedList" class="headerlink" title="ArrayList、LinkedList"></a>ArrayList、LinkedList</h4><ul><li><p>ArrayList</p><ul><li>基于数组实现，查找快：o(1)，增删慢：o(n)</li><li>初始容量为10，扩容通过 System.arrayCopy 方法</li></ul></li><li><p>LinkedList</p><ul><li>基于双向链表实现，查找慢：o(n)，增删快：o(1)</li><li>封装了队列和栈的调用</li></ul></li></ul><h4 id="HashMap-、HashTable、HashSet"><a href="#HashMap-、HashTable、HashSet" class="headerlink" title="HashMap 、HashTable、HashSet"></a>HashMap 、HashTable、HashSet</h4><ul><li><p>HashMap（允许 key/value 为 null）</p><ul><li>基于数组和单向链表实现，数组是 HashMap 的主体；链表是为解决哈希冲突而存在的，存放的是key和value结合的实体</li><li>数组索引通过 key.hashCode（还会二次 hash） 得到，在链表上通过 key.equals 索引</li><li>哈希冲突落在同一个桶中时，直接放在链表头部（java1.8后放到尾部）</li><li>JAVA 8 中链表数量大于 8 时会转为红黑树存储，查找时间由 O(n) 变为 O(logn)</li><li>数组长度总是2的n次方：这样就能通过位运算实现取余，从而让 index 能落在数组长度范围内</li><li>加载因子（默认0.75）表示添加到多少填充比时进行扩容，填充比大：链表较长，查找慢；填充比小：链表短，查找快</li><li>扩容时直接创建原数组两倍的长度，然后将原有对象再进行hash找到新的index，重新放</li></ul></li><li><p>HashTable（不允许 key/value 为 null)</p><ul><li>数据结构和 HashMap 一样</li><li>线程安全</li></ul></li><li><p>HashSet</p><ul><li>基于 HashMap 实现，元素就是 HashMap 的 key，Value 传入了一个固定值</li></ul></li></ul><h4 id="ArrayMap、SparseArray"><a href="#ArrayMap、SparseArray" class="headerlink" title="ArrayMap、SparseArray"></a>ArrayMap、SparseArray</h4><ul><li><p>ArrayMap</p><ul><li>基于两个数组实现，一个存放 hash；一个存放键值对</li><li>存放 hash 的数组是有序的，查找时使用二分法查找</li><li>发生哈希冲突时键值对数组里连续存放，查找时也是通过 key.equals索引，找不到时先向后再向前遍历相同hash值的键值对数组</li><li>扩容时不像 HashMap 直接 double，内存利用率高；也不需要重建哈希表，只需要调用 system.arraycopy 数组拷贝，性能较高</li><li>不适合存大量数据（1000以下），因为数据量大的时候二分查找相比红黑树会慢很多</li></ul></li><li><p>SparseArray</p><ul><li>基于 ArrayMap，key 只能是特定类型</li></ul></li></ul><h4 id="Concurrent-集合"><a href="#Concurrent-集合" class="headerlink" title="Concurrent 集合"></a>Concurrent 集合</h4><ul><li>ConcurrentHashMap<ul><li>数据结构跟 HashMap 一样，还是数组加链表</li><li>采用 segment 分段锁技术，不像 HashTable 无脑直接同步 put 和 get 操作</li><li>get 操作没有加锁，因为 value 用 volatile 修饰来保证可见行，性能很高</li><li>java1.8 后去除分段锁，采用 CAS 乐观锁加 synchronized 来实现</li></ul></li></ul><h4 id="WeakHashMap-原理"><a href="#WeakHashMap-原理" class="headerlink" title="WeakHashMap 原理"></a>WeakHashMap 原理</h4><h4 id="LRUCache-原理"><a href="#LRUCache-原理" class="headerlink" title="LRUCache 原理"></a>LRUCache 原理</h4><ul><li>基于访问顺序排序的 LinkedHashMap 实现，最近访问的会排在最后</li></ul><h4 id="Volatile-关键字"><a href="#Volatile-关键字" class="headerlink" title="Volatile 关键字"></a>Volatile 关键字</h4><ul><li>只能用来修饰变量，适用修饰可能被多线程同时访问的变量</li><li>相当于轻量级的 synchronized，volatitle 能保证有序性（禁用指令重排序）、可见性</li><li>变量位于主内存中，每个线程还有自己的工作内存，变量在自己线程的工作内存中有份拷贝，线程直接操作的是这个拷贝</li><li>被 volatile 修饰的变量改变后会立即同步到主内存，保持变量的可见性<blockquote><p>双重检查单例，为什么要加 violate？<br>volatile想要解决的问题是，在另一个线程中想要使用instance，发现instance!=null，但是实际上instance还未初始化完毕这个问题。将instance =newInstance();拆分为3句话是。1.分配内存2.初始化3.将instance指向分配的内存空间，volatile可以禁止指令重排序，确保先执行2，后执行3</p></blockquote></li></ul><h4 id="wait-和-sleep"><a href="#wait-和-sleep" class="headerlink" title="wait 和 sleep"></a>wait 和 sleep</h4><ul><li>sleep 是 Thread 的静态方法，可以在任何地方调用</li><li>wait 是 Object 的成员方法，只能在 synchronized 代码块中调用，否则会报 IllegalMonitorStateException 非法监控状态异常</li><li>sleep 不会释放共享资源锁，wait 会释放共享资源锁</li></ul><h4 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h4><ul><li>锁池：某个对象的锁已被线程A拥有，其他线程要执行该对象的 synchronized 方法获取锁时就会进入该对象的锁池，锁池中的线程回去竞争该对象的锁</li><li>等待池：某个线程调用了某个对象的 wait 方法，该线程就会释放该对象的锁，进入该对象的等待池，等待池中的线程不会去竞争该对象的锁</li><li>调用 notify 会随机唤醒等待池中的一个线程，唤醒后会进入到锁池</li><li>调用 notifyAll 会唤醒等待池中的所有线程，唤醒后会都进入到锁池</li></ul><h4 id="lock-和-synchronized"><a href="#lock-和-synchronized" class="headerlink" title="lock 和 synchronized"></a>lock 和 synchronized</h4><ul><li>synchronized 是 Java 关键字，内置特性；Lock 是一个接口</li><li>synchronized 会自动释放锁；lock 需要手动释放，所以需要写到 try catch 块中并在 finally 中释放锁</li><li>synchronized 无法中断等待锁；lock 可以中断</li><li>Lock 可以提高多个线程进行读/写操作的效率</li><li>竞争资源激烈时，lock 的性能会明显的优于 synchronized</li></ul><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul><li>定义：已经获取到锁后，再次调用同步代码块/尝试获取锁时不必重新去申请锁，可以直接执行相关代码</li><li>ReentrantLock 和 synchronized 都是可重入锁</li></ul><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><ul><li>定义：等待时间最久的线程会优先获得锁</li><li>非公平锁无法保证哪个线程获取到锁，synchronized 就是非公平锁</li><li>ReentrantLock 默认时非公平锁，可以设置为公平锁</li></ul><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ul><li>悲观锁：线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁<br>乐观锁：假设没有冲突，不加锁，更新数据时判断该数据是否过期，过期的话则不进行数据更新，适用于读取操作频繁的场景</li><li>乐观锁 CAS：Compare And Swap，更新数据时先比较原值是否相等，不相等则表示数据过去，不进行数据更新</li><li>乐观锁实现：AtomicInteger、AtomicLong、AtomicBoolean</li></ul><h4 id="死锁-4-个必要条件"><a href="#死锁-4-个必要条件" class="headerlink" title="死锁 4 个必要条件"></a>死锁 4 个必要条件</h4><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ul><h4 id="Synchronized-原理"><a href="#Synchronized-原理" class="headerlink" title="Synchronized 原理"></a>Synchronized 原理</h4><ul><li>每个对象都有一个监视器锁：monitor，同步代码块会执行  monitorenter 开始，motnitorexit 结束 </li><li>Wait/notify 就依赖 monitor 监视器，所以在非同步代码块中执行会报 IllegalMonitorStateException 异常</li></ul><h4 id="六大原则（DJ单开一里）"><a href="#六大原则（DJ单开一里）" class="headerlink" title="六大原则（DJ单开一里）"></a>六大原则（DJ单开一里）</h4><ul><li>开闭原则：对拓展开放，对修改关闭</li><li>单一指责原则：一个类指责单一</li><li>里氏替换原则：引用基类的地方都能替换成子类对象</li><li>依赖倒置原则：高层次模块不依赖低层次模块的具体实现，抽象不应该依赖细节</li><li>接口隔离原则：类之间的依赖关系应该建立在最小的接口上</li><li>迪米特原则：一个对象对其他对象应该有尽量少的了解</li></ul><h4 id="Java-23-种设计模式（按目的分类为：5-7-11）"><a href="#Java-23-种设计模式（按目的分类为：5-7-11）" class="headerlink" title="Java 23 种设计模式（按目的分类为：5+7+11）"></a>Java 23 种设计模式（按目的分类为：5+7+11）</h4><blockquote><p>1995 年 GoF（四人组）出了一本设计模式的书，收录了 23 种设计模式，树立设计模式里程碑，也叫：GoF 设计模式</p></blockquote><ul><li>创建型（5）：描述怎么创建对象<ul><li>1.单例模式</li><li>2.原型模式：对象的拷贝</li><li>3.建造者模式</li><li>4.工厂模式：建立一个工厂方法来制造新的对象</li><li>5.抽象工厂模式：</li></ul></li><li>结构型（7）：描述如何将类或对象按某种规则组成更大的结构（键盘记忆：qw sd zzx）<ul><li>1.桥接模式：对于两个或以上纬度独立变化的场景，将抽象与具体实现分离，实例：用不同颜色画不同形状</li><li>2.外观模式：对外有一个统一接口，外部不用关心内部子系统的具体实现，这是”迪米特原则”的典型应用</li><li>3.适配器模式：改变类的接口，使原本由于接口不匹配而无法一起工作的两个类能够在一工作，实例：RecycleView 的 Adapter 不管什么类型的 View 都返回 ViewHolder</li><li>4.代理模式：由代理对象控制对原对象的引用，包括静态代理和动态代理</li><li>5.组合模式：将对象组成树形结构，用于对单个对象和组合对象的使用具有一致性，实例：ViewGroup</li><li>6.装饰模式：对对象包装一层，动态的增加一些额外功能，实例：ContextWrapper 包装 Context</li><li>7.享元模式：复用对象，实例：java 的常量池（比如 String），线程池，Message.obtain 等</li></ul></li><li>行为型（11）：描述类或对象之间怎么相互协作，怎样分配指责（记忆：3者 3短 4长 1模版方法）<ul><li>1.观察者模式：一对多依赖关系，多个观察者可以同时监听某一个对象，实例：jetpack 的 lifeCycle 添加生命周期观察者</li><li>2.中介者模式：定义一个中介对象封装一系列对象的交互，解耦这些对象，实例：MVP 的 P</li><li>3.访问者模式：将作用于某数据结构中各元素的操作分离出来封装成独立的类，对这些元素添加新的操作，但不改变原数据结构，实例：asm 中的 classVisitor 中再分别对类注解、变量、方法等进行处理</li><li>4.状态模式：行为由状态决定，不同状态下由不同行为，与策略模式类似，实例：不同状态下有同一种操作的不同行为的子类实现</li><li>5.命令模式：将一个请求封装为一个对象发出，交给别的对象去处理请求，实例：Handler 发送定义好的消息事件</li><li>6.策略模式：将一系列的算法封装起来，方便替换，实例：动画的时间插值器</li><li>7.责任链模式：让多个对象都有机会处理一个事件，实例：View 事件传递机制</li><li>8.备忘录模式：保存对象之前的状态，方便后面恢复</li><li>9.迭代器模式：提供一种方法遍历容器中的元素，而不需要暴露该对象的内部表示，实例：集合的迭代器</li><li>10.解释器模式：多次出现的问题有一定规律，就可以归纳成一种简单的语言来解释，实例：AndroidManifest 文件、GLES 着色器语言</li><li>11.模版方法模式：定义一套固定步骤，方便直接执行，实例：AsyncTask</li></ul></li></ul><h1 id="3-Java-虚拟机-amp-内存结构-amp-GC-amp-类加载-amp-四种引用-amp-动态代理"><a href="#3-Java-虚拟机-amp-内存结构-amp-GC-amp-类加载-amp-四种引用-amp-动态代理" class="headerlink" title="3.Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理"></a>3.Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理</h1><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>定义：可以理解成一个虚构的计算机，解释自己的字节码指令集映射到本地 CPU 或 OS 的指令集，上层只需关注 Class 文件，与操作系统无关，实现跨平台</li><li>Kotlin 就是能解释成 Class 文件，所以可以跑在 JVM 上</li></ul><h4 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h4><ul><li>Java 多线程之间是通过共享内存来通信的，每个线程都有自己的本地内存</li><li>共享变量存放于主内存中，线程会拷贝一份共享变量到本地内存</li><li>volatile 关键字就是给内存模型服务的，用来保证内存可见性和顺序性</li></ul><h4 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h4><ul><li>线程私有：<ul><li>1.程序计数器：记录正在执行的字节码指令地址，若正在执行 Native 方法则为空</li><li>2.虚拟机栈：执行方法时把方法所需数据存为一个栈帧入栈，执行完后出栈</li><li>3.本地方法栈：同虚拟机栈，但是针对的是 Native 方法</li></ul></li><li>线程共享：<ul><li>1.堆：存储 Java 实例，GC 主要区域，分代收集 GC 方法会吧堆划分为新生代、老年代</li><li>2.方法区：存储类信息，常量池，静态变量等数据</li></ul></li></ul><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><ul><li>回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收</li><li>回收类型：<ul><li>1.堆中的对象<ul><li>分代收集 GC 方法会吧堆划分为新生代、老年代</li><li>新生代：新建小对象会进入新生代；通过复制算法回收对象</li><li>老年代：新建大对象及老对象会进入老年代；通过标记-清除算法回收对象</li></ul></li><li>2.方法区中的类信息、常量池</li></ul></li><li>判断一个对象是否可被回收：<ul><li>1.引用计数法<ul><li>缺点：循环引用</li></ul></li><li>2.可达性分析法<ul><li>定义：从 GC ROOT 开始搜索，不可达的对象都是可以被回收的</li><li>GC ROOT ：<ul><li>1.虚拟机栈/本地方法栈中引用的对象</li><li>2.方法区中常量/静态变量引用的对象</li></ul></li></ul></li></ul></li></ul><h4 id="Minor-GC-Major-GC-Full-GC"><a href="#Minor-GC-Major-GC-Full-GC" class="headerlink" title="Minor GC/Major GC/Full GC"></a>Minor GC/Major GC/Full GC</h4><ul><li>Minor GC（Young GC）：即新生代（分为一个 Eden 区和两个 Survivor 区）的垃圾回收<ul><li>Eden 区无用对象被回收，存活对象会移到 Survivor 区</li><li>Survivor 区的存活对象会被复制到另一个 Survivor 区，复制次数也记做年龄，年龄足够大时（15）会移到老年代</li><li>如果 Survivor 区已满，则存活对象会被提前移动到老年代（过早提升），如果老年代也无法容纳，则会触发 Full GC（提升失败）</li><li>老年代的对象可能引用新生代对象，所以这个引用会被作为 GC Roots</li></ul></li><li>Major GC：通常是跟 Full GC 等价的，回收整个堆</li><li>Full GC：回收整个堆，包括新生代和老年代<ul><li>当要在老年代分配空间但无法容纳时触发</li><li>当主动调用 System.gc 时触发</li></ul></li></ul><h4 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h4><ul><li>强引用：不会被回收</li><li>软引用：内存不足时会被回收</li><li>弱引用：gc 时会被回收</li><li>虚引用：无法通过虚引用得到对象，可以监听对象的回收</li></ul><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><ul><li>类的生命周期：<br>1.加载；2.验证；3.准备；4.解析；5.初始化；6.使用；7.卸载</li><li>类加载过程：<br>1.加载：获取类的二进制字节流；生成方法区的运行时存储结构；在内存中生成 Class 对象<br>2.验证：确保该 Class 字节流符合虚拟机要求<br>3.准备：初始化静态变量<br>4.解析：将常量池的符号引用替换为直接引用<br>5.初始化：执行静态块代码、类变量赋值</li><li>类加载时机：<br>1.实例化对象<br>2.调用类的静态方法<br>3.调用类的静态变量（放入常量池的常量除外）</li><li>类加载器：负责加载 class 文件<br>1.引导类加载器 - 没有父类加载器<br>2.拓展类加载器 - 继承自引导类加载器<br>3.系统类加载器 - 继承自拓展类加载器</li><li>双亲委托模型：<ul><li>当要加载一个 class 时，会先逐层向上让父加载器先加载，加载失败才会自己加载</li><li>为什么叫双亲？不考虑自定义加载器，系统类加载器需要网上询问两层，所以叫双亲</li><li>判断是否是同一个类时，除了类信息，还必须时同一个类加载器</li><li>优点：<ul><li>防止重复加载，父加载器加载过了就没必要加载了</li><li>安全，防止篡改核心库类</li></ul></li></ul></li></ul><h4 id="动态代理原理及实现"><a href="#动态代理原理及实现" class="headerlink" title="动态代理原理及实现"></a>动态代理原理及实现</h4><ul><li>InvocationHandler 接口，动态代理类需要实现这个接口</li><li>Proxy.newProxyInstance，用于动态创建代理对象</li><li>Retrofit 应用： Retrofit 通过动态代理，为我们定义的请求接口都生成一个动态代理对象，实现请求</li></ul><h1 id="4-Android-基础-amp-性能优化-amp-Framwork"><a href="#4-Android-基础-amp-性能优化-amp-Framwork" class="headerlink" title="4.Android 基础&amp;性能优化&amp;Framwork"></a>4.Android 基础&amp;性能优化&amp;Framwork</h1><h4 id="Android-解析-XML"><a href="#Android-解析-XML" class="headerlink" title="Android 解析 XML"></a>Android 解析 XML</h4><ul><li>SAX：流式解析</li><li>DOM：先把 XML 全部读取到内存，再访问树形结构，很消耗内存</li><li>PULL：流式解析，Android 内置的默认解析方式</li></ul><h4 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h4><ul><li>A 打开 B 界面，会先执行 A 的 onPause，再执行 B 的 onCreate、onStart、onResume，再执行 A 的 onStop</li><li>B 界面的打开依赖 A 界面 onPause 方法执行完，所以不要在 onPause 中做耗时操作</li></ul><h4 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h4><ul><li>standard 标准模式</li><li>singleTop 栈顶复用模式，<ul><li>推送点击消息界面</li></ul></li><li>singleTask 栈内复用模式，<ul><li>首页</li></ul></li><li>singleInstance 单例模式，单独位于一个任务栈中<ul><li>拨打电话界面</li></ul></li><li>细节：<ul><li>taskAffinity：任务相关性，用于指定任务栈名称，默认为应用包名</li><li>allowTaskReparenting：允许转移任务栈</li></ul></li></ul><h4 id="MeasureSpec-测量规则"><a href="#MeasureSpec-测量规则" class="headerlink" title="MeasureSpec 测量规则"></a>MeasureSpec 测量规则</h4><ul><li>EXACTLY：父 View 指定了子 View 确切的大小</li><li>AT_MOST：父 View 指定一个大小，子 View 不能超过这个值</li><li>UNSPECIFIEND： 父 View 不对子 View 有任何限制</li></ul><h4 id="View-工作原理"><a href="#View-工作原理" class="headerlink" title="View 工作原理"></a>View 工作原理</h4><ul><li>DecorView (FrameLayout)<ul><li>LinearLayout<ul><li>titlebar<ul><li>Content</li><li>调用 setContentView 设置的 View</li></ul></li></ul></li></ul></li></ul><ul><li>ViewRoot 的 performTraversals 方法调用触发开始 View 的绘制，然后会依次调用:<ul><li>performMeasure：遍历 View 的 measure 测量尺寸</li><li>performLayout：遍历 View 的 layout 确定位置</li><li>performDraw：遍历 View 的 draw 绘制</li></ul></li></ul><h4 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h4><ul><li>一个 MotionEvent 产生后，按 Activity -&gt; Window -&gt; decorView -&gt; View 顺序传递，View 传递过程就是事件分发，主要依赖三个方法:</li><li>dispatchTouchEvent：用于分发事件，只要接受到点击事件就会被调用，返回结果表示是否消耗了当前事件</li><li>onInterceptTouchEvent：用于判断是否拦截事件，当 ViewGroup 确定要拦截事件后，该事件序列都不会再触发调用此 ViewGroup 的 onIntercept</li><li>onTouchEvent：用于处理事件，返回结果表示是否处理了当前事件，未处理则传递给父容器处理</li><li>细节：<ul><li>一个事件序列只能被一个 View 拦截且消耗</li><li>View 没有 onIntercept 方法，直接调用 onTouchEvent 处理</li><li>OnTouchListener 优先级比 OnTouchEvent 高，onClickListener 优先级最低</li><li>requestDisallowInterceptTouchEvent 可以屏蔽父容器 onIntercet 方法的调用</li></ul></li></ul><h4 id="Window-、-WindowManager、WMS、SurfaceFlinger"><a href="#Window-、-WindowManager、WMS、SurfaceFlinger" class="headerlink" title="Window 、 WindowManager、WMS、SurfaceFlinger"></a>Window 、 WindowManager、WMS、SurfaceFlinger</h4><ul><li>WIndow：抽象概念不是实际存在的，而是以 View 的形式存在，通过 PhoneWindow 实现</li><li>WindowManager：外界访问 Window 的入口，内部与 WMS 交互是个 IPC 过程</li><li>WMS：管理窗口 Surface 的布局和次序，作为系统级服务单独运行在一个进程</li><li>SurfaceFlinger：将 WMS 维护的窗口按一定次序混合后显示到屏幕上</li></ul><h4 id="View-动画、帧动画及属性动画"><a href="#View-动画、帧动画及属性动画" class="headerlink" title="View 动画、帧动画及属性动画"></a>View 动画、帧动画及属性动画</h4><ul><li>View 动画：<ul><li>作用对象是 View，可用 xml 定义，建议 xml 实现比较易读</li><li>支持四种效果：平移、缩放、旋转、透明度</li></ul></li><li>帧动画：<ul><li>通过 AnimationDrawable 实现，容易 OOM</li></ul></li><li>属性动画：<ul><li>可作用于任何对象，可用 xml 定义，Android 3 引入，建议代码实现比较灵活</li><li>包括 ObjectAnimator、ValuetAnimator、AnimatorSet</li><li>时间插值器：根据时间流逝的百分比计算当前属性改变的百分比<ul><li>系统预置匀速、加速、减速等插值器</li></ul></li><li>类型估值器：根据当前属性改变的百分比计算改变后的属性值<ul><li>系统预置整型、浮点、色值等类型估值器</li></ul></li><li>使用注意事项：<ul><li>避免使用帧动画，容易OOM</li><li>界面销毁时停止动画，避免内存泄漏</li><li>开启硬件加速，提高动画流畅性 ，硬件加速：<ul><li>将 cpu 一部分工作分担给 gpu ，使用 gpu 完成绘制工作</li><li>从工作分摊和绘制机制两个方面优化了绘制速度</li></ul></li></ul></li></ul></li></ul><h4 id="Handler、MessageQueue、Looper-及-postDelayed-原理"><a href="#Handler、MessageQueue、Looper-及-postDelayed-原理" class="headerlink" title="Handler、MessageQueue、Looper 及 postDelayed 原理"></a>Handler、MessageQueue、Looper 及 postDelayed 原理</h4><ul><li>Handler：开发直接接触的类，内部持有 MessageQueue 和 Looper</li><li>MessageQueue：消息队列，内部通过单链表存储消息</li><li>Looper：内部持有 MessageQueue，循环查看是否有新消息，有就处理，没就阻塞</li><li>postDelayed 其实就是调用 postAtTime 实现的，传入的时间戳基于 SystemClock.uptimeMillis，即 boot 时间</li><li>进一步会调用 MessageQueue#enqueueMessage 将消息插入到队列</li><li>插入消息时会根据消息执行时刻 Message#when 来决定插入到什么位置，when 为 0 或最早执行就会插入到链表头，否则按执行时刻排序插入</li><li>插入后如果正在阻塞则会尝试唤醒，插入到头部则会唤醒，插入到队列中则再根据其他条件判断是否需要唤醒</li><li>Looper#loop 中调用 MessageQueue#next 取消息，next 方法除非是即将销毁时会返回 null，否则就会返回消息，没有消息就阻塞。如果当前时刻还没到消息的执行时刻 when，就会再阻塞这个时间差的时间</li><li>阻塞是调用 nativePollOnce 实现，基于 Linux epoll 事件管理机制，主线程不会因为 Looper 阻塞是因为系统每 16ms 会发送一个刷新 UI 消息唤醒 </li><li>Looper#loop 中取出消息后通过 Message#target 拿到 handler，然后调用 Handler#dispatchMessage 分发处理消息</li></ul><h4 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h4><ul><li>MVP：Model：处理数据；View：控制视图；Presenter：分离 Activity 和 Model</li><li>MVVM：Model：处理获取保存数据；View：控制视图；ViewModel：数据容器<ul><li>使用 Jetpack 组件架构的 LiveData、ViewModel 便捷实现 MVVM</li></ul></li></ul><h4 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h4><ul><li>如何感知声明周期：像 Glide 一样给界面添加了无视图的 Fragment</li></ul><h4 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h4><ul><li>界面旋转短暂销毁重建时如何保存 ViewModel ？<ul><li>ViewModel 保存在 ViewModelStore 中</li><li>当 Activity 配置变更销毁时，系统会调用 onRetainNonConfigurationInstance 保存 NonConfigurationInstances，而 ViewModel 就保存在 NonConfigurationInstances 中</li><li>重建时 onCreate 方法通过 getLastNonConfigurationInstance 方法获取到 NonConfigurationInstances，从而获取到 ViewModelStore</li></ul></li></ul><h4 id="Serializable、Parcelable"><a href="#Serializable、Parcelable" class="headerlink" title="Serializable、Parcelable"></a>Serializable、Parcelable</h4><ul><li>Serializable ：Java 序列化方式，适用于存储和网络传输，serialVersionUID 用于确定反序列化和类版本是否一致，不一致时反序列化回失败</li><li>Parcelable ：Android 序列化方式，适用于组件通信数据传递，性能高，因为不像 Serializable 一样有大量反射操作，频繁 GC</li></ul><h4 id="Linux-IPC-方式"><a href="#Linux-IPC-方式" class="headerlink" title="Linux IPC 方式"></a>Linux IPC 方式</h4><ul><li>管道：</li><li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段</li><li>信号：不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等（Android中的Kill Process采用的就是signal（信号）机制）</li><li>消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信</li><li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决</li><li>socket：</li></ul><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><ul><li>Android 中基于 C/S 结构的一种面向对象的进程间通信的机制</li><li>主要用在 system_server 进程与上层 App 层的 IPC 交互</li><li>包含：Client,Server,Binder 驱动和 ServiceManager 四大组成部分</li></ul><h4 id="Android-为什么选择-binder"><a href="#Android-为什么选择-binder" class="headerlink" title="Android 为什么选择 binder"></a>Android 为什么选择 binder</h4><ul><li>性能：使用 mmap 一次数据拷贝实现 IPC，传统 IPC：用户A空间-&gt;内核-&gt;用户B空间；mmap 将内核与用户B空间映射，实现直接从用户A空间-&gt;用户B空间，而 Linux 的管道、消息队列、Socket 都需要拷贝两次，binder 仅次于共享内存</li><li>稳定性：基于C/S架构，架构清晰，稳定性好，不像共享内存实现方式复杂，需要充分考虑访问临界资源的并发同步问题</li><li>安全：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份</li></ul><h4 id="Android-IPC-方式"><a href="#Android-IPC-方式" class="headerlink" title="Android IPC 方式"></a>Android IPC 方式</h4><ul><li>Intent extras、Bundle：要求传递数据能被序列化，实现 Parcelable、Serializable ，适用于四大组件通信</li><li>文件共享：适用于交换简单的数据实时性不高的场景</li><li>AIDL：AIDL 接口实质上是系统提供给我们可以方便实现 BInder 的工具<ul><li>Android Interface Definition Language，可实现跨进程调用方法</li><li>服务端：将暴漏给客户端的接口声明在 AIDL 文件中，创建 Service 实现 AIDL 接口并监听客户端连接请求</li><li>客户端：绑定服务端 Service ，绑定成功后拿到服务端 Binder 对象转为 AIDL 接口调用</li><li>RemoteCallbackList 实现跨进程接口监听，同个 Binder 对象做 key 存储客户端注册的 listener</li><li>监听 Binder 断开：1.Binder.linkToDeath 设置死亡代理；2. onServiceDisconnected 回调</li></ul></li><li>Messenger：基于 AIDL 实现，服务端串行处理，主要用于传递消息，适用于低并发一对多通信</li><li>ContentProvider：基于 Binder 实现，适用于一对多进程间数据共享</li><li>Socket：TCP、UDP，适用于网络数据交换</li></ul><h4 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h4><p><img src="../img/20.jpg" alt></p><ul><li>Linux 内核</li><li>HAL</li><li>本地 Native 库和 Android 运行时环境</li><li>Framework 框架层</li><li>应用层</li></ul><h4 id="Android-系统启动流程"><a href="#Android-系统启动流程" class="headerlink" title="Android 系统启动流程"></a>Android 系统启动流程</h4><ul><li>按电源键 -&gt; 加载引导程序 BootLoader 到 RAM -&gt; 执行 BootLoader 程序启动内核 -&gt; 启动 init 进程 -&gt; 启动 Zygote 和各种守护进程 -&gt;</li><li>启动  System Server 服务进程开启 AMS、WMS 等 -&gt; 启动 Launcher 应用进程</li></ul><h4 id="App-启动流程"><a href="#App-启动流程" class="headerlink" title="App 启动流程"></a>App 启动流程</h4><ul><li>Launcher 中点击一个应用图标 -&gt; 通过 AMS 查找应用进程，若不存在就通过 Zygote 进程 fork </li></ul><h4 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h4><ul><li>进程优先级：1.前台进程 ；2.可见进程；3.服务进程；4.后台进程；5.空进程</li><li>进程被 kill 场景：1.切到后台内存不足时被杀；2.切到后台厂商省电机制杀死；3.用户主动清理</li><li>保活方式：<ul><li>1.Activity 提权：挂一个 1像素 Activity 将进程优先级提高到前台进程</li><li>2.Service 提权：启动一个前台服务（API&gt;18会有正在运行通知栏）</li><li>3.广播拉活</li><li>4.Service 拉活</li><li>5.JobScheduler 定时任务拉活</li><li>6.双进程拉活</li></ul></li></ul><h4 id="网络优化及检测"><a href="#网络优化及检测" class="headerlink" title="网络优化及检测"></a>网络优化及检测</h4><ul><li>速度：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；4.IP 直连省去 DNS 解析时间</li><li>成功率：1.失败重试策略；</li><li>流量：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；5.文件下载断点续传 ；6.缓存</li><li>协议层的优化，比如更优的 http 版本等</li><li>监控：Charles 抓包、Network Monitor 监控流量</li></ul><h4 id="UI卡顿优化"><a href="#UI卡顿优化" class="headerlink" title="UI卡顿优化"></a>UI卡顿优化</h4><ul><li>减少布局层级及控件复杂度，避免过度绘制</li><li>使用 include、merge、viewstub</li><li>优化绘制过程，避免在 Draw 中频繁创建对象、做耗时操作</li></ul><h4 id="内存泄漏场景及规避"><a href="#内存泄漏场景及规避" class="headerlink" title="内存泄漏场景及规避"></a>内存泄漏场景及规避</h4><ul><li>1.静态变量、单例强引跟生命周期相关的数据或资源，包括 EventBus</li><li>2.游标、IO 流等资源忘记主动释放</li><li>3.界面相关动画在界面销毁时及时暂停</li><li>4.内部类持有外部类引用导致的内存泄漏<ul><li>handler 内部类内存泄漏规避：1.使用静态内部类+弱引用 2.界面销毁时清空消息队列</li><li>检测：Android Studio Profiler </li></ul></li></ul><h4 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h4><ul><li>内存问题<ul><li>内存泄漏</li><li>内存抖动：频繁创建临时对象</li><li>Bitmap 大内存：规避位图超标</li><li>代码质量：枚举代替 intdef，使用 SparseArray 代替 Hashmap</li></ul></li><li>检测工具<ul><li>MAT(Memory Analysis Tools) ，可分析 Java 堆数据，可查看实例占用空间、引用关系等</li><li>Android Studio 自带的 Profiler</li><li>LeakCanary</li></ul></li></ul><h4 id="LeakCanary-原理"><a href="#LeakCanary-原理" class="headerlink" title="LeakCanary 原理"></a>LeakCanary 原理</h4><ul><li>通过弱引用和引用队列监控对象是否被回收</li><li>比如 Activity 销毁时开始监控此对象，检测到未被回收则主动 gc ，然后继续监控</li></ul><h4 id="OOM-场景及规避"><a href="#OOM-场景及规避" class="headerlink" title="OOM 场景及规避"></a>OOM 场景及规避</h4><ul><li>加载大图：减小图片</li><li>内存泄漏：规避内存泄漏</li></ul><h4 id="ANR-问题及分析"><a href="#ANR-问题及分析" class="headerlink" title="ANR 问题及分析"></a>ANR 问题及分析</h4><ul><li>anr 分类<ul><li>主线程 5s 内没有处理完输入事件</li><li>service 阻塞 20s</li><li>前台广播阻塞 10s 或后台广告阻塞 20s</li></ul></li><li>anr 发生过程<ul><li>1.捕获到 anr，发送 linux 信号量 3</li><li>2.进程接受到信号量将 anr 信息写入 data/anr/traces.txt 文件</li><li>3.Log 打印 anr 信息</li><li>4.进程进入 anr 状态，弹出 anr 提示框</li></ul></li><li>监控 anr<ul><li>1.Android 5.0 以下监听 traces.txt 文件写入</li><li>2.每隔 5s 向主线程发送消息判断主线程是否阻塞</li></ul></li><li>分析 anr<ul><li>查看 cpu 负载是否是 cpu 资源紧张导致</li><li>查看堆栈看是否是我们的代码耗时过长</li></ul></li><li>避免 anr<ul><li>主线程中不要做耗时操作，注意使用 IntentService </li><li>降低子线程优先级，让主线程可以更多的获取到 cpu 资源</li></ul></li></ul><h1 id="5-Android-模块化-amp-热修复-amp-热更新-amp-打包-amp-混淆-amp-压缩-amp-AOP"><a href="#5-Android-模块化-amp-热修复-amp-热更新-amp-打包-amp-混淆-amp-压缩-amp-AOP" class="headerlink" title="5.Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩&amp;AOP"></a>5.Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩&amp;AOP</h1><h4 id="Dalvik-和-ART"><a href="#Dalvik-和-ART" class="headerlink" title="Dalvik 和 ART"></a>Dalvik 和 ART</h4><ul><li>Dalvik<ul><li>谷歌设计专用于 Android 平台的 Java 虚拟机，可直接运行 .dex 文件，适合内存和处理速度有限的系统 </li><li>JVM 指令集是基于栈的；Dalvik 指令集是基于寄存器的，代码执行效率更优</li></ul></li><li>ART<ul><li>Dalvik 每次运行都要将字节码转换成机器码；ART 在应用安装时就会转换成机器码，执行速度更快</li><li>ART 存储机器码占用空间更大，空间换时间</li></ul></li></ul><h4 id="APK-打包流程"><a href="#APK-打包流程" class="headerlink" title="APK 打包流程"></a>APK 打包流程</h4><ul><li>1.aapt 打包资源文件生成 R.java 文件；aidl 生成 java 文件</li><li>2.将 java 文件编译为 class 文件</li><li>3.将工程及第三方的 class 文件转换成 dex 文件</li><li>4.将 dex 文件、so、编译过的资源、原始资源等打包成 apk 文件</li><li>5.签名</li><li>6.资源文件对齐，减少运行时内存</li></ul><h4 id="App-安装过程"><a href="#App-安装过程" class="headerlink" title="App 安装过程"></a>App 安装过程</h4><ul><li>首先要解压 APK，资源、so等放到应用目录</li><li>Dalvik 会将 dex 处理成 ODEX ；ART 会将 dex 处理成 OAT；</li><li>OAT 包含 dex 和安装时编译的机器码</li></ul><h4 id="瘦包"><a href="#瘦包" class="headerlink" title="瘦包"></a>瘦包</h4><ul><li>1.资源方面：资源在线化、图片使用 webp 格式、tint 着色生成不同色调的切、使用 icon font</li><li>2.so 库：保留一个 cpu 架构的 so 文件</li><li>3.AS Inspect Code 清除无用代码和资源</li><li>4.代码混淆：使用 ProGuard 可以移除无用的类、字段、方法（压缩），移除无用字节码指令 </li><li>5.不保留行号：使用 ProGuard 配置不保留行号 </li><li>6.开启 shrinkResources：移除无用资源 </li><li>7.资源混淆：使用 AndResGuard 缩短资源长度，对资源进行 7z 压缩等（直接对apk操作）</li><li>8.代码结构简化，比如用 intdef 代替 枚举(一个枚举有1~1.4kb大小)</li><li>9.使用 compileOnly 在只需编译时依赖的场景，不会打到 apk 里</li><li>10.使用 thinR 插件剔除 R 文件，将引用 R 字段的地方替换成对应常量</li><li>11.Android 7.0 使用 V2(apksigner) 代替 V1(jarsigner) 签名工具</li><li>12.动态加载 so 库(System.load加载绝对路径文件)、插件化技术、App Bundle</li><li>13.使用 facebook 的 redex</li></ul><h4 id="Android-类加载器"><a href="#Android-类加载器" class="headerlink" title="Android 类加载器"></a>Android 类加载器</h4><ul><li>BootClassLoader(加载 Franwork 级别的类)</li><li>PathClassLoader(加载系统类和 data/app 应用目录下的 dex 文件)</li><li>DexClassLoader(加载自定义的 dex 文件或 jar，支持从 sd 卡中进行加载)</li></ul><h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><ul><li>DexClassLoader 动态加载</li><li>VirtualAPK：动态加载，四大组件未注册问题通过 hook AMS、Instrumentation 等解决</li></ul><h4 id="热修复原理"><a href="#热修复原理" class="headerlink" title="热修复原理"></a>热修复原理</h4><ul><li>Native Hook（AndFix）：直接在 native 层进行方法的结构体信息对换</li><li>分包（QFix）：插入新 dex 到 dexElements[]，利用 ClassLoader 通过遍历 dexElements[] 来 findClass 的特性</li><li>Java Hook（Robust）：hook 每个方法，在每个方法里埋好准备替换的逻辑</li></ul><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><ul><li>ARoute 路由实现：通过 APT 解析 @Route 等注解，结合 JavaPoet 生成路由表，即路由与 Activity 的映射关系</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li>基于 Gradle Transform API 创建 TransForm ，其执行时机在 class 被打包成 dex 之前</li><li>在 TransForm 中通过 javassist 或 asm 修改字节码</li><li>基于 Gradle Plugin API 自定义插件，应用自定义的 TransForm</li></ul><h1 id="6-JNI-amp-音视频-amp-FFmpeg-amp-播放器"><a href="#6-JNI-amp-音视频-amp-FFmpeg-amp-播放器" class="headerlink" title="6.JNI&amp;音视频&amp;FFmpeg&amp;播放器"></a>6.JNI&amp;音视频&amp;FFmpeg&amp;播放器</h1><h4 id="SurfaceView、TextureView、SurfaceTexture、GLSurfaceView"><a href="#SurfaceView、TextureView、SurfaceTexture、GLSurfaceView" class="headerlink" title="SurfaceView、TextureView、SurfaceTexture、GLSurfaceView"></a>SurfaceView、TextureView、SurfaceTexture、GLSurfaceView</h4><ul><li>SurfaceView：使用双缓冲机制，有自己的 surface，在一个独立的线程里绘制，Android7.0之前不能平移、缩放</li><li>TextureView：持有 SurfaceTexture，将图像处理为 OpenGL 纹理更新到 HardwareLayer，必须开启硬件加速，Android5.0之前在主线程渲染，之后有独立的渲染线程，可以平移、旋转、缩放</li><li>SurfaceTexture：将图像流转为 OpenGL 外部纹理，不直接显示</li><li>GLSurfaceView：加入 EGL 管理，自带 GL 上下文和 GL 渲染线程</li></ul><h4 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h4><h4 id="Native-Crash"><a href="#Native-Crash" class="headerlink" title="Native Crash"></a>Native Crash</h4><ul><li>崩溃过程：native crash 时操作系统会向进程发送信号，崩溃信息会写入到 data/tombstones 下，并在 logcat 输出崩溃日志</li><li>定位：so 库剥离调试信息的话，只有相对位置没有具体行号，可以使用 NDK 提供的 addr2line 或 ndk-stack 来定位</li><li>addr2line：根据有调试信息的 so 和相对位置定位实际的代码处</li><li>ndk-stack：可以分析 tombstone 文件，得到实际的代码调用栈</li></ul><h4 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h4><ul><li>基于命令方式实现了一个音视频编辑 App：<a href="https://github.com/yhaolpz/FFmpegCmd" target="_blank" rel="noopener">FFEditor</a></li><li>集成编译了 AAC、MP3、H264 编码器</li></ul><h4 id="播放器原理"><a href="#播放器原理" class="headerlink" title="播放器原理"></a>播放器原理</h4><ul><li>视频播放原理：（mp4、flv）-&gt; 解封装 -&gt; （mp3/aac、h264/h265）-&gt; 解码 -&gt; （pcm、yuv）-&gt; 音视频同步 -&gt; 渲染播放</li><li>音视频同步：<ul><li>选择参考时钟源：音频时间戳、视频时间戳和外部时间三者选择一个作为参考时钟源（一般选择音频，因为人对音频更敏感，ijk 默认也是音频）</li><li>通过等待或丢帧将视频流与参考时钟源对齐，实现同步</li></ul></li></ul><h4 id="IjkPlayer-原理"><a href="#IjkPlayer-原理" class="headerlink" title="IjkPlayer 原理"></a>IjkPlayer 原理</h4><ul><li>集成了 MediaPlayer、ExoPlayer 和 IjkPlayer 三种实现，其中 IjkPlayer 基于 FFmpeg 的 ffplay </li><li>音频输出方式：AudioTrack、OpenSL ES；视频输出方式：NativeWindow、OpenGL ES</li></ul><h1 id="7-AndroidStudio-amp-Lint-amp-gradle-amp-maven-amp-CI-amp-CD"><a href="#7-AndroidStudio-amp-Lint-amp-gradle-amp-maven-amp-CI-amp-CD" class="headerlink" title="7.AndroidStudio&amp;Lint&amp;gradle&amp;maven&amp;CI&amp;CD"></a>7.AndroidStudio&amp;Lint&amp;gradle&amp;maven&amp;CI&amp;CD</h1><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><ul><li>Android Lint是Google提供给Android开发者的静态代码检查工具</li><li>使用Lint对Android工程代码进行扫描和检查，可以发现代码潜在的问题，提醒程序员及早修正</li><li>基于 Detector、IssueRegistry 实现，通过 lintChecks project 引入</li></ul><h4 id="CI-amp-CD"><a href="#CI-amp-CD" class="headerlink" title="CI&amp;CD"></a>CI&amp;CD</h4><ul><li>Continuous integration（持续集成，简称CI）：频繁的将代码集成到主干，防止分支大幅偏离主干，方便快速发现错误</li><li>Continuous delivery（持续交付）：频繁地将软件的新版本，交付给质量团队或者用户，以供评审</li><li>Continuous deployment（持续部署）：持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境</li><li>交付后需要进行构建，将源码转换为可以运行的实际代码，常用的构建工具有 Jenkins、Strider</li></ul><blockquote><h5 id="持续补充中…"><a href="#持续补充中…" class="headerlink" title="持续补充中…"></a>持续补充中…</h5></blockquote><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;1.网络&amp;amp;算法&amp;amp;数据结构&lt;/li&gt;
&lt;li&gt;2.Java 基础&amp;amp;容器&amp;amp;同步&amp;amp;设计模式&lt;/li&gt;
&lt;li&gt;3.Java 虚拟机&amp;amp;内存结构&amp;amp;GC&amp;amp;类加载&amp;amp;四种引用&amp;amp;动态代理&lt;/li&gt;
&lt;li&gt;4.Android 基础&amp;amp;性能优化&amp;amp;Framwork&lt;/li&gt;
&lt;li&gt;5.Android 模块化&amp;amp;热修复&amp;amp;热更新&amp;amp;打包&amp;amp;混淆&amp;amp;压缩&amp;amp;AOP&lt;/li&gt;
&lt;li&gt;6.JNI&amp;amp;音视频&amp;amp;FFmpeg&amp;amp;播放器&lt;/li&gt;
&lt;li&gt;7.AndroidStudio&amp;amp;Lint&amp;amp;gradle&amp;amp;maven&amp;amp;CI&amp;amp;CD&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>对 Android 开发的一点思考</title>
    <link href="http://yhaowa.gitee.io/f713728e/"/>
    <id>http://yhaowa.gitee.io/f713728e/</id>
    <published>2019-04-07T09:17:09.000Z</published>
    <updated>2020-04-07T15:34:42.758Z</updated>
    
    <content type="html"><![CDATA[<p>17 年毕业开始工作到现在已快两个年头，在实际项目开发的过程中，我对 Android 开发有了一些自己的思考。本着碰撞才会有火花、讨论才会进步的理念，我把对 Android 开发的一点思考分享出来，真诚的希望可以有不同的观点，在纠结反驳之中得到最优解，共同进步。</p><a id="more"></a><p>最初的时候，你是否是一个完美主义者，不容忍任何一点 warning 与叹号，if 必有 else，switch 必有 default，即使 else 和 default 中确实什么也不用处理，你也会添加一个 //do nothing 注释，表示这里的逻辑是经过充分考虑的，下次阅读程序时，告诉别人也告诉自己，这里的确什么也不用处理，可以快速跳过。</p><p>我想大多数开发者，都是经历过这种心态的，然后在繁忙的版本迭代中、在赶着回家的加班时、在愈来愈发的对自己的薪水不满时、在一次又一次看到团队中别人得过且过的代码时，渐渐的，就可能对“生活”妥协，丢掉了完美主义。</p><p>然而如果你有更高的追求，就要勇敢的战胜自己的感性。</p><h3 id="使用-IntDef、StringDef"><a href="#使用-IntDef、StringDef" class="headerlink" title="使用 IntDef、StringDef"></a>使用 IntDef、StringDef</h3><p>平时特常用的 View.setVisibility() 方法使用 IntDef 来规定参数的可选项，可以试想一下，假如没用 IntDef 会怎么样？对于初学者来说，可能要稍微阅读一下源码或查下资料才能知道 setVisibility 有哪些参数可以设置。你可能会觉得没什么差，因为你很清楚 setVisibility 方法有哪些参数可以设置。但若是程序中新增的一个方法呢？比如你新接触一个模块，某个界面有若干个跳转 Action，你得先找到定义这些 Action 的地方，而若一不小心将这些 Action 分散写在不同的地方，那对后面的维护和拓展可能就是一个灾难。</p><p>建议凡是符合语义的逻辑，都必须用 IntDef、StringDef 来约束，它比枚举节省内存，性能更优，其 RetentionPolicy.SOURCE 表示此注解只在源码中存在，编译时会剔除。你可以在 Android Studio 的 Live Templates 中添加 IntDef、StringDef 写法：<br><img src="../img/14.jpg" alt></p><h3 id="使用精准表达的变量类型"><a href="#使用精准表达的变量类型" class="headerlink" title="使用精准表达的变量类型"></a>使用精准表达的变量类型</h3><p>比如你需要声明一个变量来表示某个功能是否启用，譬如控制你的 App 是否展示广告，并且可以通过服务端在线下发开关来控制，如果没有接收到下发的开关，就根据地区来决定是否展示。</p><p>这种情况下你会使用什么类型的变量？</p><p>你可能会想到使用一个 int 类型变量来控制，然后需要给这个变量加上注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0：展示； 1：不展示； 2：未接收到在线开关，需要根据地区决定是否展示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mShouldShowAd;</span><br></pre></td></tr></table></figure><p>以后每当改动到这部分逻辑，都需要查看一下这个变量数值对应的含义，随着时间的推移和代码量的增多，在此逻辑之上可能堆积了很多代码，然后就会出现各种各样的问题，别人可能在不存在的逻辑分支做了一些事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mShouldShowAd == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mShouldShowAd == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mShouldShowAd == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可能对这个变量赋值 [0,2] 区间之外的数值！ 你可能对这个变量的意义很了解也绝不会用错，但你不能保证他人不会出现上面所说的荒唐的用法，因为这个变量类型并不能很精准的表达它的语义，也没有任何约束性。</p><p>我们可以怎样改善这种难维护、有风险的代码？</p><ul><li>可以使用 IntDef 规定这个变量的取值</li><li>可以换成 Boolean 类型，用 null 表示未获取到在线开关，恰好的表达语义并且易读、易维护</li></ul><h3 id="使用尽可能少的变量"><a href="#使用尽可能少的变量" class="headerlink" title="使用尽可能少的变量"></a>使用尽可能少的变量</h3><p>举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mDebug = BuildConfig.DEBUG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mDebug) &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你是否写过这样的逻辑？明明已经存在了一个可以直接使用的变量条件，你仍然要重新定义。这个例子逻辑还十分简单，此变量是 final 类型的，不会出错。而如果是非 final 类型的变量，那就是强行增加了一个赋值联动的逻辑，埋下了隐患，后续如果出了问题，白白的增加了定位问题的路径与复杂度。</p><p>实际开发中我们可能自己都意识不到使用了不必要的变量，比如我们的服务端接口一般会有多个接口环境，那你的代码可能是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否是测试环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sIsApiHostTest;</span><br><span class="line"><span class="comment">//是否是beta环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sIsApiHostBeta;</span><br><span class="line"><span class="comment">//正式环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line"><span class="comment">//测试环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line"><span class="comment">//beta环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sIsApiHostTest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sIsApiHostBeta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isApiTest()) &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHostTest;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isApiBeta()) &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHostBeta;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样看起来好像没什么问题，只要维护好 sIsApiHostTest、sIsApiHostBeta 这两个变量就行了。如果后面又添加了一个环境呢？又添加了三四个环境呢？是不是还要维护多个变量？这个逻辑可以通过减少变量来改善：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sCurApiHost;</span><br><span class="line"><span class="comment">//正式环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line"><span class="comment">//测试环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line"><span class="comment">//beta环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sApiHostTest.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sApiHostBeta.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sCurApiHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再加上 StringDef 就完美了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StringDef</span>(&#123;ApiHost.sApiHost, ApiHost.sApiHostTest, ApiHost.sApiHostBeta&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiHost &#123;</span><br><span class="line">    <span class="comment">//正式环境host</span></span><br><span class="line">    String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line">    <span class="comment">//测试环境host</span></span><br><span class="line">    String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line">    <span class="comment">//beta环境host</span></span><br><span class="line">    String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前环境host</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sCurApiHost = ApiHost.sApiHost;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiHost.sApiHostTest.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiHost.sApiHostBeta.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sCurApiHost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setApiHost</span><span class="params">(@ApiHost String apiHost)</span> </span>&#123;</span><br><span class="line">    sCurApiHost = apiHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道你有没有感受到易读性、可维护性、拓展性都蹭蹭蹭的往上涨呢？</p><h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h3><p>同时接受多个数据源数据的逻辑相比只接受一个数据源的数据需要考虑时序性等问题，要复杂很多。打个比方，可以把数据源当作你的直接上级，上级会不定时的分配任务给你做，如果你有多个上级，一个让你做任务 A，一个让你做任务 B，且 A 需要在 B 之前完成，你要怎么办？两个上级都让你做任务 A，但是只用做一次，你要怎么办？</p><p>在安卓中较为典型的场景就是同时加载网络和本地缓存数据到 UI 上，你的 UI 上展示的数据来自不同的地方，你需要考虑不同数据源之间如何协作。谷歌推出的 Jetpack 开发指南上推荐我们使用单一数据源，假如你的网络数据也需要缓存的话，那你的实现逻辑应该是这样：</p><ul><li>加载网络数据，返回后插入到本地<ul><li>统一从本地取数据展示到 UI 上</li></ul></li></ul><p>这点和上面说的“使用尽可能少的变量”有相通之处，都是尽量规避使用多个条件变量对程序产生影响的逻辑。</p><h3 id="职责分离"><a href="#职责分离" class="headerlink" title="职责分离"></a>职责分离</h3><p>强烈建议什么类里就干什么事，别把逻辑都揉到一块儿，这样随着代码量的增加，会愈发的难以维护，到最后就变成一颗存在重大隐患的地雷，看见就头疼。</p><p>举个例子，比如你要自定义一个 View，那就像系统控件一样，只负责一个控件该负责的事，处理一下渲染、展示，把手势交互通过接口开放出来，把数据的获取写在数据仓库中。这样如果数据展示出了问题，可以很快的定位到是数据获取出了问题，还是渲染展示出了问题；如果这个控件的渲染展示是经过验证的，之后就几乎不用改动此控件，至少你有机会可以将你的自定义 View 写的像系统的控件一样稳定。</p><p>这里再推荐一下谷歌的 Jetpack - MVVM 全家桶，MVC 真的是不易读、难维护、问题多、很简陋。</p><h3 id="回归最初的完美主义"><a href="#回归最初的完美主义" class="headerlink" title="回归最初的完美主义"></a>回归最初的完美主义</h3><p>希望你我可以战胜感性，不向“生活”妥协，让优秀成为准则和习惯，回归最初的完美主义。</p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17 年毕业开始工作到现在已快两个年头，在实际项目开发的过程中，我对 Android 开发有了一些自己的思考。本着碰撞才会有火花、讨论才会进步的理念，我把对 Android 开发的一点思考分享出来，真诚的希望可以有不同的观点，在纠结反驳之中得到最优解，共同进步。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="开发模式" scheme="http://yhaowa.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>一个轻量的 Android 端日志打印记录库</title>
    <link href="http://yhaowa.gitee.io/f346f34f/"/>
    <id>http://yhaowa.gitee.io/f346f34f/</id>
    <published>2019-03-31T06:22:56.000Z</published>
    <updated>2020-04-07T15:34:42.801Z</updated>
    
    <content type="html"><![CDATA[<p> 地址：<a href="https://github.com/yhaolpz/PLog" target="_blank" rel="noopener">https://github.com/yhaolpz/PLog</a></p><p><img src="../img/2.jpg" alt></p><p>PLog 即 Persistence Log，可持久化日志于文件，便于还原用户使用场景，解决异常问题。</p><h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><p>1.mmap 方式高效写入，规避 IO 操作带来的性能消耗</p><p>2.兼容多进程并发文件写入，日志文件保存在各自的进程目录下</p><p>3.通过 zip 压缩并加密，节省上报流量，保护日志私密性</p><p>4.内置收集 Activity/Fragment 生命周期、崩溃、网络状态等常用信息：</p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h5 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PLog.Config config = <span class="keyword">new</span> PLog.Config.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .logDir(mLogDirPath) <span class="comment">//日志存放目录，默认优先存储于SD卡</span></span><br><span class="line">        .logcatDebugLevel(PLog.DebugLevel.DEBUG) <span class="comment">//允许输出到Logcat的级别</span></span><br><span class="line">        .recordDebugLevel(PLog.DebugLevel.DEBUG) <span class="comment">//允许记录到日志文件的级别</span></span><br><span class="line">        .fileSizeLimitDay(<span class="number">15</span>) <span class="comment">//单天日志文件存储上限</span></span><br><span class="line">        .overdueDay(<span class="number">3</span>) <span class="comment">//日志文件过期天数</span></span><br><span class="line">        .cipherKey(<span class="string">"123456"</span>) <span class="comment">//日志密钥</span></span><br><span class="line">        .build();</span><br><span class="line">PLog.init(config);</span><br></pre></td></tr></table></figure><h5 id="2-打印"><a href="#2-打印" class="headerlink" title="2.打印"></a>2.打印</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通打印</span></span><br><span class="line">PLog.d(<span class="string">"wyh"</span>, <span class="string">"This is a log that can be recorded in a file"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Format</span></span><br><span class="line">PLog.d(<span class="string">"wyh"</span>, <span class="string">"This is a %s"</span>, <span class="string">"log"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组类型</span></span><br><span class="line">PLog.d(<span class="string">"wyh"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</span><br><span class="line"><span class="comment">//output: [a,b,c]</span></span><br></pre></td></tr></table></figure><h5 id="3-只记录到日志文件"><a href="#3-只记录到日志文件" class="headerlink" title="3.只记录到日志文件"></a>3.只记录到日志文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PLog.record(PLog.DebugLevel.DEBUG,<span class="string">"wyh"</span>,<span class="string">"This is a log that can only be recorded in files"</span>);</span><br></pre></td></tr></table></figure><h5 id="4-只输出到logcat"><a href="#4-只输出到logcat" class="headerlink" title="4.只输出到logcat"></a>4.只输出到logcat</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PLog.print(PLog.DebugLevel.DEBUG,<span class="string">"wyh"</span>,<span class="string">"This is a log"</span>);</span><br></pre></td></tr></table></figure><h5 id="5-触发上传"><a href="#5-触发上传" class="headerlink" title="5.触发上传"></a>5.触发上传</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PLog.upload(<span class="keyword">new</span> UploadListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">(@NonNull List&lt;File&gt; files)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上传到你的服务端</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//建议上传成功及时删除日志文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">             <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                file.delete();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="存储逻辑"><a href="#存储逻辑" class="headerlink" title="存储逻辑"></a>存储逻辑</h2><h4 id="日志文件类型"><a href="#日志文件类型" class="headerlink" title="日志文件类型"></a>日志文件类型</h4><p>为更好的区分并管理日志，将从写入到上传经历不同状态的日志文件划分为以下类型：</p><ul><li>“-mmap” 正在写入的日志文件，不可上传，文件命名为: yyyy-MM-dd-mmap</li><li>“-mmap-up” 写入完成的日志文件，可压缩上传，文件命名为: yyyy-MM-dd-mmap-up</li><li>“-mmap-up-old” 单天较早写入完成的日志大小，可压缩上传，文件命名为: yyyy-MM-dd-mmap-up-old</li><li>“-mmap-up-last” 触发上传时超出存储上限部分的日志文件，上传操作的中间态，不会长久存在，可压缩上传，文件命名为: yyyy-MM-dd-mmap-up-last</li><li>“.zip” 已压缩加密的日志文件，可直接上传，文件命名为: yyyy-MM-dd HH:mm:ss.zip</li></ul><h4 id="控制日志时效"><a href="#控制日志时效" class="headerlink" title="控制日志时效"></a>控制日志时效</h4><p>暂定保留最近三天的日志，更早的日志将会在特定时机自动清除当前进程目录所有类型过期的日志文件，这些时机包括：</p><ul><li>初始化时</li><li>触发上传重命名日志文件添加”-up”时</li><li>触发上传压缩所有标记为”-up”的可上传的日志时</li><li>触发上传扫描所有”.zip”可上传的日志时</li></ul><h4 id="控制存储上限"><a href="#控制存储上限" class="headerlink" title="控制存储上限"></a>控制存储上限</h4><p>理论上我们应该避免无意义的日志记录滥用，控制日志体积，但为避免极端情况下大量日志写入导致存储爆炸，通过将日志文件分为两片控制存储上限。</p><p>譬如规定单天日志存储体积上限为 MAX，逻辑大致为下：</p><ul><li>当天日志文件 -mmap 写入体积达 MAX/3 时就会停止写入，并命名为 -mmap-up，然后新建文件 -mmap 继续写入</li><li>当写入达 MAX/3 时，先将已存在的 -mmap-up 命名为 -mmap-up-old，再将刚写满的 -mmap 命名为 -mmap-up，然后新建文件 -mmap 继续写入</li><li>当写入达 MAX/3 时，先删除 -mmap-up-old 文件，将已存在的 -mmap-up 命名为 -mmap-up-old，再将刚写满的 -mmap 命名为 -mmap-up，然后新建文件 -mmap 继续写入</li></ul><p>按照此逻辑，假定当天写入日志体积为 SIZE，可以将单天日志存储情况划分为以下几种状态：</p><ul><li>a. SIZE &lt; MAX/3</li><li>b. MAX/3 &lt; SIZE &lt; MAX*2/3</li><li>c. MAX*2/3 &lt; SIZE &lt; MAX</li></ul><p>当处于 a 状态时触发上传： -mmap –&gt; -mmap-up –&gt; zip<br>当处于 b 状态时触发上传： -mmap-up –&gt; -mmap-up-old –&gt; zip ;  -mmap –&gt; -mmap-up –&gt; zip<br>当处于 c 状态时触发上传： -mmap-up-old –&gt; zip ;  -mmap-up –&gt; zip ;  -mmap –&gt; -mmap-up-last –&gt; zip</p><p>为了防止频繁的判断日志体积，可设置每隔一定写入条数后判断一次进行优化，目前设置间隔为 1000 条。</p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 地址：&lt;a href=&quot;https://github.com/yhaolpz/PLog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yhaolpz/PLog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/2.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;PLog 即 Persistence Log，可持久化日志于文件，便于还原用户使用场景，解决异常问题。&lt;/p&gt;
&lt;h2 id=&quot;特性：&quot;&gt;&lt;a href=&quot;#特性：&quot; class=&quot;headerlink&quot; title=&quot;特性：&quot;&gt;&lt;/a&gt;特性：&lt;/h2&gt;&lt;p&gt;1.mmap 方式高效写入，规避 IO 操作带来的性能消耗&lt;/p&gt;
&lt;p&gt;2.兼容多进程并发文件写入，日志文件保存在各自的进程目录下&lt;/p&gt;
&lt;p&gt;3.通过 zip 压缩并加密，节省上报流量，保护日志私密性&lt;/p&gt;
&lt;p&gt;4.内置收集 Activity/Fragment 生命周期、崩溃、网络状态等常用信息：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="日志" scheme="http://yhaowa.gitee.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>单例的线程安全及序列化问题</title>
    <link href="http://yhaowa.gitee.io/1516a551/"/>
    <id>http://yhaowa.gitee.io/1516a551/</id>
    <published>2019-03-05T15:04:44.000Z</published>
    <updated>2020-04-07T15:34:42.820Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式可以说是最简单的设计模式了，但在使用时也有一些问题需要注意，比如线程安全性和序列化破坏。本文以几个问题为出发点，分析延迟加载、线程安全以及序列化三个方面，深入了解一下单例模式的各种姿势，以便在今后使用时追求极致性能  ⊙﹏⊙‖∣°</p><a id="more"></a><ul><li>饿汉方式单例到底有多“饿”？</li><li>静态内部类为什么是延迟加载的？</li><li>枚举方式单例是延迟加载的吗？</li><li>饿汉、静态内部类、枚举方式单例为什么是线程安全的？</li><li>序列化为什么会破坏单例模式？</li><li>怎么防止序列化破坏单例模式？</li><li>枚举方式单例是怎么避免序列化破坏的？</li></ul><p>开始正文前先思考下以上问题，如果你都掌握了，就可以点叉出去了。</p><h1 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h1><h4 id="饿汉方式"><a href="#饿汉方式" class="headerlink" title="饿汉方式"></a>饿汉方式</h4><p>先来看一下饿汉方式实现的单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与饿汉方式一并提起的往往还有懒汉方式，对比而言，懒汉方式具有延迟加载（这里的加载指创建 Singleton 实例）的优点。这容易让人对饿汉方式有一个恶劣的刻板印象：它的性能很不好！没有使用它的时候它就会初始化，白白占用资源！</p><p>现在我们来思考一下，饿汉方式单例到底有多“饿”？它到底什么时候会初始化呢？我们知道类加载的时候会初始化静态资源，所以饿汉方式的初始化时机就是类加载时机，回顾一下类加载的时机：</p><ul><li>使用new关键字实例化对象</li><li>调用一个类的静态方法</li><li>读取一个类的静态字段（被 final 修饰已在编译期把结果放在常量池的静态字段除外）</li></ul><p>当使用单例时，往往都是先调用 getInstance() 获取单例，几乎不会涉及其他的静态方法或字段，所以大多数情况下，饿汉方式同懒汉方式一样是延迟加载的！如果你的单例只暴露了 getInstance() 方法（个人感觉也是比较规范的写法），那就放心的使用饿汉方式吧！如果别人 diss 了你的饿汉方式，那就 diss 回去让他去复习类加载机制 &gt;_&lt;||| </p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类方式单例实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比饿汉方式，这种方式实现的单例即使加载了 Singleton 类，也不一定会创建 Singleton 实例，因为 Singleton 的静态引用放到了静态内部类中，只有静态内部类被加载了，Singleton 实例才会被创建。</p><p>如果 Singleton 中对外只暴露了 getInstance 方法，那和饿汉方式无异；如果还暴露了其他的静态方法或字段，那相比饿汉方式，可以更精准的实现延迟加载。</p><h4 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h4><p>枚举方式实现的单例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式或许我们无从下手，但反编译后就明白了，相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，枚举方式实现的单例和饿汉方式差不多，延迟加载时机依赖类加载时机。</p><p>这里需要搞清楚被 static、final 修饰的编译期常量、运行期常量。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>这部分内容其实十分简单。</p><p>类加载的逻辑位于 synchronized 代码块中，是线程安全的，而饿汉、静态内部类以及枚举方式实现的单例初始化都处于类加载时机，所以它们都是线程安全的。</p><p>懒汉方式的初始化与类加载时机无关，所以要自行保证线程安全。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>我们期望单例模式可以实现只创建一个实例，通过特殊手段创建出其他的实例，就对单例模式造成了破坏，序列化就会破坏单例模式。</p><p>假如我们的单例实现了 serializable 接口，序列化时会通过反射调用无参数的构造方法创建一个新的实例，这时就要重写 readResolve 方法防止序列化破坏单例，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止序列化破坏单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的 Java 类的反序列化过程中，会通过反射创建新的实例。而枚举在序列化的时候仅是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf 方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，禁用了writeObject、readObject、readObjectNoData、writeReplace 和 readResolve 等方法。</p><p>枚举的反序列化并不是通过反射实现的，所以也就不会发生由于反序列化导致的单例破坏问题。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>最后集中回答下开头的问题：</p><ul><li>饿汉方式单例到底有多“饿”？<br>大多数情况下，饿汉方式同懒汉方式一样时延迟加载的</li><li>静态内部类为什么是延迟加载的？<br>依赖类加载机制，加载静态内部类时才会初始化</li><li>枚举方式单例是延迟加载的吗？<br>与饿汉方式类似，类加载时初始化</li><li>饿汉、静态内部类、枚举方式单例为什么是线程安全的？<br>因为它们在类加载时初始化，而类加载是线程安全的</li><li>序列化为什么会破坏单例模式？<br>普通的 Java 类的反序列化过程中，会通过反射创建新的实例</li><li>怎么防止序列化破坏单例模式？<br>使用枚举或重写 readResolve 方法</li><li>枚举方式单例是怎么避免序列化破坏的？<br>依赖枚举自身特殊的序列化机制</li></ul><h6 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h6><p><a href="https://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">单例与序列化的那些事儿</a><br><a href="https://www.hollischuang.com/archives/2498" target="_blank" rel="noopener">为什么我墙裂建议大家使用枚举来实现单例</a><br><a href="https://www.hollischuang.com/archives/197" target="_blank" rel="noopener">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a><br><a href="https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized" target="_blank" rel="noopener">stackoverflow：singleton-via-enum-way-is-lazy-initialized</a></p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式可以说是最简单的设计模式了，但在使用时也有一些问题需要注意，比如线程安全性和序列化破坏。本文以几个问题为出发点，分析延迟加载、线程安全以及序列化三个方面，深入了解一下单例模式的各种姿势，以便在今后使用时追求极致性能  ⊙﹏⊙‖∣°&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yhaowa.gitee.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yhaowa.gitee.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yhaowa.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[剑指offer] 机器人走格子之回溯法</title>
    <link href="http://yhaowa.gitee.io/e89c3ed9/"/>
    <id>http://yhaowa.gitee.io/e89c3ed9/</id>
    <published>2019-03-03T12:14:56.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><a id="more"></a><p><strong>核心思路：</strong></p><ol><li>从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 4 个方向的探索值之和。</li><li>探索时，判断当前节点是否可达的标准为：1）当前节点在矩阵内；2）当前节点未被访问过；3）当前节点满足limit限制。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">return</span> countingSteps(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countingSteps</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows || c &lt; <span class="number">0</span> || c &gt;= cols</span><br><span class="line">            || visited[r][c] || bitSum(r) + bitSum(c) &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> countingSteps(limit, rows, cols, r - <span class="number">1</span>, c, visited)</span><br><span class="line">            + countingSteps(limit, rows, cols, r, c - <span class="number">1</span>, visited)</span><br><span class="line">            + countingSteps(limit, rows, cols, r + <span class="number">1</span>, c, visited)</span><br><span class="line">            + countingSteps(limit, rows, cols, r, c + <span class="number">1</span>, visited)</span><br><span class="line">            + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitSum</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="number">0</span>) &#123;</span><br><span class="line">        count += t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;
    
    </summary>
    
      <category term="算法之美" scheme="http://yhaowa.gitee.io/categories/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="剑指offer" scheme="http://yhaowa.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>[剑指offer] 二维数组中的查找</title>
    <link href="http://yhaowa.gitee.io/ff815187/"/>
    <id>http://yhaowa.gitee.io/ff815187/</id>
    <published>2019-02-28T15:03:46.000Z</published>
    <updated>2019-06-28T09:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = array[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] anArray : array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == anArray[<span class="number">0</span>] || target == anArray[len - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; anArray[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; anArray[len - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a : anArray) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
      <category term="算法之美" scheme="http://yhaowa.gitee.io/categories/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="剑指offer" scheme="http://yhaowa.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>简洁明了的刘海屏适配方案</title>
    <link href="http://yhaowa.gitee.io/2f41d4d1/"/>
    <id>http://yhaowa.gitee.io/2f41d4d1/</id>
    <published>2019-02-26T15:11:04.000Z</published>
    <updated>2020-04-07T15:34:42.809Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于刘海屏适配的文章不少，可讲清楚的却没几篇，大多是拷贝文档、长篇大论，甚至热情的贴图告诉你什么是刘海屏，到最后你仍不确定到底是怎样的一个适配方案，才能让你的 app 真正的适配所有的刘海屏机型。</p><p>看到这篇文章你就无需再怨恨各大厂商的跟风“刘海”了，因为刘海屏的适配十分简单。</p><a id="more"></a><p>ok，废话说完了，开始适配。</p><p>首先要清楚的是哪些界面需要适配刘海屏：</p><ul><li>有状态栏的界面：刘海区域会显示状态栏，无需适配</li><li>全屏界面：刘海区域可能遮挡内容，需要适配</li></ul><p>如果你的应用里所有界面都有状态栏，那么恭喜你，你不用做任何操作，状态栏就那么自然的显示在刘海区域，毫无违和，刘海屏已适配完毕，可以点叉出去了。</p><p>不幸的是，你的应用中很大几率会有全屏界面，所谓的刘海屏适配，也正是针对这些全屏界面。</p><p>如果你什么都不做，默认规则不允许全屏界面内容显示到刘海区域，即刘海屏区域会保留一条黑边，你的全屏界面会在刘海下方展示，这看起来好像也是可以接受的，然后你竟说服产品达成共识，“无为而治”才是最强大的刘海屏适配方案！</p><p>但有些手机厂商（譬如oppo）不开心了，我辛辛苦苦研发的刘海屏手机，你们这些开发者竟直接放弃刘海区域！然后就在你的全屏界面下方加了一条提示：“全屏显示”，当用户点击开启后，强行把你的全屏界面显示到刘海区域，然后一切都乱套了…</p><p>嗯～ “无为而治”行不通。</p><p>只能允许全屏界面内容显示到刘海区域了，参考各大厂商的适配文档，我们可以知道如何允许，比如华为机型只需在 AndroidManifest 中配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;android.notch_support&quot;</span><br><span class="line">    android:value=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>配置后，华为机型上的全屏界面就会显示到刘海区域了，但这个刘海，是可能挡住我们全屏界面中的内容的。这时需要将全屏界面中的视图元素适当下移，保证不会被刘海遮挡住，就 ok 了。</p><p>这里我们搞清楚：允许全屏界面内容显示到刘海区域的机型，才需要将全屏界面中的视图元素适当下移。</p><p>比如若只允许华为机型全屏界面内容显示到刘海区域，那只有华为的刘海屏机型才需要将全屏界面中的视图元素适当下移，其他厂商的刘海屏机型则不需要下移。</p><p>如果允许华为、小米、oppo、vivo 全屏界面内容显示到刘海区域，那么华为、小米、oppo、vivo 刘海屏机型需要将全屏界面中的视图元素适当下移。</p><p>另外也不一定要通过全屏界面中的视图元素适当下移方式来适配刘海屏，如果产品形态允许的话，你也可以让该界面显示状态栏啊。</p><p>至此刘海屏适配完毕，是不是很简单！？</p><p>最后代码奉上，拿走不谢：</p><h4 id="允许全屏界面内容显示到刘海区域配置："><a href="#允许全屏界面内容显示到刘海区域配置：" class="headerlink" title="允许全屏界面内容显示到刘海区域配置："></a>允许全屏界面内容显示到刘海区域配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--允许绘制到oppo、vivo刘海屏机型的刘海区域 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;android.max_aspect&quot;</span><br><span class="line">    android:value=&quot;2.2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许绘制到华为刘海屏机型的刘海区域 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;android.notch_support&quot;</span><br><span class="line">    android:value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许绘制到小米刘海屏机型的刘海区域 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;notch.config&quot;</span><br><span class="line">    android:value=&quot;portrait&quot; /&gt;</span><br></pre></td></tr></table></figure><p>上面在 AndroidManifest 的配置在 Android 9.0 之前有效，9.0 系统针对刘海屏制定了新的 api，默认保留一条黑边，即不允许绘制到刘海区域。所以如果你还没有适配 Android 9.0，那在判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型时，就要加上版本判断。</p><h4 id="判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型："><a href="#判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型：" class="headerlink" title="判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型："></a>判断是否是允许全屏界面内容显示到刘海区域的刘海屏机型：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CutoutUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean sAllowDisplayToCutout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为允许全屏界面显示内容到刘海区域的刘海屏机型（与AndroidManifest中配置对应）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">allowDisplayToCutout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sAllowDisplayToCutout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.O_MR1) &#123;</span><br><span class="line">                <span class="comment">// 9.0系统全屏界面默认会保留黑边，不允许显示内容到刘海区域</span></span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutoutDevice = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Context context = App.get();</span><br><span class="line">            <span class="keyword">if</span> (hasCutout_Huawei(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasCutout_OPPO(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasCutout_VIVO(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasCutout_XIAOMI(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sAllowDisplayToCutout = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sAllowDisplayToCutout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是华为刘海屏机型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCutout_Huawei</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Build.MANUFACTURER.equalsIgnoreCase(<span class="string">"HUAWEI"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl = context.getClassLoader();</span><br><span class="line">            Class HwNotchSizeUtil = cl.loadClass(<span class="string">"com.huawei.android.util.HwNotchSizeUtil"</span>);</span><br><span class="line">            <span class="keyword">if</span> (HwNotchSizeUtil != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Method get = HwNotchSizeUtil.getMethod(<span class="string">"hasNotchInScreen"</span>);</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">boolean</span>) get.invoke(HwNotchSizeUtil);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是oppo刘海屏机型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCutout_OPPO</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Build.MANUFACTURER.equalsIgnoreCase(<span class="string">"oppo"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context.getPackageManager().hasSystemFeature(<span class="string">"com.oppo.feature.screen.heteromorphism"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是vivo刘海屏机型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCutout_VIVO</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Build.MANUFACTURER.equalsIgnoreCase(<span class="string">"vivo"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl = context.getClassLoader();</span><br><span class="line">            <span class="meta">@SuppressLint</span>(<span class="string">"PrivateApi"</span>)</span><br><span class="line">            Class ftFeatureUtil = cl.loadClass(<span class="string">"android.util.FtFeature"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ftFeatureUtil != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Method get = ftFeatureUtil.getMethod(<span class="string">"isFeatureSupport"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">boolean</span>) get.invoke(ftFeatureUtil, <span class="number">0x00000020</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是小米刘海屏机型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCutout_XIAOMI</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Build.MANUFACTURER.equalsIgnoreCase(<span class="string">"xiaomi"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl = context.getClassLoader();</span><br><span class="line">            <span class="meta">@SuppressLint</span>(<span class="string">"PrivateApi"</span>)</span><br><span class="line">            Class SystemProperties = cl.loadClass(<span class="string">"android.os.SystemProperties"</span>);</span><br><span class="line">            Class[] paramTypes = <span class="keyword">new</span> Class[<span class="number">2</span>];</span><br><span class="line">            paramTypes[<span class="number">0</span>] = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            paramTypes[<span class="number">1</span>] = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Method getInt = SystemProperties.getMethod(<span class="string">"getInt"</span>, paramTypes);</span><br><span class="line">            <span class="comment">//参数</span></span><br><span class="line">            Object[] params = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">            params[<span class="number">0</span>] = <span class="string">"ro.miui.notch"</span>;</span><br><span class="line">            params[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (Integer) getInt.invoke(SystemProperties, params) == <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到，不一定要通过全屏界面中的视图元素适当下移方式来适配刘海屏，如果产品形态允许的话，也可以让该界面显示状态栏。</p><p>显示状态栏的方案是较为通用简单的，或者说，在一个应用中，一些全屏界面往往是允许使用显示状态栏的方案来适配的，如果你考虑使用这种方案，那便会是这种效果：</p><ul><li>在你的应用中，你期望某些全屏界面在刘海屏机型上必须全屏展示，那你就自行将界面元素适当下移，从而避免被刘海遮挡；而某些全屏界面不是非要全屏显示，允许在刘海屏机型显示状态栏，那就通过显示状态栏的方式，从而避免被刘海遮挡。</li></ul><p>为了实现这种效果，我们需要标记区分哪些界面必须全屏展示、哪些界面允许显示状态栏。这里提供一种实现方式，让允许显示状态栏的界面 Activity 继承一个接口，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CutoutAdapt</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 ActivityLifecycleCallbacks 回调，统一适配允许通过显示状态栏的全屏界面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是允许全屏显示到刘海屏区域的刘海屏机型</span></span><br><span class="line">    <span class="keyword">if</span> (CutoutUtil.allowDisplayToCutout()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFullScreen(activity)) &#123;</span><br><span class="line">            <span class="comment">// 如果允许通过显示状态栏方式适配刘海屏</span></span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> CutoutAdapt) &#123;</span><br><span class="line">                <span class="comment">// 显示状态栏</span></span><br><span class="line">                StatusBarUtil.showStatusbar(activity.getWindow());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 需自行将该界面视图元素下移，否则可能会被刘海遮挡</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非全屏界面无需适配刘海屏</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上关于刘海屏适配的文章不少，可讲清楚的却没几篇，大多是拷贝文档、长篇大论，甚至热情的贴图告诉你什么是刘海屏，到最后你仍不确定到底是怎样的一个适配方案，才能让你的 app 真正的适配所有的刘海屏机型。&lt;/p&gt;
&lt;p&gt;看到这篇文章你就无需再怨恨各大厂商的跟风“刘海”了，因为刘海屏的适配十分简单。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yhaowa.gitee.io/tags/Android/"/>
    
      <category term="刘海屏适配" scheme="http://yhaowa.gitee.io/tags/%E5%88%98%E6%B5%B7%E5%B1%8F%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 展示 gif 原理</title>
    <link href="http://yhaowa.gitee.io/3fe9ef36/"/>
    <id>http://yhaowa.gitee.io/3fe9ef36/</id>
    <published>2019-02-17T10:03:14.000Z</published>
    <updated>2020-04-07T15:34:42.850Z</updated>
    
    <content type="html"><![CDATA[<p>在展示 gif 时，即使不调用 asGif 方法，Glide 也能识别出 gif 类型并正常展示。解码逻辑位于 Downsampler 的 decode 方法中，我们先从这里开始，看看 Glide 是如何识别 gif 类型的。decode 方法中调用了 decodeFromWrappedStreams 方法开始实际解码逻辑：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">decodeFromWrappedStreams</span><span class="params">(InputStream is,</span></span></span><br><span class="line"><span class="function"><span class="params">    BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    DecodeFormat decodeFormat, <span class="keyword">boolean</span> isHardwareConfigAllowed, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> requestedHeight, <span class="keyword">boolean</span> fixBitmapToRequestedDimensions,</span></span></span><br><span class="line"><span class="function"><span class="params">    DecodeCallbacks callbacks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);</span><br><span class="line">  <span class="keyword">int</span> sourceWidth = sourceDimensions[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> sourceHeight = sourceDimensions[<span class="number">1</span>];</span><br><span class="line">  String sourceMimeType = options.outMimeType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap,</span></span><br><span class="line">  <span class="comment">// so we want to use a mutable Bitmap type. One way this can happen is if the image header is so</span></span><br><span class="line">  <span class="comment">// large (10mb+) that our attempt to use inJustDecodeBounds fails and we're forced to decode the</span></span><br><span class="line">  <span class="comment">// full size image.</span></span><br><span class="line">  <span class="keyword">if</span> (sourceWidth == -<span class="number">1</span> || sourceHeight == -<span class="number">1</span>) &#123;</span><br><span class="line">    isHardwareConfigAllowed = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);</span><br><span class="line">  <span class="keyword">int</span> degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);</span><br><span class="line">  <span class="keyword">boolean</span> isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;</span><br><span class="line">  <span class="keyword">int</span> targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;</span><br><span class="line"></span><br><span class="line">  ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略下面的解码逻辑代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到解码开始前，准备了图片角度、输出尺寸的信息，并通过 ImageHeaderParserUtils 获取了图片类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);</span><br></pre></td></tr></table></figure></p><p>Glide 中定义了以下图片类型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The format of the image data including whether or not the image may include transparent</span></span><br><span class="line"><span class="comment"> * pixels.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> ImageType &#123;</span><br><span class="line">  GIF(<span class="keyword">true</span>),</span><br><span class="line">  JPEG(<span class="keyword">false</span>),</span><br><span class="line">  RAW(<span class="keyword">false</span>),</span><br><span class="line">  <span class="comment">/** PNG type with alpha. */</span></span><br><span class="line">  PNG_A(<span class="keyword">true</span>),</span><br><span class="line">  <span class="comment">/** PNG type without alpha. */</span></span><br><span class="line">  PNG(<span class="keyword">false</span>),</span><br><span class="line">  <span class="comment">/** WebP type with alpha. */</span></span><br><span class="line">  WEBP_A(<span class="keyword">true</span>),</span><br><span class="line">  <span class="comment">/** WebP type without alpha. */</span></span><br><span class="line">  WEBP(<span class="keyword">false</span>),</span><br><span class="line">  <span class="comment">/** Unrecognized type. */</span></span><br><span class="line">  UNKNOWN(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> hasAlpha;</span><br><span class="line"></span><br><span class="line">  ImageType(<span class="keyword">boolean</span> hasAlpha) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasAlpha = hasAlpha;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlpha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasAlpha;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而实际获取图片类型的逻辑位于 DefaultImageHeaderParser 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ImageType <span class="title">getType</span><span class="params">(Reader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> firstTwoBytes = reader.getUInt16();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JPEG.</span></span><br><span class="line">  <span class="keyword">if</span> (firstTwoBytes == EXIF_MAGIC_NUMBER) &#123;</span><br><span class="line">    <span class="keyword">return</span> JPEG;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> firstFourBytes = (firstTwoBytes &lt;&lt; <span class="number">16</span> &amp; <span class="number">0xFFFF0000</span>) | (reader.getUInt16() &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">  <span class="comment">// PNG.</span></span><br><span class="line">  <span class="keyword">if</span> (firstFourBytes == PNG_HEADER) &#123;</span><br><span class="line">    <span class="comment">// See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha</span></span><br><span class="line">    <span class="comment">// -color-type</span></span><br><span class="line">    reader.skip(<span class="number">25</span> - <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> alpha = reader.getByte();</span><br><span class="line">    <span class="comment">// A RGB indexed PNG can also have transparency. Better safe than sorry!</span></span><br><span class="line">    <span class="keyword">return</span> alpha &gt;= <span class="number">3</span> ? PNG_A : PNG;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GIF from first 3 bytes.</span></span><br><span class="line">  <span class="keyword">if</span> (firstFourBytes &gt;&gt; <span class="number">8</span> == GIF_HEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span> GIF;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// WebP (reads up to 21 bytes). See https://developers.google.com/speed/webp/docs/riff_container</span></span><br><span class="line">  <span class="comment">// for details.</span></span><br><span class="line">  <span class="keyword">if</span> (firstFourBytes != RIFF_HEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Bytes 4 - 7 contain length information. Skip these.</span></span><br><span class="line">  reader.skip(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> thirdFourBytes =</span><br><span class="line">      (reader.getUInt16() &lt;&lt; <span class="number">16</span> &amp; <span class="number">0xFFFF0000</span>) | (reader.getUInt16() &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">  <span class="keyword">if</span> (thirdFourBytes != WEBP_HEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> fourthFourBytes =</span><br><span class="line">      (reader.getUInt16() &lt;&lt; <span class="number">16</span> &amp; <span class="number">0xFFFF0000</span>) | (reader.getUInt16() &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">  <span class="keyword">if</span> ((fourthFourBytes &amp; VP8_HEADER_MASK) != VP8_HEADER) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((fourthFourBytes &amp; VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_EXTENDED) &#123;</span><br><span class="line">    <span class="comment">// Skip some more length bytes and check for transparency/alpha flag.</span></span><br><span class="line">    reader.skip(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> (reader.getByte() &amp; WEBP_EXTENDED_ALPHA_FLAG) != <span class="number">0</span> ? ImageType.WEBP_A : ImageType.WEBP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((fourthFourBytes &amp; VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_LOSSLESS) &#123;</span><br><span class="line">    <span class="comment">// See chromium.googlesource.com/webm/libwebp/+/master/doc/webp-lossless-bitstream-spec.txt</span></span><br><span class="line">    <span class="comment">// for more info.</span></span><br><span class="line">    reader.skip(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> (reader.getByte() &amp; WEBP_LOSSLESS_ALPHA_FLAG) != <span class="number">0</span> ? ImageType.WEBP_A : ImageType.WEBP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ImageType.WEBP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里是通过文件头标示来获取图片类型的，而 gif 文件头如下：<br><img src="https://upload-images.jianshu.io/upload_images/4679478-588f3a9d994f274a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>查看代码，Glide 中便是通过 0x474946 文件头来判断的。</p><p>Glide 中将 gif 类型图片封装成了 GifDrawable，在 ByteBufferGifDecoder 中可以看到 GifDrawable 的生成逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> GifDrawableResource <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ByteBuffer byteBuffer, <span class="keyword">int</span> width, <span class="keyword">int</span> height, GifHeaderParser parser, Options options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> GifHeader header = parser.parseHeader();</span><br><span class="line">    <span class="keyword">if</span> (header.getNumFrames() &lt;= <span class="number">0</span> || header.getStatus() != GifDecoder.STATUS_OK) &#123;</span><br><span class="line">      <span class="comment">// If we couldn't decode the GIF, we will end up with a frame count of 0.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bitmap.Config config = options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565</span><br><span class="line">        ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sampleSize = getSampleSize(header, width, height);</span><br><span class="line">    GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);</span><br><span class="line">    gifDecoder.setDefaultBitmapConfig(config);</span><br><span class="line">    gifDecoder.advance();</span><br><span class="line">    Bitmap firstFrame = gifDecoder.getNextFrame();</span><br><span class="line">    <span class="keyword">if</span> (firstFrame == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Transformation&lt;Bitmap&gt; unitTransformation = UnitTransformation.get();</span><br><span class="line"></span><br><span class="line">    GifDrawable gifDrawable =</span><br><span class="line">        <span class="keyword">new</span> GifDrawable(context, gifDecoder, unitTransformation, width, height, firstFrame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GifDrawableResource(gifDrawable);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Decoded GIF from stream in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此已经获取到 GifDrawable ，GifDrawable 中持有一个 GifFrameLoader，而 GifFrameLoader 中持有了 gif 解码器 StandardGifDecoder 。由此可以得出 gif 的展示逻辑就封装于 GifDrawable 中，主要通过 GifFrameLoader 实现。</p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在展示 gif 时，即使不调用 asGif 方法，Glide 也能识别出 gif 类型并正常展示。解码逻辑位于 Downsampler 的 decode 方法中，我们先从这里开始，看看 Glide 是如何识别 gif 类型的。decode 方法中调用了 decodeFromWrappedStreams 方法开始实际解码逻辑：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 缩略图使用及原理</title>
    <link href="http://yhaowa.gitee.io/2455213e/"/>
    <id>http://yhaowa.gitee.io/2455213e/</id>
    <published>2019-02-17T08:25:28.000Z</published>
    <updated>2020-04-07T15:34:42.747Z</updated>
    
    <content type="html"><![CDATA[<p>缩略图的使用可参考<a href="https://muyangmin.github.io/glide-docs-cn/doc/options.html#缩略图-thumbnail-请求" target="_blank" rel="noopener">官方文档</a>。</p><p>若使用简化方式设置缩略图：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(imgUrl).thumbnail(<span class="number">0.2f</span>).into(imageView);</span><br></pre></td></tr></table></figure><p>发起缩略图请求的关键逻辑位于 RequestBuilder 的 buildThumbnailRequestRecursive 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.</span></span><br><span class="line">  ThumbnailRequestCoordinator coordinator = <span class="keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);</span><br><span class="line"></span><br><span class="line">  Request fullRequest =</span><br><span class="line">      obtainRequest(</span><br><span class="line">          target,</span><br><span class="line">          targetListener,</span><br><span class="line">          requestOptions,</span><br><span class="line">          coordinator,</span><br><span class="line">          transitionOptions,</span><br><span class="line">          priority,</span><br><span class="line">          overrideWidth,</span><br><span class="line">          overrideHeight);</span><br><span class="line"></span><br><span class="line">  RequestOptions thumbnailOptions = requestOptions.clone()</span><br><span class="line">      .sizeMultiplier(thumbSizeMultiplier);</span><br><span class="line">  Request thumbnailRequest =</span><br><span class="line">      obtainRequest(</span><br><span class="line">          target,</span><br><span class="line">          targetListener,</span><br><span class="line">          thumbnailOptions,</span><br><span class="line">          coordinator,</span><br><span class="line">          transitionOptions,</span><br><span class="line">          getThumbnailPriority(priority),</span><br><span class="line">          overrideWidth,</span><br><span class="line">          overrideHeight);</span><br><span class="line"></span><br><span class="line">  coordinator.setRequests(fullRequest, thumbnailRequest);</span><br><span class="line">  <span class="keyword">return</span> coordinator;</span><br></pre></td></tr></table></figure></p><p>其中 fullRequest、thumbnailRequest 分别为原图、缩略图请求，ThumbnailRequestCoordinator 就是字面意思，专门用于协调原图、缩略图的请求，并合并成一个请求，可以看到在构建缩略图请求时，为了尽量让缩略图比原图加载的更快一点，调用 getThumbnailPriority 方法调整了请求优先级：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Priority <span class="title">getThumbnailPriority</span><span class="params">(@NonNull Priority current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOW:</span><br><span class="line">      <span class="keyword">return</span> Priority.NORMAL;</span><br><span class="line">    <span class="keyword">case</span> NORMAL:</span><br><span class="line">      <span class="keyword">return</span> Priority.HIGH;</span><br><span class="line">    <span class="keyword">case</span> HIGH:</span><br><span class="line">    <span class="keyword">case</span> IMMEDIATE:</span><br><span class="line">      <span class="keyword">return</span> Priority.IMMEDIATE;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unknown priority: "</span> + requestOptions.getPriority());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加载完数据后，Glide 会分别解码缩略图、原图两种尺寸的图片，具体解码实现位于 Downsampler 的 decode 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(InputStream is, <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options, DecodeCallbacks callbacks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Preconditions.checkArgument(is.markSupported(), <span class="string">"You must provide an InputStream that supports"</span></span><br><span class="line">      + <span class="string">" mark()"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();</span><br><span class="line">  bitmapFactoryOptions.inTempStorage = bytesForOptions;</span><br><span class="line"></span><br><span class="line">  DecodeFormat decodeFormat = options.get(DECODE_FORMAT);</span><br><span class="line">  DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);</span><br><span class="line">  <span class="keyword">boolean</span> fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);</span><br><span class="line">  <span class="keyword">boolean</span> isHardwareConfigAllowed =</span><br><span class="line">    options.get(ALLOW_HARDWARE_CONFIG) != <span class="keyword">null</span> &amp;&amp; options.get(ALLOW_HARDWARE_CONFIG);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,</span><br><span class="line">        downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,</span><br><span class="line">        requestedHeight, fixBitmapToRequestedDimensions, callbacks);</span><br><span class="line">    <span class="keyword">return</span> BitmapResource.obtain(result, bitmapPool);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    releaseOptions(bitmapFactoryOptions);</span><br><span class="line">    byteArrayPool.put(bytesForOptions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解码完后会调用到 DecodeJob 的 notifyComplete 方法，进一步调用到 EngineJob 的 onResourceReady 方法，在 onResourceReady 方法中通过 handle 转到主线程，然后调用到 EngineJob 的 handleResultOnMainThread 方法，接着调用 SingleRequest 的 onResourceReady 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// We must call isFirstReadyResource before setting status.</span></span><br><span class="line">   <span class="keyword">boolean</span> isFirstResource = isFirstReadyResource();</span><br><span class="line">   status = Status.COMPLETE;</span><br><span class="line">   <span class="keyword">this</span>.resource = resource;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (glideContext.getLogLevel() &lt;= Log.DEBUG) &#123;</span><br><span class="line">     Log.d(GLIDE_TAG, <span class="string">"Finished loading "</span> + result.getClass().getSimpleName() + <span class="string">" from "</span></span><br><span class="line">         + dataSource + <span class="string">" for "</span> + model + <span class="string">" with size ["</span> + width + <span class="string">"x"</span> + height + <span class="string">"] in "</span></span><br><span class="line">         + LogTime.getElapsedMillis(startTime) + <span class="string">" ms"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   isCallingCallbacks = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">boolean</span> anyListenerHandledUpdatingTarget = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (requestListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (RequestListener&lt;R&gt; listener : requestListeners) &#123;</span><br><span class="line">         anyListenerHandledUpdatingTarget |=</span><br><span class="line">             listener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     anyListenerHandledUpdatingTarget |=</span><br><span class="line">         targetListener != <span class="keyword">null</span></span><br><span class="line">             &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;</span><br><span class="line">       Transition&lt;? <span class="keyword">super</span> R&gt; animation =</span><br><span class="line">           animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">       target.onResourceRReady(result, animation);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     isCallingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   notifyLoadSuccess();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到此方法中终于将加载资源回调给 Target 了，调用栈大致如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/4679478-08af148de8e8a2c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以上不止是设置缩略图时的加载流程，没有缩略图时走的也是这个流程。我们知道图片缩略图不过是通过 BitmapFactory.Options  解码一张尺寸较小、质量较差的图罢了，而 Glide 除了支持配置图片缩略图，还支持配置本地视频缩略图。取视频缩略图的关键逻辑位于 VideoDecoder 的 decodeFrame 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">decodeFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     MediaMetadataRetriever mediaMetadataRetriever,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">long</span> frameTimeMicros,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> frameOption,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> outWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> outHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">     DownsampleStrategy strategy)</span> </span>&#123;</span><br><span class="line">   Bitmap result = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// Arguably we should handle the case where just width or just height is set to</span></span><br><span class="line">   <span class="comment">// Target.SIZE_ORIGINAL. Up to and including OMR1, MediaMetadataRetriever defaults to setting</span></span><br><span class="line">   <span class="comment">// the dimensions to the display width and height if they aren't specified (ie</span></span><br><span class="line">   <span class="comment">// getScaledFrameAtTime is not used). Given that this is an optimization only if</span></span><br><span class="line">   <span class="comment">// Target.SIZE_ORIGINAL is not used and not using getScaledFrameAtTime ever would match the</span></span><br><span class="line">   <span class="comment">// behavior of Glide in all versions of Android prior to OMR1, it's probably fine for now.</span></span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= VERSION_CODES.O_MR1</span><br><span class="line">       &amp;&amp; outWidth != Target.SIZE_ORIGINAL</span><br><span class="line">       &amp;&amp; outHeight != Target.SIZE_ORIGINAL</span><br><span class="line">       &amp;&amp; strategy != DownsampleStrategy.NONE) &#123;</span><br><span class="line">     result =</span><br><span class="line">         decodeScaledFrame(</span><br><span class="line">             mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight, strategy);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">     result = decodeOriginalFrame(mediaMetadataRetriever, frameTimeMicros, frameOption);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在 Android 8.1 系统上支持直接获取缩放的视频缩略图，8.1 以下则直接获取帧原图，分别通过 MediaMetadataRetriever 的 getScaledFrameAtTime 、getFrameAtTime 获取。MediaMetadataRetriever 是 Android 提供的类，用来获取本地和网络 Media 文件信息，提供了用于从输入媒体文件检索帧和元数据的统一接口。</p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缩略图的使用可参考&lt;a href=&quot;https://muyangmin.github.io/glide-docs-cn/doc/options.html#缩略图-thumbnail-请求&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;若使用简化方式设置缩略图：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 请求优先级及原理</title>
    <link href="http://yhaowa.gitee.io/aeb1195c/"/>
    <id>http://yhaowa.gitee.io/aeb1195c/</id>
    <published>2019-02-17T08:24:53.000Z</published>
    <updated>2020-04-07T15:34:42.829Z</updated>
    
    <content type="html"><![CDATA[<p>若一个界面中需要展示多张图片，我们可能会期望某张图片优先加载，这就需要设置 Glide 的请求优先级， Glide 中提供四种优先级：</p><a id="more"></a><ul><li>Priority.LOW</li><li>Priority.NORMAL</li><li>Priority.HIGH</li><li>Priority.IMMEDIATE</li></ul><p>使用十分简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = <span class="keyword">new</span> RequestOptions().priority(Priority.HIGH);</span><br><span class="line">Glide.with(context).load(imgUrl).apply(options).into(imageView);</span><br></pre></td></tr></table></figure></p><p>下面来分析一下我们配置的 Priority.HIGH 到底是如何生效的，跟踪发现优先级参数 priority 会被传入到 RequestBuilder 的 buildThumbnailRequestRecursive 方法，其中主要逻辑如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildThumbnailRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">     RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">     @Nullable RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">     TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">     Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">     RequestOptions requestOptions)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (thumbnailBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 缩略图相关，先忽略</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (thumbSizeMultiplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 缩略图相关，先忽略</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Base case: no thumbnail.</span></span><br><span class="line">     <span class="keyword">return</span> obtainRequest(</span><br><span class="line">         target,</span><br><span class="line">         targetListener,</span><br><span class="line">         requestOptions,</span><br><span class="line">         parentCoordinator,</span><br><span class="line">         transitionOptions,</span><br><span class="line">         priority,</span><br><span class="line">         overrideWidth,</span><br><span class="line">         overrideHeight);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>由于并未设置 thumbnail，先忽略缩略图相关逻辑，此方法中会调用到 obtainRequest 方法，继续跟踪，发现我们配置的 priority 参数在 SingleRequest 中的 onSizeReady 方法中被传入到 Engine 的 load 方法中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">     Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">     Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">     Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">     Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">     Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">     DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">     Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">     Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">     ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// ...省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">   DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">       decodeJobFactory.build(</span><br><span class="line">           glideContext,</span><br><span class="line">           model,</span><br><span class="line">           key,</span><br><span class="line">           signature,</span><br><span class="line">           width,</span><br><span class="line">           height,</span><br><span class="line">           resourceClass,</span><br><span class="line">           transcodeClass,</span><br><span class="line">           priority,</span><br><span class="line">           diskCacheStrategy,</span><br><span class="line">           transformations,</span><br><span class="line">           isTransformationRequired,</span><br><span class="line">           isScaleOnlyOrNoTransform,</span><br><span class="line">           onlyRetrieveFromCache,</span><br><span class="line">           options,</span><br><span class="line">           engineJob);</span><br><span class="line"></span><br><span class="line">   jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">   engineJob.addCallback(cb);</span><br><span class="line">   engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">     logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里在构建 DecodeJob 时将优先级配置传入，最终传入到 DecodeJob 和 DecodeHelper 中，其中 DecodeHelper 被 DecodeJob 持有。</p><p>接下来分析 priority 参数分别在什么时候被用到，首先看 DecodeJob 中持有的 priority，其仅在实现 Comparable 接口时用到，这个比较容易理解，可以通过对 DecodeJob 排序来实现优先级的调整。DecodeHelper 中持有的 priority 在 DataFetcher 的 loadData 方法中被传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority, @NonNull DataCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span></span>;</span><br></pre></td></tr></table></figure><p>DataFetch 用于加载数据，其实现有很多：</p><p><img src="https://upload-images.jianshu.io/upload_images/4679478-f7b5a4e8759e4930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>但并不是所有方法都能应用优先级的，这取决与具体的业务组件，比如 OkHttp 不支持请求优先级设置，直接忽略了 priority 参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull <span class="keyword">final</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder().url(url.toStringUrl());</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : url.getHeaders().entrySet()) &#123;</span><br><span class="line">    String key = headerEntry.getKey();</span><br><span class="line">    requestBuilder.addHeader(key, headerEntry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  Request request = requestBuilder.build();</span><br><span class="line">  <span class="keyword">this</span>.callback = callback;</span><br><span class="line"></span><br><span class="line">  call = client.newCall(request);</span><br><span class="line">  call.enqueue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 Volley 就支持请求优先级：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),</span><br><span class="line">      url.getHeaders());</span><br><span class="line">  requestQueue.add(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此也可以得出设置请求优先级并不是必然生效的。</p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;若一个界面中需要展示多张图片，我们可能会期望某张图片优先加载，这就需要设置 Glide 的请求优先级， Glide 中提供四种优先级：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 图片格式及内存优化</title>
    <link href="http://yhaowa.gitee.io/da1371bf/"/>
    <id>http://yhaowa.gitee.io/da1371bf/</id>
    <published>2019-02-17T08:24:22.000Z</published>
    <updated>2020-04-07T15:34:42.777Z</updated>
    
    <content type="html"><![CDATA[<p>记得刚接触 Glide 时，总会看到这个描述：</p><p><em>Glide 默认的 Bitmap 格式是 RGB_565，相比于 Picasso，加载的图片质量略差，但比 ARGB_8888 格式的内存开销要小一半。</em></p><p>而现在再讲这个特性就不对了，因为在 Glide v4 中，默认的 Bitmap 格式改为了 ARGB_8888。准确来说是默认的解码格式由 PREFER_RGB_565 改为了 PREFER_ARGB_8888，具体可参考 <a href="https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#解码格式" target="_blank" rel="noopener">官方文档</a> 。</p><a id="more"></a><p>Glide 中可配置的解码格式只提供了 PREFER_RGB_565 和 PREFER_ARGB_8888 两个选项，而 Android Bitmap Config 中提供了 RGB_565、ARGB_8888、ARGB_4444 以及 HARDWARE 等 7 种格式，这让我们在使用层面上有一定程度的简化， Glide 内部自行适配了其他解码格式，比如若配置为 PREFER_ARGB_8888，在 Android 8.0 系统上就会尝试开启硬件位图编码格式，对应代码于 DecodeJob 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Options <span class="title">getOptionsWithHardwareConfig</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">  Options options = <span class="keyword">this</span>.options;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) &#123;</span><br><span class="line">    <span class="keyword">return</span> options;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isHardwareConfigSafe =</span><br><span class="line">      dataSource == DataSource.RESOURCE_DISK_CACHE || decodeHelper.isScaleOnlyOrNoTransform();</span><br><span class="line">  Boolean isHardwareConfigAllowed = options.get(Downsampler.ALLOW_HARDWARE_CONFIG);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If allow hardware config is defined, we can use it if it's set to false or if it's safe to</span></span><br><span class="line">  <span class="comment">// use the hardware config for the request.</span></span><br><span class="line">  <span class="keyword">if</span> (isHardwareConfigAllowed != <span class="keyword">null</span> &amp;&amp; (!isHardwareConfigAllowed || isHardwareConfigSafe)) &#123;</span><br><span class="line">    <span class="keyword">return</span> options;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If allow hardware config is undefined or is set to true but it's unsafe for us to use the</span></span><br><span class="line">  <span class="comment">// hardware config for this request, we need to override the config.</span></span><br><span class="line">  options = <span class="keyword">new</span> Options();</span><br><span class="line">  options.putAll(<span class="keyword">this</span>.options);</span><br><span class="line">  options.set(Downsampler.ALLOW_HARDWARE_CONFIG, isHardwareConfigSafe);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档关于 <a href="https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html" target="_blank" rel="noopener">硬件位图</a> 的介绍也比较清晰，就不过多描述了。另外 Android 端涉及到图片内存，必须了解的一个问题就是：<a href="https://zhuanlan.zhihu.com/p/20732309?refer=bennyhuo" target="_blank" rel="noopener">你的 Bitmap 究竟占多大内存？</a></p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得刚接触 Glide 时，总会看到这个描述：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Glide 默认的 Bitmap 格式是 RGB_565，相比于 Picasso，加载的图片质量略差，但比 ARGB_8888 格式的内存开销要小一半。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;而现在再讲这个特性就不对了，因为在 Glide v4 中，默认的 Bitmap 格式改为了 ARGB_8888。准确来说是默认的解码格式由 PREFER_RGB_565 改为了 PREFER_ARGB_8888，具体可参考 &lt;a href=&quot;https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#解码格式&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析 - 加载图片到通知栏和应用小部件中</title>
    <link href="http://yhaowa.gitee.io/693b387a/"/>
    <id>http://yhaowa.gitee.io/693b387a/</id>
    <published>2019-02-17T08:23:48.000Z</published>
    <updated>2020-04-07T15:34:42.754Z</updated>
    
    <content type="html"><![CDATA[<p>上面说到的下载、预加载主要通过 RequestFutureTarget、PreloadTarget 实现，平时使用 Glide 直接加载图片到 ImageView 的方式则是通过 ImageViewTarget，Glide 中还提供了 NotificationTarget 和 AppWidgetTarget 来实现加载图片到通知栏和应用小部件中。使用方法十分简单，下面列出加载图片到通知栏的实现示例：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载图片到通知栏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadNotificationImg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建一个通知栏</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NOTIFICATION_ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> RemoteViews rv = <span class="keyword">new</span> RemoteViews(context.getPackageName(), R.layout.remoteview_notification);</span><br><span class="line">    rv.setImageViewResource(R.id.iv, R.mipmap.ic_launcher);</span><br><span class="line">    rv.setTextViewText(R.id.tv, <span class="string">"Short Message"</span>);</span><br><span class="line">    NotificationCompat.Builder mBuilder =</span><br><span class="line">            <span class="keyword">new</span> NotificationCompat.Builder(context, <span class="string">"channel_id"</span>)</span><br><span class="line">                    .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                    .setContentTitle(<span class="string">"Content Title"</span>)</span><br><span class="line">                    .setContentText(<span class="string">"Content Text"</span>)</span><br><span class="line">                    .setContent(rv)</span><br><span class="line">                    .setPriority(NotificationCompat.PRIORITY_HIGH);</span><br><span class="line">    <span class="keyword">final</span> Notification notification = mBuilder.build();</span><br><span class="line">    notification.bigContentView = rv;</span><br><span class="line">    NotificationManager service = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    service.notify(NOTIFICATION_ID, notification);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载图片到通知栏</span></span><br><span class="line">    NotificationTarget notificationTarget = <span class="keyword">new</span> NotificationTarget(</span><br><span class="line">            context,</span><br><span class="line">            R.id.iv,</span><br><span class="line">            rv,</span><br><span class="line">            notification,</span><br><span class="line">            NOTIFICATION_ID);</span><br><span class="line">    Glide.with(context).asBitmap().load(imgUrl).into(notificationTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的更新方法封装于 NotificationTarget 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Updates the Notification after the Bitmap resource is loaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NotificationManager manager =</span><br><span class="line">      (NotificationManager) <span class="keyword">this</span>.context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">  Preconditions.checkNotNull(manager)</span><br><span class="line">      .notify(<span class="keyword">this</span>.notificationTag, <span class="keyword">this</span>.notificationId, <span class="keyword">this</span>.notification);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 AppWidgetTarget 加载图片到应用小部件中与此类似，这些均继承自  <a href="https://muyangmin.github.io/glide-docs-cn/doc/targets.html" target="_blank" rel="noopener">Target</a> 接口，了解原理后，我们可以自定义 Target 来随意的定制功能了。</p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上面说到的下载、预加载主要通过 RequestFutureTarget、PreloadTarget 实现，平时使用 Glide 直接加载图片到 ImageView 的方式则是通过 ImageViewTarget，Glide 中还提供了 NotificationTarget 和 AppWidgetTarget 来实现加载图片到通知栏和应用小部件中。使用方法十分简单，下面列出加载图片到通知栏的实现示例：&lt;/p&gt;
    
    </summary>
    
      <category term="Glide 源码分析" scheme="http://yhaowa.gitee.io/categories/Glide-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="glide" scheme="http://yhaowa.gitee.io/tags/glide/"/>
    
  </entry>
  
</feed>
