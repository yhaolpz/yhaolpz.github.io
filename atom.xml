<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>what is your main focus for today?</title>
  
  
  <link href="/yhaowa/atom.xml" rel="self"/>
  
  <link href="http://yhaowa.gitee.io/yhaowa/"/>
  <updated>2021-02-11T17:33:17.503Z</updated>
  <id>http://yhaowa.gitee.io/yhaowa/</id>
  
  <author>
    <name>Ahab</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP/IP 网络协议知识点总结</title>
    <link href="http://yhaowa.gitee.io/yhaowa/625d4c7c/"/>
    <id>http://yhaowa.gitee.io/yhaowa/625d4c7c/</id>
    <published>2021-02-08T02:58:16.000Z</published>
    <updated>2021-02-11T17:33:17.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>TCP/IP 模型</li><li>TCP 和 UDP</li><li>TCP 为什么要三次握手</li><li>TCP 为什么要四次挥手</li><li>网页请求一个 URL 的流程</li><li>DNS 工作原理</li><li>HTTPS 加密原理</li><li>TCP 流量与拥塞控制</li><li>HTTP 1.0/1.1/2.0</li><li>QUIC 和 HTTP 3.0</li></ol></blockquote><a id="more"></a><h2 id="1-TCP-IP-模型"><a href="#1-TCP-IP-模型" class="headerlink" title="1. TCP/IP 模型"></a>1. TCP/IP 模型</h2><p><img src="../img/tcp_ip.png" alt></p><p><strong>应用层</strong>：规定应用程序数据格式，处理特定的应用程序细节</p><p><strong>传输层</strong>：指定端口供特定应用程序处理，建立端口到端口的通信</p><p><strong>网络层</strong>：主要负责寻址和路由选择，将数据传输到目标地址，建立主机到主机的通信</p><p><strong>链路层</strong>：数据链路层分为逻辑链路 LLC 子层和介质访问控制 MAC 子层：</p><ul><li><strong>MAC（Media Access Control）</strong>层主要定义了数据包如何在物理介质上传输，包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等，MAC 层的存在屏蔽了不同物理链路的差异性</li><li><strong>LLC（Logic Link Control）</strong>层负责识别网络层协议，为上层提供服务，包括传输可靠性保障和控制、传输可靠性保障和控制、数据包的顺序传输</li></ul><p>在发送数据的时候，MAC 层可以事先判断是否可以发送数据，如果可以则给数据加上一些控制信息，最终将数据以规定格式发送到物理层；在接收数据的时候，MAC 层首先判断是否发生传输错误，如果没有错误，则去掉控制信息后发送至 LLC 层</p><p><strong>物理层</strong>：通过光纤、电缆等设备将计算机连接起来，实现二进制数据的传输</p><h2 id="2-TCP-和-UDP"><a href="#2-TCP-和-UDP" class="headerlink" title="2. TCP 和 UDP"></a>2. TCP 和 UDP</h2><p><img src="../img/tcp.png" alt></p><p><strong>TCP 头结构</strong>：来源端口、目的端口、序号、确认序号、SYN/ACK 等状态位、窗口大小、校验和、紧急指针<br><strong>特点</strong>：面向连接、面向字节流、可靠、有序、速度慢、较重量，流量控制、拥塞控制<br><strong>适用场景</strong>：文件传输、浏览器等<br><strong>应用</strong>：HTTP、HTTPS、RTMP、FTP、SMTP、POP3</p><p><img src="../img/udp.png" alt></p><p><strong>UDP</strong> 头结构：来源端口、目的端口、长度域、校验和<br><strong>特点</strong>：无连接、面向报文、不可靠、无序、速度快、轻量、实时性高（无队首阻塞）<br><strong>适用场景</strong>：适用于一对多、即时通讯、视频通话等<br><strong>应用</strong>：DHCP、DNS、QUCI、VXLAN、GTP-U、TFTP、SNMP</p><h2 id="3-TCP-为什么要三次握手"><a href="#3-TCP-为什么要三次握手" class="headerlink" title="3. TCP 为什么要三次握手"></a>3. TCP 为什么要三次握手</h2><p><img src="../img/tcp1.png" alt></p><p>TCP 的可靠连接建立是靠包起始序列号来达成的，三次握手主要目的是客户端和服务端对各自的包起始序列号达成共识：</p><ul><li>第一次握手：客户端发送 SYN 及<strong>客户端包起始序列号</strong>给服务端</li><li>第二次握手：服务端发送 SYN 及<strong>服务端包起始序列号</strong>给客户端，并且还发送 ACK 及<strong>客户端包起始序列号+1</strong>，表示对<strong>客户端包起始序列号</strong>达成共识</li><li>第三次握手：客户端发送 ACK 及<strong>服务端包起始序列号+1</strong> 给服务端，表示对<strong>服务端包起始序列号</strong>达成共识</li></ul><p>而二次无法达成共识目的，四次则报文数量冗余了</p><p>包序列号可以认为是唯一的，因为它是以时间自增生成的，每四个多小时才会重复一次，远大于报文最大生成时间 MSL</p><h2 id="4-TCP-为什么要四次挥手"><a href="#4-TCP-为什么要四次挥手" class="headerlink" title="4. TCP 为什么要四次挥手"></a>4. TCP 为什么要四次挥手</h2><p><img src="../img/tcp2.png" alt></p><p>TCP 是全双工的，断开需要确保双向都没有数据要发送了：</p><ul><li>第一次挥手：客户端发送 FIN 及<strong>客户端包序列号</strong>给服务端，表示客户端没有数据要发送了</li><li>第二次挥手：服务端发送 ACK 及<strong>客户端包序列号+1</strong> 给客户端，表示对客户端没有数据发送达成了共识</li><li>第三次挥手：服务端发送 FIN 及<strong>服务端包序列号</strong>给客户端，表示服务端没有数据要发送了</li><li>第四次挥手：客户端发送 ACK 及<strong>服务端包序列号+1</strong> 给服务端，表示对五福端没有数据发送达成了共识</li></ul><p>第四次挥手客户端发送 ACK 给服务端后会进入 TIME_WAIT 状态，要等待 2MSL 才真正关闭，两个理由：</p><ul><li>1.要确保客户端发送的 ACK 能达到服务端，让服务端知道客户端收到了第三次挥手，服务端进而可以断开了</li><li>2.要保证本连接中所有的报文都在网络中死翘翘了，防止下个同端口的新连接收到旧连接的报文 </li></ul><h2 id="5-网页请求一个-URL-的流程"><a href="#5-网页请求一个-URL-的流程" class="headerlink" title="5. 网页请求一个 URL 的流程"></a>5. 网页请求一个 URL 的流程</h2><h5 id="1-HTTP-请求的准备"><a href="#1-HTTP-请求的准备" class="headerlink" title="1.HTTP 请求的准备"></a>1.HTTP 请求的准备</h5><ul><li>发起 DNS 请求将域名解析成对应的 IP 地址</li><li>建立 TCP 连接，如果开启了 Keep-Alive 机制，也可在多次请求中复用 TCP 连接</li></ul><h5 id="2-HTTP-请求的构建"><a href="#2-HTTP-请求的构建" class="headerlink" title="2. HTTP 请求的构建"></a>2. HTTP 请求的构建</h5><p><img src="../img/http_1.png" alt></p><p>按照 HTTP 报文格式构建报文，包括：</p><ul><li><strong>请求行</strong>：包括请求方法、URL、HTTP 版本信息，请求方法包括 POST、GET、PUT、DELETE 等</li><li><strong>首部</strong>：包括 Accept-Charset（客户端可以接受的字符集）、Content-Type（正文内容格式）、Cache-control（缓存控制）等</li><li><strong>正文实体</strong>：当使用 POST、PUT 等请求方法时，通常客户端需要向服务器传递数据，这些数据就存储在请求正文中</li></ul><h5 id="3-HTTP-请求的发送"><a href="#3-HTTP-请求的发送" class="headerlink" title="3. HTTP 请求的发送"></a>3. HTTP 请求的发送</h5><p><img src="../img/http.png" alt></p><p>添加 HTTP 头后，报文会经过传输层、网络层、链路层，分别添加上 TCP 头、IP 头和 MAC 头</p><p>然后判断目标地址和本机是否在同个局域网，如果是，就通过 ARP 协议获取目标 MAC 地址，放入 MAC 头；如果不在同个局域网，就把网关 MAC 地址放入 MAC 头</p><p>网关收到包后取出目标 IP 地址，根据路由协议找到下一跳路由器，获取下一跳路由器 MAC 地址，将包发送过去，这样路由器一跳一跳最终到达目标局域网</p><p>最后一跳路由器发现目标地址在自己局域网中，通过 ARP 协议获取目标地址的 MAC 地址，然后将包发送给目标机器</p><p>目标机器接收到包后，层层向上，依次解析 MAC 头、IP 头、TCP 头，最后发送给 TCP 头中端口号对应的 HTTP 服务器进程，然后 HTTP 服务器将网页返回给客户端</p><h5 id="4-HTTP-返回的构建"><a href="#4-HTTP-返回的构建" class="headerlink" title="4. HTTP 返回的构建"></a>4. HTTP 返回的构建</h5><p><img src="../img/http_2.png" alt></p><p>HTTP 返回报文包括：</p><ul><li><strong>状态行</strong>：包括版本、状态码、短语信息，状态码包括 200(OK)、404(Not Found)、503(Service Unavailable) 等等</li><li><strong>首部</strong>：包括 Retry-After（间隔一定时间后可重试）、Content-Type（正文内容格式）等</li><li><strong>正文实体</strong>：返回的数据格式，包括 HTML、JSON 等</li></ul><h2 id="6-DNS-工作原理"><a href="#6-DNS-工作原理" class="headerlink" title="6. DNS 工作原理"></a>6. DNS 工作原理</h2><p><img src="../img/dns2.png" alt></p><p>DNS 服务器包括根域名、顶级域名、权威域名三种：</p><ul><li>根域名 DNS 服务器：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域名 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威域名 DNS 服务器：返回相应主机的 IP 地址</li></ul><p><img src="../img/dns.png" alt></p><p>客户端先在本地缓存中查找是否有域名对应的 IP 地址，如果有直接返回，没有则向本地 DNS 服务器发起请求，本地 DNS 服务器检查是否有缓存，没有则向根域名服务器、顶级域名服务器、权威域名服务器依次发起请求，最终得到域名对应的 IP 地址</p><h2 id="7-HTTPS-加密原理"><a href="#7-HTTPS-加密原理" class="headerlink" title="7. HTTPS 加密原理"></a>7. HTTPS 加密原理</h2><p>HTTPS 通过非对称加密生成密钥，然后用这个密钥去对称加密传输的数据，通过对称加密和非对称加密结合的方式，既保证传输安全，也保证传输效</p><p>非对称加密的私钥不会在互联网上传输，可以保证私钥的私密性，但公钥是公开的，可能被冒充，所以需要通过证书和权威机构来验证公钥的合法性</p><p><img src="../img/CA.png" alt></p><p>服务器需向 CA （Certificate Authority）权威认证机构申请数字证书，CA 用自己的私钥对服务器个人信息与服务器公钥生成数字签名后，再和服务器个人信息与服务器公钥一起形成数字证书</p><p>，客户端需用 CA 的公匙解密数字证书并验证数字证书的合法性</p><p><img src="../img/CA2.png" alt></p><p>客户端发起请求时，服务器会将数字证书发送给客户端，客户端用 CA 公钥解密数字签名生成服务器信息摘要，再和证书中的服务器信息摘要进行对比，以此验证数字证书是否是 CA 颁发的合法证书</p><p>但 CA 的公钥也可能被冒充，为了验证 CA 公钥的合法性，CA 也要有 CA 自身的数字证书，由更可信、更权威的 CA 机构签名生成，由此形成多层级的认证机构，客户端设备默认内置了一部分权威机构的根证书</p><h2 id="8-TCP-流量与拥塞控制"><a href="#8-TCP-流量与拥塞控制" class="headerlink" title="8. TCP 流量与拥塞控制"></a>8. TCP 流量与拥塞控制</h2><h2 id="9-HTTP-1-0-1-1-2-0"><a href="#9-HTTP-1-0-1-1-2-0" class="headerlink" title="9. HTTP 1.0/1.1/2.0"></a>9. HTTP 1.0/1.1/2.0</h2><h2 id="10-QUIC-和-HTTP-3-0"><a href="#10-QUIC-和-HTTP-3-0" class="headerlink" title="10. QUIC 和 HTTP 3.0"></a>10. QUIC 和 HTTP 3.0</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;TCP/IP 模型&lt;/li&gt;
&lt;li&gt;TCP 和 UDP&lt;/li&gt;
&lt;li&gt;TCP 为什么要三次握手&lt;/li&gt;
&lt;li&gt;TCP 为什么要四次挥手&lt;/li&gt;
&lt;li&gt;网页请求一个 URL 的流程&lt;/li&gt;
&lt;li&gt;DNS 工作原理&lt;/li&gt;
&lt;li&gt;HTTPS 加密原理&lt;/li&gt;
&lt;li&gt;TCP 流量与拥塞控制&lt;/li&gt;
&lt;li&gt;HTTP 1.0/1.1/2.0&lt;/li&gt;
&lt;li&gt;QUIC 和 HTTP 3.0&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yhaowa.gitee.io/yhaowa/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://yhaowa.gitee.io/yhaowa/tags/TCP/"/>
    
      <category term="UDP" scheme="http://yhaowa.gitee.io/yhaowa/tags/UDP/"/>
    
      <category term="HTTPS" scheme="http://yhaowa.gitee.io/yhaowa/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Android APT 开发实践</title>
    <link href="http://yhaowa.gitee.io/yhaowa/28077273/"/>
    <id>http://yhaowa.gitee.io/yhaowa/28077273/</id>
    <published>2021-01-05T15:00:30.000Z</published>
    <updated>2021-01-05T16:44:49.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于 APT、JavaPoet，自动生成 Activity/Fragment 对应的 ViewModel.</p></blockquote><a id="more"></a><p>项目界面需求较特殊，需频繁新增 Activity/Fragment，虽基于 ViewModel、LiveData 的 MVVM 模式已将 View 与 Model 彻底解耦，数据获取及处理逻辑可直接复用，但仍存在一些样板代码。</p><p>举个例子，新增一个需要展示用户信息和书籍信息的 MainActivity，那就要新增对应的 ViewModel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> UserDataStore mUserDataStore = <span class="keyword">new</span> UserDataStore();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BookDataStore mBookDataStore = <span class="keyword">new</span> BookDataStore();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserDataStore <span class="title">getUserDataStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mUserDataStore;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BookDataStore <span class="title">getBookDataStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBookDataStore;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何规避编写这样的样板代码呢？想要实现的效果如下，在 MainActivity 中添加注解，列出该界面需使用的 Model：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewModelAutoGen</span>(&#123;</span><br><span class="line">    UserDataStore<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">BookDataStore</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>然后 Make Project 编译一下，自动生成 MainActivityViewModel 类，无需手动编写。</p><p>而基于 APT、JavaPoet 可以实现这个需求，先简单了解下它们。</p><p><strong>APT</strong> 即 Annotation Processing Tool，编译时注解处理器，是 javac 的一个工具，用于编译时扫描和处理注解。通过 APT 可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求自动生成一些代码，省去手动编写。获取注解及生成代码在代码编译期完成，相比反射在运行时处理注解大大提高了程序性能。</p><p><strong>JavaPoet</strong> 是一个辅助生成 Java 源代码的工具库，APT 结合 JavaPoet，可以便捷的生成代码。</p><p>下面来看具体如何实现，首先创建一个 java-library ViewModelAnnotation，在其中定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ViewModelAutoGen &#123;</span><br><span class="line">    Class[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再创建一个 java-library ViewModelAnnotationProcessor ，在其中处理注解，处理类需继承 AbstractProcessor 并添加特定注解标注，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ViewModelAnnotationProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而最关键的代码生成逻辑就在此类中了，代码见 <a href="https://github.com/yhaolpz/AptSample/blob/master/ViewModelAnnotationProcessor/src/main/java/com/wyh/viewmodel/annotation/processor/ViewModelAnnotationProcessor.java" target="_blank" rel="noopener">ViewModelAnnotationProcessor.java</a>。</p><p>外部导入时需通过 <strong>annotationProcessor</strong> 使其支持编译时注解处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">annotationProcessor <span class="title">project</span><span class="params">(<span class="string">':ViewModelAnnotationProcessor'</span>)</span></span></span><br><span class="line"><span class="function">    implementation <span class="title">project</span><span class="params">(<span class="string">':ViewModelAnnotation'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>完整 Sample 见 <a href="https://github.com/yhaolpz/AptSample" target="_blank" rel="noopener">https://github.com/yhaolpz/AptSample</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基于 APT、JavaPoet，自动生成 Activity/Fragment 对应的 ViewModel.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/yhaowa/categories/Android/"/>
    
    
      <category term="APT" scheme="http://yhaowa.gitee.io/yhaowa/tags/APT/"/>
    
      <category term="JavaPoet" scheme="http://yhaowa.gitee.io/yhaowa/tags/JavaPoet/"/>
    
      <category term="ViewModel" scheme="http://yhaowa.gitee.io/yhaowa/tags/ViewModel/"/>
    
  </entry>
  
  <entry>
    <title>Android Handler epoll 机制分析</title>
    <link href="http://yhaowa.gitee.io/yhaowa/649d55e5/"/>
    <id>http://yhaowa.gitee.io/yhaowa/649d55e5/</id>
    <published>2020-11-15T04:25:14.000Z</published>
    <updated>2020-12-06T09:24:52.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>IO 多路复用</li><li>select、poll、epoll 对比</li><li>epoll API</li><li>epoll 使用示例</li><li>eventfd</li><li>Handler 中的 epoll 源码分析<ol><li>nativePollOnce</li><li>nativePollOnce</li><li>nativeWake</li></ol></li></ol></blockquote><a id="more"></a><h3 id="1-IO-多路复用"><a href="#1-IO-多路复用" class="headerlink" title="1. IO 多路复用"></a>1. IO 多路复用</h3><p>IO 多路复用是一种同步 IO 模型，实现一个线程可以监视多个文件句柄。一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作，没有文件句柄就绪时会阻塞应用程序，交出 cpu。</p><p>与多进程和多线程技术相比，IO 多路复用技术的最大优势是系统开销小，系统不必为每个 IO 操作都创建进程或线程，也不必维护这些进程或线程，从而大大减小了系统的开销。</p><p>select、poll、epoll 就是 IO 多路复用三种实现方式。</p><h3 id="2-select、poll、epoll-对比"><a href="#2-select、poll、epoll-对比" class="headerlink" title="2. select、poll、epoll 对比"></a>2. select、poll、epoll 对比</h3><p>select 最大连接数为进程文件描述符上限，一般为 1024；每次调用 select 拷贝 fd；轮询方式工作时间复杂度为 O(n)</p><p>poll 最大连接数无上限；每次调用 poll 拷贝 fd；轮询方式工作时间复杂度为 O(n)</p><p>epoll 最大连接数无上限；首次调用 epoll_ctl 拷贝 fd，调用 epoll_wait 时不拷贝；回调方式工作时间复杂度为 O(1)</p><h3 id="3-epoll-API"><a href="#3-epoll-API" class="headerlink" title="3. epoll API"></a>3. epoll API</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epoll_create(<span class="keyword">int</span> size);</span><br></pre></td></tr></table></figure><p>创建 eventpoll 对象，并将 eventpoll 对象放到 epfd 对应的 file-&gt;private_data 上，返回一个 epfd，即 eventpoll 句柄。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epoll_ctl(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event) <span class="comment">//返回值：成功 0；失败 -1</span></span><br></pre></td></tr></table></figure><p>对一个 epfd 进行操作。op 表示要执行的操作，包括 EPOLL_CTL_ADD (添加)、EPOLL_CTL_DEL (删除)、EPOLL_CTL_MOD (修改)；fd 表示被监听的文件描述符；event 表示要被监听的事件，包括：</p><ul><li>EPOLLIN（表示被监听的fd有可以读的数据）</li><li>EPOLLOUT（表示被监听的fd有可以写的数据）</li><li>EPOLLPRI（表示有可读的紧急数据）</li><li>EPOLLERR（对应的fd发生异常）</li><li>EPOLLHUP（对应的fd被挂断）</li><li>EPOLLET（设置EPOLL为边缘触发）</li><li>EPOLLONESHOT（只监听一次）</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epoll_wait(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout) <span class="comment">//返回值：监听到的产生的事件数</span></span><br></pre></td></tr></table></figure><p>等待 epfd 监听的 fd 所产生对应的事件。epfd 表示 epoll句柄；events 表示回传处理事件的数组；maxevents 表示每次能处理的最大事件数；timeout：等待 IO 的超时时间，-1 表示一直阻塞直到来 IO 被唤醒，大于 0 表示阻塞指定的时间后被唤醒</p><h3 id="4-epoll-使用示例"><a href="#4-epoll-使用示例" class="headerlink" title="4. epoll 使用示例"></a>4. epoll 使用示例</h3><p>创建一个管道，使用 epoll 监听管道读端，然后进入阻塞：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pipFd[<span class="number">2</span>];</span><br><span class="line">pipe(pipFd); <span class="comment">//打开管道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> epoll_event event;</span><br><span class="line">event.data.fd = pipFd[<span class="number">0</span>]; <span class="comment">//设置为监听管道读端</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET; <span class="comment">//设置参数，接收可以 read() 的通知</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">256</span>); <span class="comment">//创建 epoll 对象</span></span><br><span class="line"><span class="keyword">int</span> res = epoll_ctl(epfd, EPOLL_CTL_ADD, pipFd[<span class="number">0</span>], &amp;event); <span class="comment">//添加管道读端为要监听的文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> epoll_event allEvs[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> count = epoll_wait(epfd, allEvs, <span class="number">256</span>, <span class="number">5000</span>); <span class="comment">//当前线程进入阻塞，等待被唤醒</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123; <span class="comment">//被唤醒，处理触发唤醒文件描述符</span></span><br><span class="line">    <span class="keyword">if</span>(allEvs[i].data.fd == pipFd[<span class="number">0</span>] &amp;&amp; (allEvs[i].events &amp; EPOLLIN))&#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">        read(pipeFd, buffer, <span class="number">100</span>); <span class="comment">//接收到管道可以进行读的信号，开始读取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他线程写入管道，通知唤醒：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(pipFd[<span class="number">1</span>], str,strlen(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure></p><h3 id="5-eventfd"><a href="#5-eventfd" class="headerlink" title="5. eventfd"></a>5. eventfd</h3><p>eventfd 是 Linux 系统中一个用来通知事件的文件描述符，基于内核向用户空间应用发送通知的机制，可以有效地被用来实现用户空间事件驱动的应用程序。</p><p>简而言之：eventfd 就是用来触发事件通知，它只有一个系统调用接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eventfd</span><span class="params">(unsigned <span class="keyword">int</span> initval, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>表示打开一个 eventfd 文件并返回文件描述符，支持 epoll/poll/select 操作。</p><p>之所以要在介绍 Handler native 源码前先介绍 eventfd，是因为在 Android 6.0 后，Handler 底层替换为 eventfd/epoll 实现。而 6.0 之前是由 pipe/epoll 实现的，就像上面的 epoll 使用示例那样。</p><h3 id="6-Handler-中的-epoll-源码分析"><a href="#6-Handler-中的-epoll-源码分析" class="headerlink" title="6. Handler 中的 epoll 源码分析"></a>6. Handler 中的 epoll 源码分析</h3><p>主要分析 MessageQueue.java 中的三个 native 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>; <span class="comment">//返回 ptr</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; <span class="comment">//阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>; <span class="comment">//唤醒</span></span><br></pre></td></tr></table></figure><h5 id="1-nativeInit"><a href="#1-nativeInit" class="headerlink" title="1. nativeInit"></a>1. nativeInit</h5><p>首先来看 nativeInit 方法，nativeInit 在 MessageQueue 构造函数中被调用，其返回了一个底层对象的指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应实现在 android_os_MessageQueue.cpp 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 MessageQueue 对应的底层对象就是 NativeMessageQueue，而 NativeMessageQueue 初始化时会创建一个底层的 Looper 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == NULL) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="keyword">false</span>);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，可以知道 Looper 对象是 ThreadLocal 类型。Looper 的构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(bool allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), ...&#123;</span><br><span class="line">    mWakeEventFd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    ...</span><br><span class="line">    rebuildEpollLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 eventfd 系统调用返回一个文件描述符，专门用于事件通知。接着来看 rebuildEpollLocked 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    struct epoll_event eventItem;</span><br><span class="line">    memset(&amp; eventItem, <span class="number">0</span>, sizeof(epoll_event));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd;</span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们已经熟悉的 epoll 操作了： 通过 epoll_create 创建 epoll 对象，然后调用 epoll_ctl 添加 mWakeEventFd 为要监听的文件描述符。</p><h5 id="2-nativePollOnce"><a href="#2-nativePollOnce" class="headerlink" title="2. nativePollOnce"></a>2. nativePollOnce</h5><p>之前学习 Handler 机制时多次看到过 nativePollOnce 方法，也知道它会进入休眠，下面就来彻底搞懂它的原理。对应的底层调用同样是在 android_os_MessageQueue.cpp 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实现同样是在 Looper.cpp 中，接着来看 Looper 的 pollOnce 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>至此通过调用 epoll_wait 方法，当前线程进入休眠，等待被唤醒。</p><h5 id="3-nativeWake"><a href="#3-nativeWake" class="headerlink" title="3. nativeWake"></a>3. nativeWake</h5><p>最后来看如何通过 nativeWake 唤醒线程，首先是 android_os_MessageQueue.cpp 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 nativeInit、nativePollOnce 一样，最终实现都是在 Looper.cpp 中，Looper 的 wake 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">    uint64_t inc = <span class="number">1</span>;</span><br><span class="line">    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != sizeof(uint64_t)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"Could not write wake signal to fd %d: %s"</span>,</span><br><span class="line">                    mWakeEventFd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关键逻辑是对 mWakeEventFd 发起写入操作，从而唤醒 nativePollOnce 中通过 epoll_wait 进入休眠的线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;IO 多路复用&lt;/li&gt;
&lt;li&gt;select、poll、epoll 对比&lt;/li&gt;
&lt;li&gt;epoll API&lt;/li&gt;
&lt;li&gt;epoll 使用示例&lt;/li&gt;
&lt;li&gt;eventfd&lt;/li&gt;
&lt;li&gt;Handler 中的 epoll 源码分析&lt;ol&gt;
&lt;li&gt;nativePollOnce&lt;/li&gt;
&lt;li&gt;nativePollOnce&lt;/li&gt;
&lt;li&gt;nativeWake&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="handler" scheme="http://yhaowa.gitee.io/yhaowa/tags/handler/"/>
    
      <category term="epoll" scheme="http://yhaowa.gitee.io/yhaowa/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>开发编写的 View 控件，是怎么变成屏幕上图像的？</title>
    <link href="http://yhaowa.gitee.io/yhaowa/f9fd2518/"/>
    <id>http://yhaowa.gitee.io/yhaowa/f9fd2518/</id>
    <published>2020-11-08T06:24:57.000Z</published>
    <updated>2021-01-03T14:31:26.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>Activity 与 Window<ol><li>setContentView 原理</li><li>Activity 窗口添加过程</li></ol></li><li>UI 刷新机制<ol><li>发起 UI 重绘请求</li><li>执行 UI 绘制时机</li><li>vsync 信号的生成</li><li>vsync 信号的分发<ol><li>SurfaceFlinger -&gt; DispSync</li><li>DispSync -&gt; DispSyncSource</li><li>DispSyncSource -&gt; EventThread</li><li>Connection -&gt; SurfaceFlinger </li><li>Connection -&gt; app</li></ol></li></ol></li><li>UI 绘制流程</li><li>Surface 原理<ol><li>Surface 创建流程</li><li>Surface 的跨进程传递</li><li>GraphicBufferProducer</li></ol></li></ol></blockquote><a id="more"></a><h1 id="1-Activity-与-Window"><a href="#1-Activity-与-Window" class="headerlink" title="1. Activity 与 Window"></a>1. Activity 与 Window</h1><h2 id="1-setContentView-原理"><a href="#1-setContentView-原理" class="headerlink" title="1. setContentView 原理"></a>1. setContentView 原理</h2><p>Activity 中将 setContentView 工作交给了 Window 对象去处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 Activity 内部都持有一个 Window 对象，而 Window 对象是在创建 Activity 流程中 attach 时就实例化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PhoneWindow 中会实际去 inflate 布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 installDecor 中伪代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = <span class="keyword">new</span> DecorView(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = (ViewGroup)mDecor.findViewById(R.id.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 Activity 内部都持有一个 window 对象，其实现为 PhoneWindow，在 Activity attachContext 时创建。</p><p>PhoneWindow 的根布局为 DecorView，其包括 TitleView 和 ContentView，Activity 的 setContentView 就是把布局添加到 ContentView。</p><h2 id="2-Activity-窗口添加过程"><a href="#2-Activity-窗口添加过程" class="headerlink" title="2. Activity 窗口添加过程"></a>2. Activity 窗口添加过程</h2><p>setContentView 只是创建好了 View 视图结构，还没告知 WMS。在 ActivityThread handleResumeActivity 方法中，才会与 WMS 通信开始添加 Activity 窗口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, ...);</span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">    &#125;</span><br><span class="line">    r.activity.makeVisible();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 performResumeActivity 方法会回调 onResume 生命周期，之后调用 WindowManager 的 addView 方法并将 DecorView 传入。这里的 WindowManager 为 WindowManagerImpl 对象，与 Activity 内部的 window 一样，都是在 Activity attachContext 时创建。</p><p>WindowManagerImpl 中 addView 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其进一步交给了 mGlobal 即 WindowManagerGlobal 去处理，接着来看 WindowManagerGlobal 的 addView 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">            mRoots.get(index).doDie();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                    + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ViewRootImpl root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 WindowManagerGlobal 为进程单例，其内部的 mViews 则记录了全局添加的 View。当重复添加 View 时，就会抛出 “View has already been added to the window manager” 异常。</p><p>接着创建一个与 View 对应的 ViewRootImpl，将 View、ViewRootImpl 记录在 WindowManagerGlobal 中后，调用了 ViewRootImpl 的 setView 方法。先来看 ViewRootImpl 的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mWindowSession 是通过 WMS openSession 获取的匿名 binder，用于应用调用 WMS；mWindow 也是一个 binder 接口，用于 WMS 调用应用端。</p><p>接着看 ViewRootImpl setView 方法，关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">            requestLayout();</span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">                    mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                    mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">                    mTempInsets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，不需把 view 传给 WMS，这是因为 WMS 并不关心 View 树所表达的具体 UI 内容，它只要知道各应用进程显示界面的大小、窗口层级值即可。</p><p>到达 WMS 所在 system_server 进程后，WindowSession addToDisplay 会进一步调用 WindowManagerService 的 addWindow 方法，执行添加用户窗口工作，包括：</p><ul><li>对用户窗口进行权限检查，比如 TYPE_PHONE 等窗口类型需要 SYSTEM_ALERT_WINDOW 权限</li><li>检查 mWindow，窗口最终会记录到 &lt;IBinder,WindowState&gt; HashMap 中，其中 IBinder 为应用端的 mWindow，即一个 mWindow 只允许添加唯一的窗口</li><li>检查窗口类型，比如子窗口必须依赖于一个父窗口</li><li>按照窗口层级添加合适的位置</li><li>等等…</li></ul><p>小结一下，当 Activity 第一次回调 onResume 后，将 Activity 对应的窗口添加到 WMS 的过程：</p><ul><li>首先调用了 WindowManagerImpl，WindowManagerImpl 进一步调用进程单例的 WindowManagerGlobal</li><li>WindowManagerGlobal 中创建了与 DecorView 对应的 ViewRootImpl，并将 DecorView 和 ViewRootImpl 记录下来</li><li>WindowManagerImpl 和 WindowManagerGlobal 都还在应用进程，与 WMS 没什么关系</li><li>在 ViewRootImpl 中与 WMS 发生交互，应用端通过 WindowSession 调用 WMS，WMS 通过 IWindow 调用应用端</li><li>WMS 中会对窗口进行权限、类型等检查，最终将应用窗口信息记录下来</li></ul><h1 id="2-UI-刷新机制"><a href="#2-UI-刷新机制" class="headerlink" title="2. UI 刷新机制"></a>2. UI 刷新机制</h1><h2 id="1-发起-UI-重绘请求"><a href="#1-发起-UI-重绘请求" class="headerlink" title="1. 发起 UI 重绘请求"></a>1. 发起 UI 重绘请求</h2><p>ViewRootImpl 中的 performTraversals 中会依次调用 performMeasure、performLayout、performDraw，分别对应于 measure、layout、draw，由顶而下的进行界面绘制逻辑。</p><p>调用 View 控件 requestLayout、invalidate 等方法请求 UI 重绘时，会统一调用到 ViewRootImpl 的 scheduleTraversals 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 postSyncBarrier 插入一个消息屏障 block 普通消息，以保证主线程可以优先来执行接下来的绘制工作。mTraversalRunnable 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 mTraversalScheduled 变量可以看出，不是每次调用 requestLayout、invalidate 方法就会触发一次 UI 重绘的，而是要等 mTraversalRunnable 被执行后才会接收下一次的重绘请求。</p><p>在 mTraversalRunnable 中调用了 performTraversals() 进行真正的 UI 绘制，而 UI 真正绘制的时机则取决于 mChoreographer 触发回调的时机。</p><h2 id="2-执行-UI-绘制时机"><a href="#2-执行-UI-绘制时机" class="headerlink" title="2. 执行 UI 绘制时机"></a>2. 执行 UI 绘制时机</h2><p>ViewRootImpl 接收 UI 重绘请求后，将真正的 UI 绘制时机交给了 Choreographer，而 Choreographer 中会在每次 vsync 信号到来时执行 UI 绘制。</p><p>调用 Choreographer 的 postCallback 方法将 UI 绘制 TraversalRunnable 传入后，会进一步调用 Choreographer 的 postCallbackDelayedInternal 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将 UI 绘制 action 记录到 mCallbackQueues 队列中，然后根据处理时间决定立即调用 scheduleFrameLocked ，或发送异步消息延时调用 scheduleFrameLocked。</p><p>scheduleFrameLocked 方法关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span></span><br><span class="line">    <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span></span><br><span class="line">    <span class="comment">// as soon as possible.</span></span><br><span class="line">    <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">        scheduleVsyncLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如注释所示，scheduleFrameLocked 中需要切换到指定线程中调用 scheduleVsyncLocked：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleVsync 表示要接受下一次 vsync 信号，等到 vsync 信号到来时会由 SurfaceFlinger 回调通知。直接来看 Choreographer 接受到 vsync 信号后的处理，关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                        + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当要绘制的图像时间戳晚于一个帧刷新周期时，会去进一步计算异常跳过的帧数，如果跳过的帧数过大，就可以看到非常眼熟的一条日志了：<em>“Skipped xx frames! The application may be doing too much work on its main thread”</em> </p><p>随后通过 doCallbacks 回调触发执行 UI 绘制，也就是执行 ViewRootImpl 传过来的 TraversalRunnable、调用 performTraversals 方法，由顶而下的执行界面绘制逻辑。</p><h2 id="3-vsync-信号的生成"><a href="#3-vsync-信号的生成" class="headerlink" title="3. vsync 信号的生成"></a>3. vsync 信号的生成</h2><p><strong>vsync 信号在 SurfaceFlinger 中生成，并且有硬件、软件两种生成方式</strong> — 仅通过这种高度总结的描述，我们能得到多少信息呢？ 具体是如何生成？是优先选硬件生成还是软件生成还是同时存在？</p><p>下面就通过源码来一探究竟，既然在 SurfaceFlinger 中生成，那先来看 SurfaceFlinger 的 init 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mHwc = new HWComposer(<span class="keyword">this</span>);</span><br><span class="line">    mHwc-&gt;setEventHandler(static_cast&lt;HWComposer::EventHandler*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HWComposer 是 vsync 信号实际生成的类，SurfaceFlinger 通过 setEventHandler 向 HWComposer 注册了一个回调，使 SurfaceFlinger 能够接受由 HWComposer 生成的 vsync 信号，EventHandler 中的回调方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> onVSyncReceived(int32_t disp, nsecs_t timestamp)</span><br></pre></td></tr></table></figure><p>下面来看实际生成 vsync 的 HWComposer，其构造方法关键代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(...)&#123;</span><br><span class="line">    <span class="keyword">bool</span> needVSyncThread = <span class="literal">true</span>;</span><br><span class="line">    loadHwcModule(); <span class="comment">//加载硬件</span></span><br><span class="line">    <span class="keyword">if</span>(mHwc)&#123; <span class="comment">//硬件加载成功</span></span><br><span class="line">        mCBContext-&gt;procs.vsync = &amp;hook_vsync; <span class="comment">//注册硬件源回调</span></span><br><span class="line">        mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        needVSyncThread = <span class="literal">false</span>; <span class="comment">//不使用软件方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(needVSyncThread)&#123;</span><br><span class="line">        <span class="comment">//如果硬件不支持，则用软件模拟</span></span><br><span class="line">        mVSyncThread = new VSyncThread(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑十分简单，首先去加载硬件，优先使用硬件生成方式，如果硬件不支持，则用软件模拟。</p><p>硬件源生成的回调 hook_vsync 方法调用如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::hook_vsync(<span class="keyword">const</span> <span class="keyword">struct</span> hwc_procs* procs, <span class="keyword">int</span> disp,</span><br><span class="line">        int64_t timestamp) &#123;</span><br><span class="line">    cb_context* ctx = reinterpret_cast&lt;cb_context*&gt;(</span><br><span class="line">            const_cast&lt;hwc_procs_t*&gt;(procs));</span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp); <span class="comment">//调用 vsync 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HWComposer::vsync(<span class="keyword">int</span> disp, int64_t timestamp) &#123;</span><br><span class="line">    mEventHandler.onVSyncReceived(disp, timestamp); <span class="comment">//回调出去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 HWComposer 中的 vsync 硬件生成方式流程完毕，最后调用了 mEventHandler 回调，交由 SurfaceFlinger 处理。</p><p>再来看软件模拟生成方式，其通过 VSyncThread 类实现，VSyncThread 继承了 Thread 类，自然也继承了 Thread 类的 <em>threadLoop</em> 方法。</p><p>如果 threadLoop 方法返回 true，那当工作线程启动后，基类 Thread 会循环的调用 threadLoop 方法。而软件模拟生成的 vsync 信号就是在 threadLoop 方法中生成的，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HWComposer::VSyncThread::threadLoop() &#123;</span><br><span class="line">    <span class="keyword">const</span> nsecs_t period = mRefreshPeriod; <span class="comment">// vsync 周期</span></span><br><span class="line">    <span class="keyword">const</span> nsecs_t now = systemTime(<span class="built_in">CLOCK_MONOTONIC</span>); <span class="comment">//当前时间</span></span><br><span class="line">    nsecs_t next_vsync = mNextFakeVSync; <span class="comment">//本次要生成的 vsync 信号时间</span></span><br><span class="line">    nsecs_t sleep = next_vsync - now;</span><br><span class="line">    <span class="keyword">if</span> (sleep &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错过了，重新计算本次要生成的 vsync 信号时间</span></span><br><span class="line">        sleep = (period - ((now - next_vsync) % period));</span><br><span class="line">        next_vsync = now + sleep;</span><br><span class="line">    &#125;</span><br><span class="line">    mNextFakeVSync = next_vsync + period; <span class="comment">// 下一个 vsync 信号时间</span></span><br><span class="line">    <span class="keyword">struct</span> timespec spec;</span><br><span class="line">    spec.tv_sec  = next_vsync / <span class="number">1000000000</span>;</span><br><span class="line">    spec.tv_nsec = next_vsync % <span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//休眠到 next_vsync 即本次 vsync 信号时间 </span></span><br><span class="line">        err = clock_nanosleep(<span class="built_in">CLOCK_MONOTONIC</span>, TIMER_ABSTIME, &amp;spec, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (err&lt;<span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        mHwc.mEventHandler.onVSyncReceived(<span class="number">0</span>, next_vsync);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//让系统循环调用此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在指定的时间点产生信号呢？如代码所示，在每次循环时采用休眠的方式主动等待至 vsync 时间点。</p><p>第一次执行时， next_vsync、mNextFakeVSync 都为 0，所以 sleep &lt; 0 进而会重新计算 next_vsync 为 now + period，也就是基于当前时间再等一个 vsync 周期。</p><p>后续每次循环也会重新修正 vsync 信号的时间，避免回调 onVSyncReceived 方法或其他耗时操作导致 vsync 信号时间变得越来越晚。</p><p>小结一下，vsync 信号在 SurfaceFlinger 进程的 HWComposer 类中生成，优先使用硬件源生成方式，如果硬件不支持则使用软件方式模拟生成。不管是硬件生成还是软件生成，都会通过相同的回调统一通知，最后交由 SurfaceFlinger 进一步处理。</p><h2 id="4-vsync-信号的分发"><a href="#4-vsync-信号的分发" class="headerlink" title="4. vsync 信号的分发"></a>4. vsync 信号的分发</h2><h3 id="1-SurfaceFlinger-gt-DispSync"><a href="#1-SurfaceFlinger-gt-DispSync" class="headerlink" title="1. SurfaceFlinger -&gt; DispSync"></a>1. SurfaceFlinger -&gt; DispSync</h3><p>vsync 信号由 HWComposer 类生成后，会回调 SurfaceFlinger.cpp 的 onVSyncReceived 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onVSyncReceived(int32_t type, nsecs_t timestamp) &#123;</span><br><span class="line">    mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mPrimaryDispSync 为 DispSync 类型，DispSync 在构造时开启了一个 DispSyncThread 工作线程，专门负责 vsync 信号的分发：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispSync::DispSync(<span class="keyword">const</span> <span class="keyword">char</span>* name) :</span><br><span class="line">        mName(name),</span><br><span class="line">        mRefreshSkipCount(<span class="number">0</span>),</span><br><span class="line">        mThread(new DispSyncThread(name)) &#123;</span><br><span class="line">    mThread-&gt;run(<span class="string">"DispSync"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看 DispSync 的 addResyncSample 方法是如何处理 vsync 信号的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DispSync::addResyncSample(nsecs_t timestamp) &#123;</span><br><span class="line">    mResyncSamples[idx] = timestamp; <span class="comment">//vsync 信号时间戳</span></span><br><span class="line">    updateModelLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DispSync::updateModelLocked() &#123;</span><br><span class="line">    mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispSync 内部记录下 vsync 信号时间戳后，通过 updateModel 方法通知内部工作线程 DispSyncThread：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> updateModel(nsecs_t period, nsecs_t phase, nsecs_t referenceTime) &#123;</span><br><span class="line">    Mutex::Autolock lock(mMutex); <span class="comment">//锁</span></span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mCond.signal(); <span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意当前还处于 vsync 信号生成线程，若是软件生成则还处于 HWComposer 的 VSyncThread 线程，为了不影响 vsync 信号的生成工作，这里切换到另外的线程去分发。</p><p>具体而言，就是通过 mCond.signal() 方法通知 DispSyncThread 线程去进一步分发，DispSyncThread 的分发工作在其 threadLoop 方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">bool</span> threadLoop() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     &#123;</span><br><span class="line">        Mutex::Autolock lock(mMutex); <span class="comment">//锁</span></span><br><span class="line">        <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">            mCond.wait(mMutex); <span class="comment">//没 vsync 信号就阻塞</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="comment">// 收集注册了需要接受 vsync 信号的回调</span></span><br><span class="line">        callbackInvocations = gatherCallbackInvocationsLocked(now);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//分发回调</span></span><br><span class="line">         fireCallbackInvocations(callbackInvocations);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 DispSync 中对 vsync 信号的分发工作执行完毕。</p><h3 id="2-DispSync-gt-DispSyncSource"><a href="#2-DispSync-gt-DispSyncSource" class="headerlink" title="2. DispSync -&gt; DispSyncSource"></a>2. DispSync -&gt; DispSyncSource</h3><p>在 DispSync 内部工作线程 DispSyncThread 中，对注册需要接受 vsync 信号的回调进行调用，完成了 vsync 信号分发工作。</p><p>那具体是谁注册了监听？是谁需要进一步接受 vsync 信号呢？还是要从 DispSyncThread 的 threadLoop 方法入手，它通过 gatherCallbackInvocationsLocked 方法获取到当前已注册的监听，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(nsecs_t now) &#123;</span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;</span><br><span class="line">        CallbackInvocation ci;</span><br><span class="line">        ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line">        callbackInvocations.push(ci);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过 fireCallbackInvocations 方法回调了监听：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fireCallbackInvocations(<span class="keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;</span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispSync 内部对监听进行了封装，我们只关注外部传来的 mCallback，其为 DispSync::Callback 类型。通过以上代码可以知道 mCallback 被记录在 mEventListeners 中，那只要再看下哪里将监听添加到 mEventListeners 中，就能知道到底是谁注册的监听了。</p><p>在 SurfaceFlinger 初始化时 DispSyncSource 与 DispSync(mPrimaryDispSync) 产生关联：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">    mEventThread = new EventThread(vsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">    mSFEventThread = new EventThread(sfVsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 DispSyncSource 内部持有 DispSync，在 DispSyncSource 内部将监听注册到 DispSync 中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> setVSyncEnabled(<span class="keyword">bool</span> enable) &#123;</span><br><span class="line">    Mutex::Autolock lock(mVsyncMutex);</span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        status_t err = mDispSync-&gt;addEventListener(mName, mPhaseOffset,</span><br><span class="line">                static_cast&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status_t err = mDispSync-&gt;removeEventListener(</span><br><span class="line">                static_cast&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    mEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispSyncSource 本身继承了 DispSync::Callback 接口，即直接将自身作为监听注册到 DispSync 中。</p><p>也就是说，在 DispSync 内部工作线程中通过 fireCallbackInvocations 分发 vsync 信号，实际上调用了 DispSyncSource 的 onDispSyncEvent 方法。</p><p>需要注意的是，SurfaceFlinger init 时创建了两个 DispSyncSource，分别是上层 app 和 surfaceFlinger 自身，为什么要分这两种呢？仅仅是代码上的逻辑分离吗？</p><p>仔细观察 SurfaceFlinger init 中对这两个 DispSyncSource 的构造入参，分别传入了 vsyncPhaseOffsetNs 和 sfVsyncPhaseOffsetNs，这是要实现 vsync 信号的错时分发，即不同时分发 vsync 信号给上层 app 和 surfaceFlinger。</p><h3 id="3-DispSyncSource-gt-EventThread"><a href="#3-DispSyncSource-gt-EventThread" class="headerlink" title="3. DispSyncSource -&gt; EventThread"></a>3. DispSyncSource -&gt; EventThread</h3><p>接着来看 DispSyncSource 的 onDispSyncEvent 方法是如何处理 vsync 信号的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> onDispSyncEvent(nsecs_t when) &#123;</span><br><span class="line">    sp&lt;VSyncSource::Callback&gt; callback;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock lock(mCallbackMutex);</span><br><span class="line">        callback = mCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        callback-&gt;onVSyncEvent(when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是一个 callBack 回调了出去，这个 callBack 又是谁呢？可以再看一下上面的 SurfaceFlinger init 方法，类似于 DispSyncSource 向 DispSync 注册监听，EventThread 构造时传入了 DispSyncSource，EventThread 向 DispSyncSource 注册了监听。</p><p>callBack 类型为 VSyncSource::Callback，而 EventThread 自身也实现了这个接口：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> EventThread : public Thread, private VSyncSource::Callback</span><br></pre></td></tr></table></figure><p>接着来看 EventThread 内部实现的 onVSyncEvent 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::onVSyncEvent(nsecs_t timestamp) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp; <span class="comment">//vsync 时间戳</span></span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">    mCondition.broadcast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意当前还处于 DispSync 的工作线程，这里将 vsync 信号记录到 DisplayEventReceiver::Event 类型的 mVSyncEvent 数组中后，通过 mCondition.broadcast() 通知 EventThread 工作线程去处理，即从 DispSync 工作线程切换到了 EventThread 工作线程。</p><p>下面来看 EventThread 的工作线程中是如何处理的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line">    <span class="keyword">const</span> size_t count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        status_t err = conn-&gt;postEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是通过返回 true 来实现线程无限循环调用 threadLoop 方法，其中比较关键的是 waitForEvent 方法，关键逻辑如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)&#123;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        检测 mVSyncEvent 数组中是否有 vsync 信号</span><br><span class="line">        如果有传递给 event 参数，并开始遍历所有注册的 connection</span><br><span class="line">        如果 connection.count &gt;= <span class="number">0</span>，就加到 signalConnections 中</span><br><span class="line">        <span class="keyword">if</span>(waitForVSync)&#123;</span><br><span class="line">            mCondition.waitRelative(mLock, timeout); <span class="comment">//休眠等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (signalConnections.isEmpty());</span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梳理一下 EventThread 工作线程中的逻辑：通过 waitForEvent 方法进入休眠等待 vsync 信号，如果有 vsync 信号会唤醒，并将 vsync 信号传递给 event，返回 Connection，随后将 vsync 信号分发给了 Connection。</p><p>现在我们的关注点变为 EventThread::Connection，它是谁注册的？其 postEvent 方法又是如何进一步分发 vsync 信号的呢？</p><h3 id="4-Connection-gt-SurfaceFlinger"><a href="#4-Connection-gt-SurfaceFlinger" class="headerlink" title="4. Connection -&gt; SurfaceFlinger"></a>4. Connection -&gt; SurfaceFlinger</h3><p>依然聚焦于 vsync 的传递为脉络，接着来看 Connection 的 postEvent 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">status_t EventThread::Connection::postEvent(</span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t DisplayEventReceiver::sendEvents(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; dataChannel,</span><br><span class="line">        Event <span class="keyword">const</span>* events, size_t count)&#123;</span><br><span class="line">    <span class="keyword">return</span> BitTube::sendObjects(dataChannel, events, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t BitTube::sendObjects(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube,</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">const</span>* events, size_t count, size_t objSize)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vaddr = reinterpret_cast&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    ssize_t size = tube-&gt;write(vaddr, count*objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Connection 内部持有一个 BitTube，BitTube 是用来处理进程间通讯的机制，和管道类似，基于 SocketPair 封装实现。SocketPair 用来创建一对未命名、互相连接的套接字，套接字的一端可以进行读和写的操作，用来实现全双工的通讯。</p><p>在 Connection 中将 vsync 信号数据写入了 BitTube，那在哪里监听读呢？这就要分 SurfaceFlinger 与 app 两路了，首先来看 SurfaceFlinger 是如何接收的。再回到 SurfaceFlinger 的 init 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">    mEventThread = new EventThread(vsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">    mSFEventThread = new EventThread(sfVsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造完 SurfaceFlinger 的 EventThread 后，通过 setEventThread 方法将 EventThread 设置给 mEventQueue，mEventQueue 为 MessageQueue 类型，方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::setEventThread(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)&#123;</span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();</span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();</span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下就全走通了，SurfaceFlinger 的消息队列监听了 Connection 中的 BitTube，当 vsync 信号在 EventThread 中分发给 Connection 写入 BitTube 后，SurfaceFlinger 的消息队列就能收到通知了。</p><p>接着来看 SurfaceFlinger 的 MessageQueue 如何进一步处理 vsync 消息，在 MessageQueue 的 setEventThread 方法中设置接受到 vsync 后回调 cb_eventReceiver 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::cb_eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    MessageQueue* queue = reinterpret_cast&lt;MessageQueue *&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cb_eventReceiver 进一步调用 eventReceiver 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::eventReceiver(<span class="keyword">int</span> <span class="comment">/*fd*/</span>, <span class="keyword">int</span> <span class="comment">/*events*/</span>) &#123;</span><br><span class="line">    ssize_t n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> INVALIDATE_ON_VSYNC</span></span><br><span class="line">                mHandler-&gt;dispatchInvalidate();</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                mHandler-&gt;dispatchRefresh();</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到读取出 vsync 信号数据后，只用到了 type 信息，然后通过 Handler 回调出去处理。</p><p>至此 vsync -&gt; SurfaceFlinger 的分发流程分析完毕。</p><h3 id="5-Connection-gt-app"><a href="#5-Connection-gt-app" class="headerlink" title="5. Connection -&gt; app"></a>5. Connection -&gt; app</h3><p>尽管 vsync 传递给 SurfaceFlinger 流程发生在同个进程，却使用了支持跨进程的 BitTube。为什么要使用 BitTube 呢？可以想到的一个优点是，可以与 vsync 信号传递给上层 app 进程的方式统一。</p><p>我们知道上层 app 会统一将 UI 刷新请求发给 Choreographer，Choreographer 会在下次 vsync 信号到来时真正执行 UI 绘制，下面通过源码来搞懂底层的 vsync 是如何传递至 Choreographer 的。  </p><p>Choreographer 中实际与 vsync 信号相关的逻辑在 DisplayEventReceiver 中，初始化 Choreographer 时会构造 DisplayEventReceiver：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    mDisplayEventReceiver = <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayEventReceiver 构造函数中会调用到 DisplayEventReceiver.java 的 nativeInit 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        WeakReference&lt;DisplayEventReceiver&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        MessageQueue messageQueue, <span class="keyword">int</span> vsyncSource)</span></span>;</span><br></pre></td></tr></table></figure><p>底层实现位于 android_view_DisplayEventReceiver.cpp 中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> jlong nativeInit(JNIEnv* env, </span><br><span class="line">        jclass clazz, </span><br><span class="line">        jobject receiverWeak, jobject messageQueueObj) &#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue);</span><br><span class="line">    status_t status = receiver-&gt;initialize();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造了一个 NativeDisplayEventReceiver，其继承自 DisplayEventReceiver，在后者的构造函数中，创建了关键的 IDisplayEventConnection binder 接口，建立与 SurfaceFlinger 通信的连接：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::DisplayEventReceiver() &#123;</span><br><span class="line">    <span class="comment">// ISurfaceComposer binder 接口</span></span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// IDisplayEventConnection binder 接口</span></span><br><span class="line">        mEventConnection = sf-&gt;createDisplayEventConnection();</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = mEventConnection-&gt;getDataChannel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要将 MessageQueue 传递下来呢？因为要借助 Android Handler 已有的功能，即基于内部 epoll 机制添加对某文件描述符事件的监听，上文传递给 SurfaceFlinger 的原理也是如此。</p><p>nativeInit 中构造 NativeDisplayEventReceiver 后调用了其 initialize 方法，内部便通过 Looper 添加了对文件描述符的监听：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventDispatcher::initialize() &#123;</span><br><span class="line">    <span class="keyword">int</span> rc = mLooper-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再回到上层的 Choreographer ，其通过 scheduleVsync 请求下一次的 vsync 信号，最终会调用到 DisplayEventReceiver 的 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(<span class="keyword">long</span> receiverPtr)</span></span>;</span><br></pre></td></tr></table></figure><p>底层同样是在 android_view_DisplayEventReceiver.cpp 中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) &#123;</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">            reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">    receiver-&gt;scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到 DisplayEventReceiver 的 requestNextVsync 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line">    mEventConnection-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到 mEventConnection 是一个 binder 接口，跨进程调用到 BnDisplayEventConnection，而后者的实现类就是 SurfaceFlinger 中的 EventThread：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> EventThread : public Thread, private VSyncSource::Callback &#123;</span><br><span class="line">    <span class="keyword">class</span> Connection : public BnDisplayEventConnection &#123;...&#125;</span><br></pre></td></tr></table></figure><p>所以会进一步调用到 EventThread 的 requestNextVsync 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::requestNextVsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mFlinger.resyncWithRateLimit();</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>;</span><br><span class="line">        mCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文对 EventThread 做过详细的分析，这里再贴一遍其工作线程的关键逻辑代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)&#123;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        检测 mVSyncEvent 数组中是否有 vsync 信号</span><br><span class="line">        如果有传递给 event 参数，并开始遍历所有注册的 connection</span><br><span class="line">        如果 connection.count &gt;= <span class="number">0</span>，就加到 signalConnections 中</span><br><span class="line">        <span class="keyword">if</span>(waitForVSync)&#123;</span><br><span class="line">            mCondition.waitRelative(mLock, timeout); <span class="comment">//休眠等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (signalConnections.isEmpty());</span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，在 requestNextVsync 中将 connection-&gt;count 置为 0 然后唤醒 EventThread，EventThread 被唤醒后会将 connection 加入要通知 vsync 的 signalConnections 中，随后与上文中分析过的逻辑一致，通过 BitTube+looper 进一步分发 vsync 信号。</p><p>值得注意的是，在 waitForEvent 中判断如果 connection-&gt;count 为 0，会将 count 置为 -1，这意味着 requestNextVsync 方法名副其实，只是一次性请求接受一次 vsync 信号而已，要再调用 requestNextVsync 才能再次接受 vsync 信号。</p><p>最后再来看 vsync 信号传递到 java 层的流程，vsync 消息到来通过 dispatchVsync 方法分发：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> DisplayEventDispatcher::handleEvent(<span class="keyword">int</span>, <span class="keyword">int</span> events, <span class="keyword">void</span>*) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又回到了与 java 层最接近的 android_view_DisplayEventReceiver.cpp 中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t <span class="keyword">id</span>, uint32_t count) &#123;</span><br><span class="line">   JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">   ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));</span><br><span class="line">   <span class="keyword">if</span> (receiverObj.get()) &#123;</span><br><span class="line">       env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">               gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, <span class="keyword">id</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jni 调用了上层 DisplayEventReceiver.java 的 dispatchVsync 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后进一步回调到 Choreographer 的 doFrame，执行 ViewRootImpl 传过来的 TraversalRunnable、调用 performTraversals 方法，由顶而下的执行界面绘制逻辑。</p><p>小结一下：vsync 信号分为 SurfaceFlinger、app 两路分发，这两路分别对应于一个 EventThread。当 vsync 信号到来时，会唤醒 EventThread 线程，然后 EventThread 通过注册到内部的 Connection 分发出去。Connection 进一步通过 BitTube 并使用消息机制 looper 监听 BitTube 的 fd，从而实现 vsync 的分发。</p><h1 id="3-UI-绘制流程"><a href="#3-UI-绘制流程" class="headerlink" title="3. UI 绘制流程"></a>3. UI 绘制流程</h1><h1 id="4-Surface-原理"><a href="#4-Surface-原理" class="headerlink" title="4. Surface 原理"></a>4. Surface 原理</h1><h3 id="1-Surface-存在的意义"><a href="#1-Surface-存在的意义" class="headerlink" title="1. Surface 存在的意义"></a>1. Surface 存在的意义</h3><p>Android GUI 系统中有两类本地窗口，FramebufferNativeWindow 和 Surface。FramebufferNativeWindow 面向 SurfaceFlinger，使用了帧缓冲区，用于直接显示在屏幕上；而 Surface 面向应用程序，是从内存缓冲区分配的空间。</p><p>为什么要有面向应用程序的图像缓冲区 Surface 呢？只有屏幕显示帧缓冲区不可以吗？假如系统中只有一个需要显示 UI 的程序，仅有帧缓冲区确实可以胜任，但如果有多个 UI 程序的话，每个程序都要使用 FrameBuffer，这就像幼儿园的几个小朋友共用一个画板来涂鸦一样，”五彩斑斓”、”创意无限”。</p><p>所以需要有面向应用程序的 Surface，供应用程序独立的准备其图像数据。SurfaceFlinger 会收集所有应用程序的的 Surface，对它们进行统一的混合操作，然后输出到屏幕显示帧缓冲区上，从而保证多个应用程序图像可以被有序的显示到屏幕上。</p><h3 id="2-Surface-创建流程"><a href="#2-Surface-创建流程" class="headerlink" title="2. Surface 创建流程"></a>2. Surface 创建流程</h3><h3 id="3-GraphicBufferProducer"><a href="#3-GraphicBufferProducer" class="headerlink" title="3. GraphicBufferProducer"></a>3. GraphicBufferProducer</h3><h3 id="1-BufferQueue"><a href="#1-BufferQueue" class="headerlink" title="1. BufferQueue"></a>1. BufferQueue</h3><h3 id="1-Canvas-和-Surface"><a href="#1-Canvas-和-Surface" class="headerlink" title="1. Canvas 和 Surface"></a>1. Canvas 和 Surface</h3><h3 id="window-surface-Layer-BufferQueue-关系"><a href="#window-surface-Layer-BufferQueue-关系" class="headerlink" title="window surface  Layer  BufferQueue 关系"></a>window surface  Layer  BufferQueue 关系</h3><h3 id="skia-和-OpenGL"><a href="#skia-和-OpenGL" class="headerlink" title="skia 和 OpenGL"></a>skia 和 OpenGL</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Activity 与 Window&lt;ol&gt;
&lt;li&gt;setContentView 原理&lt;/li&gt;
&lt;li&gt;Activity 窗口添加过程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;UI 刷新机制&lt;ol&gt;
&lt;li&gt;发起 UI 重绘请求&lt;/li&gt;
&lt;li&gt;执行 UI 绘制时机&lt;/li&gt;
&lt;li&gt;vsync 信号的生成&lt;/li&gt;
&lt;li&gt;vsync 信号的分发&lt;ol&gt;
&lt;li&gt;SurfaceFlinger -&amp;gt; DispSync&lt;/li&gt;
&lt;li&gt;DispSync -&amp;gt; DispSyncSource&lt;/li&gt;
&lt;li&gt;DispSyncSource -&amp;gt; EventThread&lt;/li&gt;
&lt;li&gt;Connection -&amp;gt; SurfaceFlinger &lt;/li&gt;
&lt;li&gt;Connection -&amp;gt; app&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;UI 绘制流程&lt;/li&gt;
&lt;li&gt;Surface 原理&lt;ol&gt;
&lt;li&gt;Surface 创建流程&lt;/li&gt;
&lt;li&gt;Surface 的跨进程传递&lt;/li&gt;
&lt;li&gt;GraphicBufferProducer&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="window" scheme="http://yhaowa.gitee.io/yhaowa/tags/window/"/>
    
      <category term="vsync" scheme="http://yhaowa.gitee.io/yhaowa/tags/vsync/"/>
    
      <category term="surface" scheme="http://yhaowa.gitee.io/yhaowa/tags/surface/"/>
    
  </entry>
  
  <entry>
    <title>Android 消息屏障与异步消息</title>
    <link href="http://yhaowa.gitee.io/yhaowa/52cb86d4/"/>
    <id>http://yhaowa.gitee.io/yhaowa/52cb86d4/</id>
    <published>2020-10-31T16:07:58.000Z</published>
    <updated>2020-12-06T09:18:58.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>如何插入一个消息屏障？</li><li>如何删除一个消息屏障？</li><li>如何插入一个异步消息？</li><li>消息屏障对插入消息有什么影响？</li><li>消息屏障是如何优先处理异步消息的？</li><li>Framework 中哪里使用了消息屏障？</li></ol></blockquote><a id="more"></a><p>Android 消息机制中的 MessageQueue 可以存放三种类型的消息，普通消息、消息屏障和异步消息。其中消息屏障和异步消息搭配使用，可以达到屏蔽普通消息、优先处理异步消息的目的。</p><h4 id="1-如何插入一个消息屏障？"><a href="#1-如何插入一个消息屏障？" class="headerlink" title="1. 如何插入一个消息屏障？"></a>1. 如何插入一个消息屏障？</h4><p>见 MessageQueue 的 postSyncBarrier 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line">        <span class="comment">//按时间排序插入到队列中...</span></span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>消息屏障不需分发处理，没有 target Handler，后续也会根据有无 target 来判断是否为消息屏障</li><li>消息屏障也是有时间戳的，并且只会对后面的消息起到屏障作用，不会影响前面的消息</li><li>消息屏障插入后无需唤醒线程，因为消息屏障原本的目的就是打算屏蔽消息处理的</li><li>插入后会返回一个 token，用于后续移除指定 token 的消息屏障 </li><li>方法为 private，外部调用需反射</li></ol><h4 id="2-如何删除一个消息屏障？"><a href="#2-如何删除一个消息屏障？" class="headerlink" title="2. 如何删除一个消息屏障？"></a>2. 如何删除一个消息屏障？</h4><p>见 MessageQueue 的 removeSyncBarrier 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从队列中删除这个消息屏障...</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据无 target 及 token 匹配找到对应的消息屏障</li><li>删除屏障后可能需要唤醒线程，是否唤醒取决于当前是否是因为消息屏障而阻塞的</li></ol><h4 id="3-如何插入一个异步消息？"><a href="#3-如何插入一个异步消息？" class="headerlink" title="3. 如何插入一个异步消息？"></a>3. 如何插入一个异步消息？</h4><p>Message 的 setAsynchronous 为开放 API，直接调用设置即可，比如在 ViewRootImpl 中对输入事件的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(InputEvent event, InputEventReceiver receiver)</span> </span>&#123;</span><br><span class="line">    SomeArgs args = SomeArgs.obtain();</span><br><span class="line">    args.arg1 = event;</span><br><span class="line">    args.arg2 = receiver;</span><br><span class="line">    Message msg = mHandler.obtainMessage(MSG_DISPATCH_INPUT_EVENT, args);</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>); <span class="comment">//异步消息</span></span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于输入事件需要快速响应，优先级比较高，所以设置为异步消息，避免被消息屏障屏蔽掉</p><h4 id="4-消息屏障对插入消息有什么影响？"><a href="#4-消息屏障对插入消息有什么影响？" class="headerlink" title="4. 消息屏障对插入消息有什么影响？"></a>4. 消息屏障对插入消息有什么影响？</h4><p>见 MessageQueue 的 enqueueMessage 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略部分代码...</span></span><br><span class="line">Message p = mMessages;</span><br><span class="line"><span class="keyword">boolean</span> needWake;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123; <span class="comment">//插入到队列头部</span></span><br><span class="line">    msg.next = p;</span><br><span class="line">    mMessages = msg;</span><br><span class="line">    needWake = mBlocked;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//插入到队列中间</span></span><br><span class="line">    needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">    Message prev;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">            needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.next = p;</span><br><span class="line">    prev.next = msg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needWake) &#123; <span class="comment">//唤醒</span></span><br><span class="line">    nativeWake(mPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果插入到队列头部，那么只要当前线程是休眠的，就要唤醒，不管有没有消息屏障，因为消息屏障不会影响在它之前的消息</li><li>如果插入到队列中间且队列头消息为消息屏障，那还要判断插入的消息是不是最早的异步消息，如果是才唤醒线程。因为如果之前已经有异步消息，那说明已经对之前的异步消息做过唤醒或休眠指定时间的处理了，不用再此唤醒</li></ol><h4 id="5-消息屏障是如何优先处理异步消息的？"><a href="#5-消息屏障是如何优先处理异步消息的？" class="headerlink" title="5. 消息屏障是如何优先处理异步消息的？"></a>5. 消息屏障是如何优先处理异步消息的？</h4><p>见 MessageQueue 的 next 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果当前消息不是消息屏障，那异步消息和普通消息无异，都会按照时间排序依次执行</li><li>如果当前消息为消息屏障，就会去找队列中的异步消息，如果没有异步消息，就无限休眠；如果有，就根据这个异步消息的处理时间去分发处理或休眠</li></ol><h4 id="6-Framework-中哪里使用了消息屏障？"><a href="#6-Framework-中哪里使用了消息屏障？" class="headerlink" title="6. Framework 中哪里使用了消息屏障？"></a>6. Framework 中哪里使用了消息屏障？</h4><p>ViewRootImpl 中界面绘制时使用了消息屏障：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//插入一个消息屏障，屏蔽普通消息的处理</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//移除消息屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与输入事件一样，界面绘制也是优先级高的消息，需要优先处理，所以这里插入消息屏障 block 其他普通消息，以达到优先处理界面绘制的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如何插入一个消息屏障？&lt;/li&gt;
&lt;li&gt;如何删除一个消息屏障？&lt;/li&gt;
&lt;li&gt;如何插入一个异步消息？&lt;/li&gt;
&lt;li&gt;消息屏障对插入消息有什么影响？&lt;/li&gt;
&lt;li&gt;消息屏障是如何优先处理异步消息的？&lt;/li&gt;
&lt;li&gt;Framework 中哪里使用了消息屏障？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/yhaowa/categories/Android/"/>
    
    
      <category term="handler" scheme="http://yhaowa.gitee.io/yhaowa/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程知识点总结</title>
    <link href="http://yhaowa.gitee.io/yhaowa/d55eb6b/"/>
    <id>http://yhaowa.gitee.io/yhaowa/d55eb6b/</id>
    <published>2020-10-07T04:45:59.000Z</published>
    <updated>2020-12-06T09:22:48.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>线程基础</li><li>线程池</li><li>各种各样的锁</li><li>并发容器</li><li>原子类</li><li>Java 内存模型</li><li>线程协作</li><li>AQS 框架</li></ol></blockquote><a id="more"></a><h2 id="一、线程基础"><a href="#一、线程基础" class="headerlink" title="一、线程基础"></a>一、线程基础</h2><h4 id="1-为什么继承-runnable-接口比继承-Thread-类的线程实现方式好？"><a href="#1-为什么继承-runnable-接口比继承-Thread-类的线程实现方式好？" class="headerlink" title="1. 为什么继承 runnable 接口比继承 Thread 类的线程实现方式好？"></a>1. 为什么继承 runnable 接口比继承 Thread 类的线程实现方式好？</h4><ul><li>可以把不同的执行内容解耦，全责分明</li><li>某些情况可以减少开销，提高性能（比如可用线程池中已有的线程去执行 runnable，而不用重新创建线程）</li><li>继承 Thread 类的单继承特性会限制代码的扩展性</li></ul><h4 id="2-线程是如何在-6-种状态之间转化的？"><a href="#2-线程是如何在-6-种状态之间转化的？" class="headerlink" title="2. 线程是如何在 6 种状态之间转化的？"></a>2. 线程是如何在 6 种状态之间转化的？</h4><ul><li>线程的 6 种状态：New(新创建)、Runnable(可运行)、Blocked(被阻塞)、Waiting(等待)、Timed_waiting(计时等待)、Terminated(被终止)</li><li>新创建线程处于 New 状态，调用 Thread#start 方法后进入 Runnable 状态，Runnable 对应操作系统的 Running 和 Ready 状态，代表可能正在被执行或正在等待 CPU 分配资源</li><li>当要进入 synchronized 方法或代码块时却没抢到 monitor 锁，会由 Runnable 状态进入 Blocked 状态，获取到 monitor 锁后会进入 Runnable 状态</li><li>执行 Object#wait 或 LockSupport#park 会进入 Waiting 状态；执行带 timeOut 参数的 Object#wait 或 LockSupport#park 会进入 Timed_waiting 状态</li><li>调用 LockSupport#unpark 、被中断或超时时间到会由 Waiting/Timed_waiting 状态进入 Runnable 状态</li><li>被 notify/notifyAll 唤醒，会由 Waiting/Timed_waiting 状态进入 Blocked 状态</li><li>run 方法执行完或异常终止会进入 Terminated 状态</li><li>一个线程只会经历一次 New 和 Terminated 状态，中间状态才可以相互转换</li></ul><h4 id="3-如何理解锁池和等待池？"><a href="#3-如何理解锁池和等待池？" class="headerlink" title="3. 如何理解锁池和等待池？"></a>3. 如何理解锁池和等待池？</h4><ul><li>如果某对象的锁已被一个线程占有，其他线程调用此对象的 sychronized 代码块时无法获取到锁，就会进入此对象的锁池，锁池中的线程会竞争该对象的锁</li><li>如果一个线程调用了 Object#wait 方法，此线程就会进入此对象的等待池，等待池中的线程不会去竞争该对象的锁</li><li>调用 notify 方法会随机唤醒一个等待池中的线程，并移到锁池中；调用 notifyAll 方法会唤醒等待池中所有的线程，并全移到锁池中</li></ul><h4 id="4-为什么-Object-wait-要写在-while-condition-循环中？"><a href="#4-为什么-Object-wait-要写在-while-condition-循环中？" class="headerlink" title="4. 为什么 Object#wait 要写在 while(condition) 循环中？"></a>4. 为什么 Object#wait 要写在 while(condition) 循环中？</h4><ul><li>规避虚假唤醒导致的问题，虚假唤醒是指线程可能在未调用 notify/notifyAll、未被中断和等待超时的情况下被意外唤醒，所以 wait 要写在 while(condition) 循环中，保证在发生虚假唤醒时程序的正确性</li></ul><h4 id="5-如何正确的中断线程？"><a href="#5-如何正确的中断线程？" class="headerlink" title="5. 如何正确的中断线程？"></a>5. 如何正确的中断线程？</h4><ul><li>调用 Thread#interrupt 方法给线程发送中断信号，线程中通过 Thread#isInterrupted 方法判断是否被中断，若被中断则停止当前执行任务</li><li>线程中通过 Thread#sleep 或 BlockingQueue#put 等方法休眠时，若被中断则会抛出 InterruptedException 异常并清除中断标记位，所以要捕获处理此异常，或再调用 Thread#interrupt 标记中断使后续代码能处理中断</li><li>使用 volatile 标记位变量中断线程是错误的，因为不能中断 Thread#sleep 或 BlockingQueue#put 等方法进入的休眠状态</li></ul><h4 id="6-Object-wait-和-Thread-sleep-方法的异同？"><a href="#6-Object-wait-和-Thread-sleep-方法的异同？" class="headerlink" title="6. Object#wait 和 Thread#sleep 方法的异同？"></a>6. Object#wait 和 Thread#sleep 方法的异同？</h4><ul><li>相同点：都可以让线程阻塞；都可以响应线程中断</li><li>区别：wait 方法必须写在 synchronized 代码块；wait 方法会主动释放 monitor 锁；sleep 方法必须传入 timeout 参数</li></ul><h2 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h2><h4 id="1-使用线程池相比手动创建线程有什么优点？"><a href="#1-使用线程池相比手动创建线程有什么优点？" class="headerlink" title="1. 使用线程池相比手动创建线程有什么优点？"></a>1. 使用线程池相比手动创建线程有什么优点？</h4><ul><li>频繁创建线程系统开销大，而线程池可用一些固定的工作线程反复执行任务，避免频繁创建线程</li><li>过多线程会占用过多内存，而线程池可以控制线程的总数量，避免占用过多内存资源</li><li>线程池可更方便的统筹管理任务执行和线程，避免手动创建线程难管理、难统计的问题</li></ul><h4 id="2-线程池各个参数的含义？"><a href="#2-线程池各个参数的含义？" class="headerlink" title="2. 线程池各个参数的含义？"></a>2. 线程池各个参数的含义？</h4><ul><li>corePoolSize 核心线程数：常驻的工作线程，初始化时核心线程数默认为 0，创建后不会被销毁</li><li>maximumPoolSize 最大线程数：当 workQueue 存放满时，线程池会进一步创建线程，可创建的最多数量为 maximumPoolSize</li><li>keepAliveTime/TimeUnit 空闲线程存活时间：当大于 corePoolSize 部分的线程空闲超过存活时间后，会被回收</li><li>threadFactory 用来创建线程的线程工厂：方便给线程自定义命名以及线程优先级</li><li>workQueue 存放任务的阻塞队列：当线程数超过 corePoolSize 后，会将任务存放到 workQueue 中等待执行</li><li>handler 任务被拒绝时的处理：当线程池已 shutdown 关闭或线程数达到 maximumPoolSize 时新提交的任务会被拒绝</li><li>注意：当 workQueue 为无界队列时， maximumPoolSize 参数其实不会被用到，是没意义的</li></ul><h4 id="3-线程池的四种拒绝策略？"><a href="#3-线程池的四种拒绝策略？" class="headerlink" title="3. 线程池的四种拒绝策略？"></a>3. 线程池的四种拒绝策略？</h4><ul><li>AbortPolicy：抛出 RejectedExecutionException 异常，可根据业务进行重试等操作</li><li>DiscardPolicy：直接丢弃新提交的任务，不做其他反馈，有任务丢失风险</li><li>DiscardOldestPolicy：如果线程池未关闭，就丢弃队列中存活时间最长的任务，但不做其他反馈，有任务丢失风险</li><li>CallerRunsPolicy：如果线程池未关闭，就在提交任务的线程直接开始执行任务，任务不会被丢失，由于阻塞了提交任务的线程，相当于提供了负反馈</li></ul><h4 id="4-有哪-6-种常见的线程池？"><a href="#4-有哪-6-种常见的线程池？" class="headerlink" title="4. 有哪 6 种常见的线程池？"></a>4. 有哪 6 种常见的线程池？</h4><ul><li>FixedThreadPool：固定线程数的线程池，核心线程数与最大线程数相同，任务存放队列为无界阻塞队列（LinkedBlockingQueue）</li><li>CachedThreadPool：可缓存线程池，核心线程数为 0，最大线程数为 Integer.MAX_VALUE，任务存放队列为中转阻塞队列（SynchronousQueue）</li><li>SingleThreadExecutor：单工作线程线程池，核心线程数为 1，任务存放队列为无界阻塞队列（LinkedBlockingQueue）</li><li>ScheduledThreadPool：定时或周期性任务线程池，任务存放队列为无界优先级阻塞队列（DelayedWorkQueue）</li><li>SingleThreadScheduledExecutor：定时或周期性任务单工作线程线程池，核心线程数为 1，任务存放队列为无界优先级阻塞队列（DelayedWorkQueue）</li><li>ForkJoinPool：适合执行可以产生并行子任务的任务，可方便的分裂(Fork)成子任务执行并汇总(Join)结果，任务存放队列为 WorkQueue，除了公用队列外，每个线程还有一个独立的队列来存放任务</li></ul><h4 id="5-线程池常用的阻塞队列有哪些？"><a href="#5-线程池常用的阻塞队列有哪些？" class="headerlink" title="5. 线程池常用的阻塞队列有哪些？"></a>5. 线程池常用的阻塞队列有哪些？</h4><ul><li>LinkedBlockingQueue 无界阻塞队列：任务队列容量为 Integer.MAX_VALUE，永远不会放满，所以对应线程池只会创建核心线程数量的工作线程，而最大线程数参数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程</li><li>SynchronousQueue 中转阻塞队列：不存放任务，一旦有任务被提交就直接转发给线程或者创建新线程来执行</li><li>DelayedWorkQueue 无界优先级阻塞队列：内部采用堆数据结构，按照延迟时间长短对任务进行排序，ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，正是因为它们本身是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行</li><li>ArrayBlockingQueue 有界队列：任务队列容量可配置，结合最大线程数与拒绝策略可有效的规避资源被耗尽的风险</li></ul><h4 id="6-为什么不建议使用常见的线程池？"><a href="#6-为什么不建议使用常见的线程池？" class="headerlink" title="6. 为什么不建议使用常见的线程池？"></a>6. 为什么不建议使用常见的线程池？</h4><ul><li>FixedThreadPool 和 SingleThreadExecutor 任务存放队列为无界队列（LinkedBlockingQueue），任务过多时会占用大量内存并导致 OOM</li><li>CachedThreadPool 虽然不存储任务，但线程数没有上限，任务过多时会创建非常多的线程，导致超过线程数量上限或 OOM</li><li>ScheduledThreadPool 和 SingleThreadScheduledExecutor 任务存放队列为无界队列（DelayedWorkQueue），任务过多时会占用大量内存并导致 OOM</li><li>手动创建可以根据业务选择合适的线程数量，制定拒绝策略，避免资源耗尽的风险</li></ul><h4 id="7-合适的线程数量是多少？"><a href="#7-合适的线程数量是多少？" class="headerlink" title="7. 合适的线程数量是多少？"></a>7. 合适的线程数量是多少？</h4><ul><li>CPU 密集型任务无需设置过多线程数，因为此类任务需占用大量 CPU 资源，设置过多线程数会导致多个线程都去抢占 CPU 资源，产生不必要的上下文切换，从而造成整体性能下降</li><li>IO 密集型任务可设置较多线程数，因为此类任务 IO 操作较耗时，但不会占用太多 CPU 资源，设置过少线程数会导致 CPU 资源空闲，导致 CPU 资源的浪费</li><li>所以 CPU 耗时所占比例越高，就需要越少的线程；IO 耗时所占比例越高，就需要越多的线程</li><li>通用公式：线程数 = CPU 核心数 * (1 + IO 耗时/CPU 耗时)</li><li>例如 8 核机器执行一个 CPU 耗时 5ms，DB 耗时 100ms 的任务，线程数 = 8*(1+100/5) = 168 个</li><li>QPS(req pre second) 即一秒可执行次数，上例中 QPS = 168<em>(1000/105) = 1600 。若 DB 最大 QPS 限制为 1000，则按比例减少线程数为 168</em>(1000/1600) = 105 个</li><li>如果不同任务的 CPU 耗时和 IO 耗时各不相同，可对所有任务的 CPU 耗时和 IO 耗时求个平均值进行计算；</li></ul><h4 id="8-如何正确的关闭线程池？"><a href="#8-如何正确的关闭线程池？" class="headerlink" title="8. 如何正确的关闭线程池？"></a>8. 如何正确的关闭线程池？</h4><ul><li>shutdown()：调用后会在执行完正在执行任务和队列中等待任务后才彻底关闭，并会根据拒绝策略拒绝后续新提交的任务</li><li>shutdownNow()：调用后会给正在执行任务线程发送中断信号，并将任务队列中等待的任务转移到一个 List 中返回，后续会根据拒绝策略拒绝新提交的任务</li><li>isShutdown()：判断是否开始关闭线程池，即是否调用了 shutdown() 或 shutdownNow() 方法</li><li>isTerminated()：判断线程池是否真正终止，即线程池已关闭且所有剩余的任务都执行完了</li><li>awaitTermination()：阻塞一段时间等待线程池终止，返回 true 代表线程池真正终止否则为等待超时</li></ul><h4 id="9-线程池线程复用的原理？"><a href="#9-线程池线程复用的原理？" class="headerlink" title="9. 线程池线程复用的原理？"></a>9. 线程池线程复用的原理？</h4><ul><li>线程池将线程和任务解耦，一个线程可以从任务队列中获取多个任务执行</li><li>关键类为 ThreadPoolExecutor 内部的 Worker 类，对应于一个线程，其内部会从任务队列中获取多个任务执行</li></ul><h2 id="三、各种各样的锁"><a href="#三、各种各样的锁" class="headerlink" title="三、各种各样的锁"></a>三、各种各样的锁</h2><h4 id="1-悲观锁-乐观锁"><a href="#1-悲观锁-乐观锁" class="headerlink" title="1. 悲观锁/乐观锁"></a>1. 悲观锁/乐观锁</h4><ul><li>悲观锁指在操作同步资源前必须先拿到锁；而乐观锁利用 CAS 理念，在不独占资源的情况下对资源进行修改</li><li>悲观锁适合用于并发写入多、临界区代码复杂、竞争激烈等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗</li><li>乐观锁适用于大部分是读取，少部分是修改的场景，也适合虽然读写都很多，但是并发并不激烈的场景。在这些场景下，乐观锁不加锁的特点能让性能大幅提高</li></ul><h4 id="2-可重入锁-非可重入"><a href="#2-可重入锁-非可重入" class="headerlink" title="2. 可重入锁/非可重入"></a>2. 可重入锁/非可重入</h4><ul><li>可重入是如果指线程已经持有锁，则能在不释放这把锁的情况下，再次获取这把锁</li><li>Java 中的 ReentrantLock 和 synchronized 都是可重入锁</li></ul><h4 id="3-共享锁-独占锁"><a href="#3-共享锁-独占锁" class="headerlink" title="3. 共享锁/独占锁"></a>3. 共享锁/独占锁</h4><ul><li>共享锁指同一把锁可以同时被多个线程获取，而独占锁指一把锁只能同时被一个线程获取</li><li>ReentrantReadWriteLock 的读锁就是共享锁，可以同时被多个线程读取；写锁则为独占锁，同时只能被一个线程写</li></ul><h4 id="4-自旋锁-非自旋锁"><a href="#4-自旋锁-非自旋锁" class="headerlink" title="4. 自旋锁/非自旋锁"></a>4. 自旋锁/非自旋锁</h4><ul><li>自旋是指拿不到锁时不陷入阻塞，而是循环尝试获取锁</li><li>自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率</li><li>如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源</li></ul><h4 id="5-公平锁-非公平锁"><a href="#5-公平锁-非公平锁" class="headerlink" title="5. 公平锁/非公平锁"></a>5. 公平锁/非公平锁</h4><ul><li>公平锁是指各个线程公平平等，排队获取锁时等待的时间越长就会优先获取到锁，</li><li>非公平锁是指线程可能存在插队现象，比如一个阻塞等待中的线程 A 和新来的线程 B 同时竞争一把锁时线程 B 会插队先获取到锁</li><li>非公平锁整体执行速度为什么能更快：如上例，唤醒线程是需要耗时的，与其漫长的等待唤醒 A，不如直接先让 B 插队执行，这样可以跳过 B 阻塞、唤醒的状态切换</li><li>非公平锁的优缺点：整体执行速度更快、吞吐量更大，但可能产生线程饥饿导致某个线程长时间得不到执行</li></ul><h4 id="6-可中断锁-不可中断锁"><a href="#6-可中断锁-不可中断锁" class="headerlink" title="6. 可中断锁/不可中断锁"></a>6. 可中断锁/不可中断锁</h4><ul><li>可中断指等待获取锁时可被中断从而取消等待；synchronized 是不可中断锁</li></ul><h4 id="7-偏向锁-轻量级锁-重量级锁"><a href="#7-偏向锁-轻量级锁-重量级锁" class="headerlink" title="7. 偏向锁/轻量级锁/重量级锁"></a>7. 偏向锁/轻量级锁/重量级锁</h4><ul><li>特指 synchronized 锁的几种状态</li><li>锁的升级路径：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</li><li>偏向锁：当一个线程第一次尝试获取某个对象的锁时，仅记录这个线程为偏向锁的拥有者，后续获取锁时如果是同个线程，就可以直接获取锁，开销很小，当多线程发生实际竞争时会升级为轻量级锁</li><li>轻量级锁：线程会通过自旋的方式尝试获取锁（自旋锁），不会阻塞，开销较小，当锁竞争时间较长时会膨胀为重量级锁</li><li>重量级锁：利用操作系统同步机制实现，会让线程进入阻塞状态，开销较大</li></ul><h4 id="8-JVM-对-synchronized-锁做了哪些优化？"><a href="#8-JVM-对-synchronized-锁做了哪些优化？" class="headerlink" title="8. JVM 对 synchronized 锁做了哪些优化？"></a>8. JVM 对 synchronized 锁做了哪些优化？</h4><ul><li>锁的升级：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</li><li>锁消除：虚拟机编译时，对一些代码上使用 synchronized 同步，但是被检测到不可能存在共享数据竞争的锁进行削除</li><li>锁粗化：把不间断、高频锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗</li></ul><h2 id="四、并发容器"><a href="#四、并发容器" class="headerlink" title="四、并发容器"></a>四、并发容器</h2><h4 id="1-Vector-HashTab"><a href="#1-Vector-HashTab" class="headerlink" title="1. Vector/HashTab"></a>1. Vector/HashTab</h4><ul><li>内部使用 synchronized 方法级别的锁保证线程安全，锁的粒度比较大</li><li>在并发量高的时候很容易发生竞争，并发效率比较低</li></ul><h4 id="2-ConcurrentHashMap"><a href="#2-ConcurrentHashMap" class="headerlink" title="2. ConcurrentHashMap"></a>2. ConcurrentHashMap</h4><ul><li>Java7 中基于普通的 HashMap 数组+链表结构，采用分段锁的机制</li><li>Java8 中基于数组+链表+红黑树结构，采用 CAS + synchronized 同步机制</li><li>红黑树相比链表可以提高查找效率，复杂度为 O(log(n))</li><li>为什么链表长度大于 8 时转换为红黑树？如果 hashCode 分布离散良好、链表符合泊松分布，那链表长度为 8 的概率小于千万分之一，红黑树更多的是一种保底策略，用来保证 hash 算法异常等极端情况下的查询效率</li><li>为什么不采取仅数组+红黑树的结构？红黑树节点相比链表占用内存约大一倍，而链表较短时查找也很快，所以优先采取链表结构</li></ul><h4 id="3-CopyOnWriteArrayList"><a href="#3-CopyOnWriteArrayList" class="headerlink" title="3. CopyOnWriteArrayList"></a>3. CopyOnWriteArrayList</h4><ul><li>基于 CopyOnWrite 机制，写入时会先创建一份副本，写完副本后直接替换原内容</li><li>优点：比读写锁更近一步，只需写写互斥，读取不用加锁，对于读多写少的场景可以大幅提升性能</li><li>缺点：写入时存在创建副本开销及副本所多占的内存，读写不互斥可能会导致数据无法及时保持同步</li></ul><h2 id="五、原子类"><a href="#五、原子类" class="headerlink" title="五、原子类"></a>五、原子类</h2><h4 id="1-基本类型原子类"><a href="#1-基本类型原子类" class="headerlink" title="1. 基本类型原子类"></a>1. 基本类型原子类</h4><ul><li>包括 AtomicInteger、AtomicLong、AtomicBoolean</li><li>提供了基本类型的 getAndSet、compareAndSet 等原子操作</li><li>底层基于 Unsafe#compareAndSwapInt、Unsafe#compareAndSwapLong 等实现</li></ul><h4 id="2-数组类型原子类"><a href="#2-数组类型原子类" class="headerlink" title="2. 数组类型原子类"></a>2. 数组类型原子类</h4><ul><li>包括 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</li><li>数组里的元素都可以保证其原子性，相当于把基本类型原子类聚合起来，组合成一个数组</li></ul><h4 id="3-引用类型原子类"><a href="#3-引用类型原子类" class="headerlink" title="3. 引用类型原子类"></a>3. 引用类型原子类</h4><ul><li>包括 AtomicReference、AtomicStampedReference、AtomicMarkableReference</li><li>用于让一个对象保证原子性，底层基于 Unsafe#compareAndSwapObject 等实现</li><li>AtomicStampedReference 是对 AtomicReference 的升级，在此基础上加了时间戳，用于解决 CAS 的 ABA 问题</li></ul><h4 id="4-升级类型原子类"><a href="#4-升级类型原子类" class="headerlink" title="4. 升级类型原子类"></a>4. 升级类型原子类</h4><ul><li>包括 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</li><li>对于非原子的基本或引用类型，在不改变其原类型的前提下，提供原子更新的能力</li><li>适用于由于历史原因改动成本太大或极少情况用到原子性的场景</li></ul><h4 id="5-累加器"><a href="#5-累加器" class="headerlink" title="5. 累加器"></a>5. 累加器</h4><ul><li>包括 LongAdder、DoubleAdder</li><li>相比于基本类型原子类，累加器没有 compareAndSwap、addAndGet 等方法，功能较少</li><li>设计原理：将 value 分散到一个数组中，不同线程只针对自己命中的槽位进行修改，减小高并发场景的线程竞争概率，类似于 ConcurrentHashMap 的分段锁思想</li><li>可解决高并发场景 AtomicLong 的过多自旋问题</li></ul><h4 id="6-积累器"><a href="#6-积累器" class="headerlink" title="6. 积累器"></a>6. 积累器</h4><ul><li>包括 LongAccumulator、DoubleAccumulator</li><li>是 LongAdder、DoubleAdder 的功能增强版，提供了自定义的函数操作</li></ul><h4 id="7-原子类与锁"><a href="#7-原子类与锁" class="headerlink" title="7. 原子类与锁"></a>7. 原子类与锁</h4><ul><li>都是为了保证并发场景下线程安全</li><li>原子类粒度更细，竞争范围为变量级别</li><li>原子类效率更高，底层采取 CAS 操作，不会阻塞线程</li><li>原子类不适用于高并发场景，因为无限循环的 CAS 操作会占用 CPU</li></ul><h4 id="8-原子类与-volatile"><a href="#8-原子类与-volatile" class="headerlink" title="8. 原子类与 volatile"></a>8. 原子类与 volatile</h4><ul><li>volatile 具有可见性和有序性，但不具备原子性</li><li>volatile 修饰 boolean 类型通常保证线程安全，因为赋值操作具有原子性</li><li>volatile 修饰 int 类型通常无法保证线程安全，因为 int 类型的计算操作需要读取、修改、赋值回去，不是原子操作，这时需要使用原子类</li></ul><h2 id="六、Java-内存模型"><a href="#六、Java-内存模型" class="headerlink" title="六、Java 内存模型"></a>六、Java 内存模型</h2><h4 id="1-内存结构与内存模型"><a href="#1-内存结构与内存模型" class="headerlink" title="1. 内存结构与内存模型"></a>1. 内存结构与内存模型</h4><ul><li>内存结构描述了 JVM 运行时内存区域结构，包括：堆、方法区、虚拟机栈、本地方法栈、程序计数器、运行时常量池</li><li>内存模型（JMM）是和多线程相关的一组规范，与 Java 并发编程有关</li></ul><h4 id="2-主内存和工作内存"><a href="#2-主内存和工作内存" class="headerlink" title="2. 主内存和工作内存"></a>2. 主内存和工作内存</h4><ul><li>CPU 有多级缓存，会存在数据不同步的情况，JMM 屏蔽了 CPU 缓存的底层细节，抽象为主内存和工作内存</li><li>工作内存中存在一份主内存数据的副本，每个线程只能接触工作内存，无法直接操作主内存</li></ul><h4 id="3-内存可见性"><a href="#3-内存可见性" class="headerlink" title="3. 内存可见性"></a>3. 内存可见性</h4><ul><li>指一个线程修改了工作内存的值后，其他线程能正确感知到最新的值</li><li>满足于 happens-before 关系的原则具备可见行，比如单线程、volatile、锁同步等规则</li></ul><h4 id="4-指令重排序"><a href="#4-指令重排序" class="headerlink" title="4. 指令重排序"></a>4. 指令重排序</h4><ul><li>编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是重排序</li><li>volatile 具备禁止重排序的特性</li><li>单例模式的双重检查模式需要添加 volatile 修饰，规避指令重排序导致的对象引用判断不为 null，但对象仍未初始化完的问题</li></ul><h2 id="七、线程协作"><a href="#七、线程协作" class="headerlink" title="七、线程协作"></a>七、线程协作</h2><h4 id="1-Semaphore"><a href="#1-Semaphore" class="headerlink" title="1. Semaphore"></a>1. Semaphore</h4><ul><li>通过控制许可证的发放和归还实现统一时刻可执行某任务的最大线程数</li><li>信号量可以被 FixedThreadPool 代替吗？不能，信号量具有可跨线程、跨线程池的特性，相比 FixedThreadPool 更灵活，更适合于限制并发访问的线程数</li></ul><h4 id="2-CountDownLatch"><a href="#2-CountDownLatch" class="headerlink" title="2. CountDownLatch"></a>2. CountDownLatch</h4><ul><li>用于并发流程控制，等到一个设定的数值达到之后，才能开始执行</li><li>不可重用，若已完成倒数，则不能再重置使用</li></ul><h4 id="3-CyclicBarrier"><a href="#3-CyclicBarrier" class="headerlink" title="3. CyclicBarrier"></a>3. CyclicBarrier</h4><ul><li>与 CountDownLatch 类似，都能阻塞一个或一组线程，直到某个预设的条件达成，再统一出发</li><li>CountDownLatch 作用于一个线程，CountDownLatch 作用于事件</li><li>可重用，若已达成条件，可重置继续使用</li><li>可定义条件达成后的自定义执行动作</li></ul><h2 id="八、AQS-框架"><a href="#八、AQS-框架" class="headerlink" title="八、AQS 框架"></a>八、AQS 框架</h2><h4 id="1-AQS-及存在的意义？"><a href="#1-AQS-及存在的意义？" class="headerlink" title="1. AQS 及存在的意义？"></a>1. AQS 及存在的意义？</h4><ul><li>AQS 是一个用于构建锁、同步器等线程协作工具类的框架，即 AbstractQueuedSynchronizer 类</li><li>ReentrantLock、Semaphore、CountDownLatch 等工具类的工作都是类似的，AQS 就是这些类似工作提取出来的公共部分，比如阀门功能、调度线程等</li><li>AQS 可以极大的减少上层工具类的开发工作量，也可以避免上层处理不当导致的线程安全问题</li></ul><h4 id="2-AQS-内部的关键原理"><a href="#2-AQS-内部的关键原理" class="headerlink" title="2. AQS 内部的关键原理"></a>2. AQS 内部的关键原理</h4><ul><li>state 值：AQS 中具有一个 int 类型的 state 变量，在不同工具类中代表不同的含义，比如在 Semaphore 中代表剩余许可证的数量；在 CountDownLatch 中代表需要倒数的数量；在 ReentrantLock 中代表锁的占有情况，0 代表没被占有，1 代表被占有，大于 1 代表同个线程重入了</li><li>FIFO 队列：用于存储、管理等待的线程</li><li>获取、释放锁：需工具类自行实现，比如 Semaphore#acquire、ReentrantLock#lock 为获取； Semaphore#release、ReentrantLock#unlock 为释放</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;线程基础&lt;/li&gt;
&lt;li&gt;线程池&lt;/li&gt;
&lt;li&gt;各种各样的锁&lt;/li&gt;
&lt;li&gt;并发容器&lt;/li&gt;
&lt;li&gt;原子类&lt;/li&gt;
&lt;li&gt;Java 内存模型&lt;/li&gt;
&lt;li&gt;线程协作&lt;/li&gt;
&lt;li&gt;AQS 框架&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yhaowa.gitee.io/yhaowa/categories/Java/"/>
    
    
      <category term="线程池" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="并发编程" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android 方法插桩 plugin 开发实践</title>
    <link href="http://yhaowa.gitee.io/yhaowa/a5b629de/"/>
    <id>http://yhaowa.gitee.io/yhaowa/a5b629de/</id>
    <published>2020-08-22T05:26:21.000Z</published>
    <updated>2020-12-06T06:59:08.630Z</updated>
    
    <content type="html"><![CDATA[<p>在做应用启动速度优化时，需先了解启动阶段做了哪些耗时任务，分析 Application 的 attachBaseContext、onCreate 等关键方法，统计它们内部调用到的其他方法耗时。</p><p>分析要结合 systrace 工具，因为不仅要知道方法的 wall time，还要知道 cpu time，这样才能知道是否属于 cpu 密集型任务，然后针对任务类型进行调整或线程调度。</p><p>需求很清晰，在要统计的方法调用前插桩加入 TraceCompat.beginSection()，调用后加入 TraceCompat.endSection()。需求也很简单，我们可以很快的使用 aspect、javassist 或 asm 实现。</p><p>但是，这次是方法插桩 + systrace，需为此开发一个插件；下次是方法插桩 + 耗时统计，就得再开发一个插件。为什么插件一定要与插桩逻辑绑定呢？</p><p><strong>为什么没有一款插件，只提供方法插桩能力，不写死插桩逻辑，而是由使用者自由的定制插桩逻辑呢？</strong></p><p>基于这个痛点，我们来开发一款可自由定制插桩逻辑的插件。</p><a id="more"></a><h2 id="AOP-方案选择"><a href="#AOP-方案选择" class="headerlink" title="AOP 方案选择"></a>AOP 方案选择</h2><p>首先是 AOP 技术方案的选择，aspect、javassist 还是 asm ？ 在思考了一秒钟后，我决定选择 asm，理由很简单：性能高、逼格高。</p><p>那要基于 gradle 及 asm 原生 API，从零开发吗？ NO，有些轮子不能造，我们要当坐在马车上驰骋的人！</p><p>所以我最终选择基于 ByteX 开发。</p><p>ByteX 与 Jetpack StartUp 有异曲同工之妙。</p><p>Startup 针对多个三方库各自使用 ContentProvider 初始化导致拖慢启动速度的问题，提供了一个 ContentProvider 来集中运行所有依赖项的初始化；ByteX 针对多个功能插件各自进行 transform 导致拖慢编译速度的问题，提供了一个宿主插件 transform，集中处理所有的 transform。</p><p>ByteX 对 Transform 及 ASM 相关 API 做了封装，大大节省了插件开发的工作量，我们无需处理 class/jar 的 IO 操作，只需关注想要进行的 hook 逻辑即可。</p><p>所以，通过性能及开发成本两个维度的考量，基于 ByteX 开发一些有意义的插件，是一个不错的选择。</p><h2 id="trace-plugin-插件"><a href="#trace-plugin-插件" class="headerlink" title="trace-plugin 插件"></a>trace-plugin 插件</h2><p>成果先行，目前 trace-plugin 已开发完并发布，见：<a href="https://github.com/yhaolpz/ByteXPlugin/tree/master/trace" target="_blank" rel="noopener">https://github.com/yhaolpz/ByteXPlugin/tree/master/trace</a> , 可查看插件源码及接入方式。</p><p>使用姿势很简单，仅 @TraceClass、@TraceMethod 两个注解而已：</p><h4 id="TraceClass-为类注解，可配置："><a href="#TraceClass-为类注解，可配置：" class="headerlink" title="@TraceClass 为类注解，可配置："></a>@TraceClass 为类注解，可配置：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定方法插桩实现类</span></span><br><span class="line"><span class="function">Class <span class="title">methodTrace</span><span class="params">()</span> <span class="keyword">default</span> TimeTrace.class</span>;</span><br><span class="line"><span class="comment">//是否要追踪此类中所有方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">traceAllMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"><span class="comment">//是否要追踪方法内部调用到的方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">traceInnerMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br></pre></td></tr></table></figure><h4 id="TraceMethod-为方法注解，可配置："><a href="#TraceMethod-为方法注解，可配置：" class="headerlink" title="@TraceMethod 为方法注解，可配置："></a>@TraceMethod 为方法注解，可配置：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否要追踪此方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">trace</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"><span class="comment">//是否要追踪方法内部调用到的方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">traceInnerMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br></pre></td></tr></table></figure><p><strong>举个例子</strong></p><p>Test 类中有 m1()、m2()、m3() 三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m2();</span><br><span class="line">        OtherClass.m4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>追踪 m1() 耗时：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TraceClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@TraceMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;...</span><br></pre></td></tr></table></figure><p><em>追踪类中所有方法耗时：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TraceClass</span>(traceAllMethod = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;...</span><br></pre></td></tr></table></figure><p><em>追踪类中所有方法耗时，但不包括 m1()：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TraceClass</span>(traceAllMethod = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@TraceMethod</span>(trace = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;...</span><br></pre></td></tr></table></figure><p><em>追踪 m1() 方法内部调用到的方法，即 m2()、OtherClass.m4() 的耗时：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TraceClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@TraceMethod</span>(trace = <span class="keyword">false</span>,traceInnerMethod = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m2();</span><br><span class="line">        OtherClass.m4();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><em>自定义追踪插桩处理：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自 IMethodTrace 方法实现自己的插桩处理，例如 systrace 追踪处理：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSysTrace</span> <span class="keyword">implements</span> <span class="title">IMethodTrace</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodEnter</span><span class="params">(String className, String methodName, String methodDesc, String outerMethod)</span> </span>&#123;</span><br><span class="line">        TraceCompat.beginSection(className + <span class="string">"#"</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodEnd</span><span class="params">(String className, String methodName, String methodDesc, String outerMethod)</span> </span>&#123;</span><br><span class="line">        TraceCompat.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类注解中指定即可</span></span><br><span class="line"><span class="meta">@TraceClass</span>(methodTrace = CustomSysTrace<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Test</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义插桩处理实现原理"><a href="#自定义插桩处理实现原理" class="headerlink" title="自定义插桩处理实现原理"></a>自定义插桩处理实现原理</h2><p>其实非常简单，插件内部对于需要插桩的方法会统一调用到 TraceRecord 类进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceRecord</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插桩方法执行前会统一调到这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onMethodEnter</span><span class="params">(String traceImplClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String className,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String methodName, String methodDesc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String outerMethod)</span> </span>&#123;</span><br><span class="line">        getMethodTrace(traceImplClass).onMethodEnter(className,</span><br><span class="line">                                methodName, methodDesc, outerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插桩方法执行完后会统一调到这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onMethodEnd</span><span class="params">(String traceImplClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   String className,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   String methodName, String methodDesc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   String outerMethod)</span> </span>&#123;</span><br><span class="line">        getMethodTrace(traceImplClass).onMethodEnd(className,</span><br><span class="line">                                methodName, methodDesc, outerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>traceImplClass 就是我们在类注解中指定的自定义插桩逻辑实现类，比如 CustomSysTrace ，然后在 getMethodTrace() 中实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IMethodTrace <span class="title">getMethodTrace</span><span class="params">(String traceImplClass)</span> </span>&#123;</span><br><span class="line">    IMethodTrace methodTrace = sMethodTraceMap.get(traceImplClass);</span><br><span class="line">    <span class="keyword">if</span> (methodTrace == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodTrace = (IMethodTrace) Class.forName(traceImplClass).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sMethodTraceMap.put(traceImplClass, methodTrace);</span><br><span class="line">    <span class="keyword">return</span> methodTrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有了简洁、优雅、易用、功能强大的 trace-plugin 插件，以后再也不怕方法插桩了，你想插什么就插什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做应用启动速度优化时，需先了解启动阶段做了哪些耗时任务，分析 Application 的 attachBaseContext、onCreate 等关键方法，统计它们内部调用到的其他方法耗时。&lt;/p&gt;
&lt;p&gt;分析要结合 systrace 工具，因为不仅要知道方法的 wall time，还要知道 cpu time，这样才能知道是否属于 cpu 密集型任务，然后针对任务类型进行调整或线程调度。&lt;/p&gt;
&lt;p&gt;需求很清晰，在要统计的方法调用前插桩加入 TraceCompat.beginSection()，调用后加入 TraceCompat.endSection()。需求也很简单，我们可以很快的使用 aspect、javassist 或 asm 实现。&lt;/p&gt;
&lt;p&gt;但是，这次是方法插桩 + systrace，需为此开发一个插件；下次是方法插桩 + 耗时统计，就得再开发一个插件。为什么插件一定要与插桩逻辑绑定呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么没有一款插件，只提供方法插桩能力，不写死插桩逻辑，而是由使用者自由的定制插桩逻辑呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于这个痛点，我们来开发一款可自由定制插桩逻辑的插件。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/yhaowa/categories/Android/"/>
    
    
      <category term="aop" scheme="http://yhaowa.gitee.io/yhaowa/tags/aop/"/>
    
      <category term="plugin" scheme="http://yhaowa.gitee.io/yhaowa/tags/plugin/"/>
    
      <category term="asm" scheme="http://yhaowa.gitee.io/yhaowa/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>如何绕过 Android 8.0 startService 限制？</title>
    <link href="http://yhaowa.gitee.io/yhaowa/a183dbba/"/>
    <id>http://yhaowa.gitee.io/yhaowa/a183dbba/</id>
    <published>2020-06-22T05:31:51.000Z</published>
    <updated>2020-12-06T09:26:42.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>限制了什么？</li><li>什么是前台应用?</li><li>正确理解后台服务限制</li><li>后台服务限制源码分析</li><li>适配 Android 8.0 startService 限制策略</li><li>如何绕过 Android 8.0 startService 限制？</li></ol></blockquote><a id="more"></a><p>应用在后台运行时，会消耗一部分有限的设备资源，例如 RAM。 这可能会影响用户体验，如果用户正在使用占用大量资源的应用（例如玩游戏或观看视频），影响会尤为明显。 为了提升用户体验，Android 8.0（API 级别 26）对应用在后台运行时可以执行的操作施加了限制。</p><h2 id="1-限制了什么？"><a href="#1-限制了什么？" class="headerlink" title="1. 限制了什么？"></a>1. 限制了什么？</h2><p><em>1. 后台应用对后台服务的访问受到限制</em></p><p>在不与用户直接交互的后台应用中，运行 Service 会消耗系统资源，这可能会影响前台应用的正常运行。Android 8.0 及更高版本<strong>不允许后台应用运行后台服务</strong>，需要通过 startForegroundService() 指定为前台服务运行，或者使用 JobScheduler 替代。</p><p><em>2. 注册隐式广播接收器受到限制</em></p><p>对于一些系统隐式广播（非全部），系统不允许应用在 AndroidManifest 中注册对应的广播接收器，从而避免系统广播导致诸多应用快速、连续消耗系统资源，从而影响用户体验，需要通过 Context.registerReceiver() 动态注册或 JobScheduler 代替。</p><p><em>3. 降低了后台应用接收位置更新的频率</em></p><p>为节约电池电量、保持良好的用户体验和确保系统健康运行，在运行 Android 8.0 的设备上使用后台应用时，降低了后台应用接收位置更新的频率。</p><h2 id="2-什么是前台应用"><a href="#2-什么是前台应用" class="headerlink" title="2. 什么是前台应用?"></a>2. 什么是前台应用?</h2><p>系统可以区分前台和后台应用。如果满足以下任意条件，应用将被视为处于前台：</p><ol><li>具有可见 Activity</li><li>具有前台 Service</li><li>另一个前台应用已关联到该应用（绑定 Service 或使用 content providers）</li></ol><p>如果以上条件均不满足，应用将被视为处于后台。</p><h2 id="3-正确理解后台服务限制"><a href="#3-正确理解后台服务限制" class="headerlink" title="3. 正确理解后台服务限制"></a>3. 正确理解后台服务限制</h2><p><strong>不允许后台应用运行后台服务</strong></p><p>官网的这句描述很简单，但你真的明白它的含义吗？顺着这句话推导一下：</p><p>后台应用无法启动后台服务</p><p>-&gt; 前台应用可以启动后台服务</p><p>-&gt; <em>A 为前台应用，则 A 就能启动后台服务</em></p><p>基于这个结论，再结合后台服务的种类，对以下三种场景实践验证，结果如下：</p><ol><li>若后台服务属于 A 应用进程，则能正常启动</li><li>若后台服务属于 B 应用进程，且 B 是前台应用，则能正常启动</li><li>若后台服务属于 B 应用进程，且 B 是后台应用，则<em>无法启动！</em></li></ol><p>通过第三种场景的验证结果，可以知道 <em>不允许后台应用运行后台服务</em> 这个描述是不准确、有歧义的，更精准的描述应该是：</p><p><strong>不允许启动属于后台应用的后台服务</strong></p><h2 id="4-后台服务限制源码分析"><a href="#4-后台服务限制源码分析" class="headerlink" title="4. 后台服务限制源码分析"></a>4. 后台服务限制源码分析</h2><p>若在 Android 8.0 设备上通过 startService 启动一个属于后台应用的后台服务，会直接崩溃：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Not allowed to start service Intent</span><br><span class="line">        &#123; act=intent.action.ServerService pkg=com.server &#125;: app is in background uid <span class="keyword">null</span></span><br><span class="line">   at android.app.ContextImpl.startServiceCommon(ContextImpl.java:<span class="number">1577</span>)</span><br><span class="line">   at android.app.ContextImpl.startService(ContextImpl.java:<span class="number">1532</span>)</span><br><span class="line">   at android.content.ContextWrapper.startService(ContextWrapper.java:<span class="number">664</span>)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>下面以此异常为线索，一步一步来看源码中是如何限制的。异常在 ContextImpl 中抛出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, <span class="keyword">boolean</span> requireForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">        mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                    getContentResolver()), requireForeground,</span><br><span class="line">                    getOpPackageName(), user.getIdentifier());</span><br><span class="line">    <span class="keyword">if</span> (cn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!"</span>)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"?"</span>)) &#123;</span><br><span class="line">            <span class="comment">//这里抛出启动服务限制的异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Not allowed to start service "</span> + service + <span class="string">": "</span> + cn.getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见关键点是 cn.getPackageName().equals(“?”) 条件成立， 继续看 AMS startService 方法中是如何返回这个 ComponentName 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">boolean</span> requireForeground, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ComponentName res;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid,</span><br><span class="line">                requireForeground, callingPackage, userId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS 中转调 ActiveServices 的 startServiceLocked 方法去处理服务的启动，关键代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> fgRequired, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> userId, <span class="keyword">boolean</span> allowBackgroundActivityStarts)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//非前台服务，需要检测是否满足后台服务启动条件，不满足则限制启动</span></span><br><span class="line">    <span class="keyword">if</span> (forcedStandby || (!r.startRequested &amp;&amp; !fgRequired)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> allowed = mAm.getAppStartModeLocked(r.appInfo.uid, r.packageName,</span><br><span class="line">                r.appInfo.targetSdkVersion, callingPid, <span class="keyword">false</span>, <span class="keyword">false</span>, forcedStandby);</span><br><span class="line">        <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123; <span class="comment">//不满足启动条件</span></span><br><span class="line">            <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DELAYED || forceSilentAbort) &#123;</span><br><span class="line">                <span class="comment">//这里返回 null 代表此场景下静默的限制启动，不通知应用</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//这里代表用户应知道此场景下不允许启动，所以返回 ComponentName，明确的通知应用</span></span><br><span class="line">            <span class="comment">//注意返回了 "?"，是导致应用崩溃的原因</span></span><br><span class="line">            UidRecord uidRec = mAm.mProcessList.getUidRecordLocked(r.appInfo.uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"?"</span>, <span class="string">"app is in background uid "</span> + uidRec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此可以知道关键在于 mAm.getAppStartModeLocked 方法，如果返回 APP_START_MODE_NORMAL 则代表满足启动条件，不会被限制。</p><p>mAm 为 ActivityManagerService，继续看 ActivityManagerService 的 getAppStartModeLocked 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAppStartModeLocked</span><span class="params">(<span class="keyword">int</span> uid, String packageName, <span class="keyword">int</span> packageTargetSdk,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">boolean</span> alwaysRestrict, <span class="keyword">boolean</span> disabledOnly, <span class="keyword">boolean</span> forcedStandby)</span> </span>&#123;</span><br><span class="line">    UidRecord uidRec = mProcessList.getUidRecordLocked(uid);</span><br><span class="line">    <span class="comment">//注意传入的 alwaysRestrict、forcedStandby 都为 false，暂不关注</span></span><br><span class="line">    <span class="keyword">if</span> (uidRec == <span class="keyword">null</span> || alwaysRestrict || forcedStandby || uidRec.idle) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startMode = (alwaysRestrict)</span><br><span class="line">                ? appRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk)</span><br><span class="line">                : appServicesRestrictedInBackgroundLocked(uid, packageName,</span><br><span class="line">                        packageTargetSdk);</span><br><span class="line">        <span class="keyword">return</span> startMode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uidRec 为该服务所在应用，uidRec == null 代表应用还未启动，uidRec.idle 代表应用处于后台。应用未启动可以看作处于后台，当然也是不允许启动后台服务的。</p><p>继续看 appServicesRestrictedInBackgroundLocked 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">appServicesRestrictedInBackgroundLocked</span><span class="params">(<span class="keyword">int</span> uid, String packageName, <span class="keyword">int</span> packageTargetSdk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManagerInt.isPackagePersistent(packageName)) &#123;</span><br><span class="line">        <span class="comment">//系统永久应用不做限制</span></span><br><span class="line">        <span class="keyword">return</span> ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (uidOnBackgroundWhitelist(uid)) &#123;</span><br><span class="line">        <span class="comment">//白名单应用不做限制</span></span><br><span class="line">        <span class="keyword">return</span> ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isOnDeviceIdleWhitelistLocked(uid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">//白名单应用不做限制</span></span><br><span class="line">        <span class="keyword">return</span> ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他应用走通用的限制策略</span></span><br><span class="line">    <span class="keyword">return</span> appRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通应用会走通用的限制策略，继续看 appRestrictedInBackgroundLocked 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">appRestrictedInBackgroundLocked</span><span class="params">(<span class="keyword">int</span> uid, String packageName, <span class="keyword">int</span> packageTargetSdk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packageTargetSdk &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManager.APP_START_MODE_DELAYED_RIGID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//tartget API 小于 8.0 的应用走旧的限制策略，众所周知的不会被限制</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里对 tartget API 做的限制，8.0 及以上的应用会被限制启动服务，是上层抛出异常的根本原因。</p><h2 id="5-适配-Android-8-0-startService-限制策略"><a href="#5-适配-Android-8-0-startService-限制策略" class="headerlink" title="5. 适配 Android 8.0 startService 限制策略"></a>5. 适配 Android 8.0 startService 限制策略</h2><p>了解了系统的限制原理后，结合上文对 AMS 启动服务限制的源码分析，列举可能的适配方案：</p><ol><li>使用 startForegroundService 代替</li><li>使用 JobScheduler 代替</li><li>设置应用为 Persisten 系统永久应用类型</li><li>将应用加入到系统白名单</li><li>将应用的 targetSdkVersion 调整为小于 Android 8.0 的版本</li><li>启动服务前，先将服务所在应用从后台切换到前台</li></ol><p>方案 1 是工作量较小的兼容旧代码方案，但会显示一条通知，这可能不是我们想要的</p><p>方案 2 是官方建议方案，兼容工作量比方案 1 多</p><p>方案 3 和方案 4 需要系统侧配合，适用于系统或预装应用，对绝大多数的第三方应用来说不可行</p><p>方案 5 可行，但极不推荐这种固步自封的方式</p><p>方案 6 可行，但不符合谷歌推进此限制策略的意愿，违背提高用户体验的初衷</p><h2 id="6-如何绕过-Android-8-0-startService-限制？"><a href="#6-如何绕过-Android-8-0-startService-限制？" class="headerlink" title="6. 如何绕过 Android 8.0 startService 限制？"></a>6. 如何绕过 Android 8.0 startService 限制？</h2><p>别忘了标题，最终想要实现的是绕过 Android 8.0 startService 的限制，即不修改为前台服务，调用 startService 方法，仍旧可以启动属于后台应用的后台服务，怎么实现呢？</p><p>通过上面的方案 6 ：<strong>启动服务前，先将服务所在应用从后台切换到前台</strong> 便可实现，如何将应用从后台切换到前台呢？上文介绍了应用被视为处于前台的条件：</p><ol><li>具有可见 Activity</li><li>具有前台 Service</li><li>另一个前台应用已关联到该应用</li></ol><p>依据条件 1 可想到一种实现方案：</p><blockquote><p>如果应用处于后台，就启动一个透明的、用户无感知的 Activity，将应用切换到前台，然后再通过 startService 启动服务，随后 finish 掉透明 Activity。</p></blockquote><p>调用端这样 startService ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Intent serviceIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">serviceIntent.setAction(<span class="string">"com.ahab.server.service"</span>);</span><br><span class="line">serviceIntent.setPackage(<span class="string">"com.ahab.server"</span>);</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        context.startService(serviceIntent);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        Intent activityIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        activityIntent.setAction(<span class="string">"com.ahab.server.TranslucentActivity"</span>);</span><br><span class="line">        activityIntent.setPackage(<span class="string">"com.ahab.server"</span>);</span><br><span class="line">        activityIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        context.startActivity(activityIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    context.startService(serviceIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动透明 Activity 后 startService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TranslucentActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Intent serviceIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        serviceIntent.setAction(<span class="string">"com.ahab.server.service"</span>);</span><br><span class="line">        serviceIntent.setPackage(<span class="string">"com.ahab.server"</span>);</span><br><span class="line">        context.startService(serviceIntent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到代码实现十分简单。上面都是围绕 startService 方式来讲，没有提及 <strong>bindService</strong> 服务启动方式，系统并未直接对 bindService 限制服务启动。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;限制了什么？&lt;/li&gt;
&lt;li&gt;什么是前台应用?&lt;/li&gt;
&lt;li&gt;正确理解后台服务限制&lt;/li&gt;
&lt;li&gt;后台服务限制源码分析&lt;/li&gt;
&lt;li&gt;适配 Android 8.0 startService 限制策略&lt;/li&gt;
&lt;li&gt;如何绕过 Android 8.0 startService 限制？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/yhaowa/categories/Android/"/>
    
    
      <category term="service" scheme="http://yhaowa.gitee.io/yhaowa/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>细读《深入理解-Android-内核设计思想》（六）GUI 系统 [上]</title>
    <link href="http://yhaowa.gitee.io/yhaowa/38614e33/"/>
    <id>http://yhaowa.gitee.io/yhaowa/38614e33/</id>
    <published>2020-05-17T09:37:42.000Z</published>
    <updated>2020-12-06T09:18:58.311Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>GUI 系统综述</li><li>BufferQueue 与图像数据流</li><li>Gralloc</li><li>ANativeWindow</li><li>FrameBufferNativeWindow</li><li>FramebufferSurface</li><li>最后</li></ol></blockquote><a id="more"></a><p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em></p><h2 id="GUI-系统综述"><a href="#GUI-系统综述" class="headerlink" title="GUI 系统综述"></a>GUI 系统综述</h2><p>GUI（Graphical User Interface）即图形用户界面，官方架构图如下：</p><p><img src="../img/ape_fwk_graphics.png" alt></p><p><strong>IMAGE STREAM PRODUCERS 图像流生产方</strong>：生成图形缓冲区以供消耗的任何内容，例如 OpenGL ES、Canvas 2D 和 mediaserver 视频解码器都是图像流生产方。</p><p><strong>IMAGE STREAM CONSUMERS 图像流消耗方</strong>：图像流最常见的消耗方是 SurfaceFlinger，该系统服务接收来自于多个源的数据缓冲区，组合它们，并将它们发送给显示设备。除了 SurfaceFlinger，OpenGL ES 应用也可以消耗图像流，例如相机应用会消耗相机预览图像流，另外非 GL 应用也可以消耗图像流，例如 ImageReader 类。SurfaceFlinger 使用 OpenGL 和 Hardware Composer 来合成一组 Surface。</p><p><strong>WindowManager</strong>：WindowManager 会控制 window 对象，window 是用于容纳视图对象的容器。window 对象由 Surface 对象提供支持。WindowManager 会监督生命周期、输入和聚焦事件、屏幕方向、转换、动画、位置、变形、Z 轴顺序等窗口事件。WindowManager 会将所有窗口元数据发送到 SurfaceFlinger，以便 SurfaceFlinger 可以使用这些数据合成 Surface。</p><p><strong>Surface</strong>：无论开发者使用什么渲染 API，一切内容都会渲染到 Surface 上，Surface 即供 UI 应用程序绘制图像的 “画板”，承载应用要渲染的图像数据。应用端可以使用 OpenGL ES 、Vulkan 或 Canvas API 渲染到 Surface 上。</p><p><strong>Hardware Composer 硬件混合渲染器(HWC)</strong>：用于确定组合缓冲区的最有效方式，作为 HAL 硬件抽象层，其实现是基于特定设备的，通常由屏幕硬件设备制造商 (OEM) 完成。SurfaceFlinger 在收集可见层的所有缓冲区后，便会询问 HWC 应如何进行合成。如果 HWC 将层合成类型标记为客户端合成，则 SurfaceFlinger 会合成这些层，然后 SurfaceFlinger 会将输出缓冲区传递给 HWC。</p><p><strong>Gralloc</strong>：包括 fb 和 gralloc 两个设备，fb 负责打开内核中的 FrameBuffer、初始化配置，并提供了 post、setSwapInterval 等操作接口；gralloc 负责管理帧缓冲区的分配和释放。作为 HAL，上层都会通过 Gralloc 来访问内核显示设备的帧缓冲区。</p><h2 id="BufferQueue-与图像数据流"><a href="#BufferQueue-与图像数据流" class="headerlink" title="BufferQueue 与图像数据流"></a>BufferQueue 与图像数据流</h2><p>图像流由生产方流向消耗方，这种典型的生产者-消费者模型都是需要一个缓冲区队列的，BufferQueue 就是这个队列，它将图像流生产方与消耗方结合在一起，并且可以调解图像流从生产方到消耗方的固定周期。</p><p><img src="../img/bufferqueue.png" alt></p><p>如图，生产方通过 dequeue 向 BufferQueue 申请空闲的缓冲区，将图像数据存放进去，然后通过 queue 移交给 BufferQueue。消耗方通过 acquire 从 BufferQueue 中获取图像数据缓冲区，然后进行合成显示或处理后，再将缓冲区交还给 BufferQueue。</p><p>对应到显示场景，应用程序作为生产方将图像数据交给 BufferQueue；SurfaceFlinger 则作为消耗方从 BufferQueue 中取出来，然后合成图像数据。</p><h2 id="Gralloc"><a href="#Gralloc" class="headerlink" title="Gralloc"></a>Gralloc</h2><p>FrameBuffer 是 Linux 内核中图像硬件的抽象描述，是一块包含屏幕显示信息的缓冲区。FrameBuffer 对上层提供了统一的显示驱动，设备节点为 /dev/graphics/fb<em> 或 /dev/fb</em>，其中 fb0 标示第一个 Monitor，当前系统实现中只用到了一个显示屏。</p><p>Android 的各个子系统通常不会直接使用硬件的内核驱动，而是通过 HAL 层间接使用。显示系统也是如此，上层统一通过 HAL 层的 Gralloc 来操作内核的帧缓冲区。</p><p>先来看 Gralloc 模块的加载，它是在 FramebufferNativeWindow（OpenGL ES 的本地窗口之一，下面还会提到）的构造函数中加载的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/ui/FramebufferNativeWindow.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_MODULE_ID <span class="meta-string">"gralloc"</span></span></span><br><span class="line"></span><br><span class="line">framebufferNativeWindow::framebufferNativeWindow() </span><br><span class="line">    : BASE(),fbDev(<span class="number">0</span>),grDev(<span class="number">0</span>),mUpdateOnDemand(<span class="literal">false</span>)&#123;</span><br><span class="line">    hw_module_t <span class="keyword">const</span>* module;</span><br><span class="line">    <span class="comment">//加载 Gralloc 模块</span></span><br><span class="line">    <span class="keyword">if</span>(hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module) == <span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        err = framebuffer_open(module, &amp;fbDev); <span class="comment">//打开 fb 设备</span></span><br><span class="line">        err = gralloc_open(module, &amp;grDev); <span class="comment">//打开 gralloc 设备</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>hw_get_module 函数是上层加载 HAL 库的统一入口，不论是哪个硬件厂商提供的 HAL 库，都是通过此函数来加载的。hw_get_module 方法会在指定的路径下查找与 GRALLOC_HARDWARE_MODULE_ID 匹配的库，默认会使用 Android 原生态的实现：gralloc.default.so，此 so 主要由 gralloc.cpp，framebuffer.cpp，mapper.cpp 三个源文件编译生成。</p><p>加载 Gralloc 后，会分别打开 fb（frameBuffer） 和 gralloc（gpu）设备，framebuffer_open 和 gralloc_open 最终都会调用到 gralloc.cpp 的 gralloc_device_open 方法，只不过传入的设备名不一样：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_FB0 <span class="meta-string">"fb0"</span> <span class="comment">//fb 设备名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_GPU0 <span class="meta-string">"gpu0"</span> <span class="comment">//gralloc 设备名</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hardware/libhardware/modules/gralloc/gralloc.cpp</span></span><br><span class="line"><span class="keyword">int</span> gralloc_device_open(<span class="keyword">const</span> hw_module_t* module, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span><br><span class="line">                            hw_device_t** device)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>书中分析了 fb 及 gralloc 设备的打开过程源码，本文不再分析，源码见：<a href="http://androidxref.com/7.0.0_r1/xref/hardware/libhardware/modules/gralloc/gralloc.cpp#gralloc_device_open" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/hardware/libhardware/modules/gralloc/gralloc.cpp#gralloc_device_open</a> 。直接来看 fb 及 gralloc 设备的主要功能：</p><p><img src="../img/Gralloc.jpg" alt></p><p>gralloc 设备比较简单，主要负责图形缓冲区的分配与释放。下面来看下 fb 设备的方法说明：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 buffer 数据 post 到显示屏上，要求 buffer 必须与屏幕尺寸一致,</span></span><br><span class="line"><span class="comment">//并且没有被 locked。这样 buffer 内容将在下一次 VSYNC 中被显示出来</span></span><br><span class="line"><span class="keyword">int</span>(*post)(<span class="keyword">struct</span> framebuffer_device_t* dev, buffer_handle_t buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置两个缓冲区交换的时间间隔</span></span><br><span class="line"><span class="keyword">int</span>(*setSwapInterval)(<span class="keyword">struct</span> framebuffer_device_t* window, <span class="keyword">int</span> interval);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置刷新区域，需要 framebuffer 驱动支持 update-on-demand。</span></span><br><span class="line"><span class="comment">//也就是说，在这个区域外的数据很可能被认为是无效的</span></span><br><span class="line"><span class="keyword">int</span>(*setUpdateRect)(<span class="keyword">struct</span> framebuffer_device_t* window, </span><br><span class="line">                        <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br></pre></td></tr></table></figure><h2 id="ANativeWindow"><a href="#ANativeWindow" class="headerlink" title="ANativeWindow"></a>ANativeWindow</h2><p>Android 的 GUI 基于 OpenGL ES，而 OpenGL ES 是跨平台的，并不是针对某一个特定的操作系统平台设计的。这就需要一个本地窗口来适配特定的系统环境，充当 OpenGL ES 与特定系统的中介。</p><p>EGLNativeWindowType 是 EGL 中定义的平台相关类型，它在不同系统中对应的是不同的数据类型，而在 Android 中对应的是 ANativeWindow 指针：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//framework/native/opengl/include/egl/Eglplatform.h //Android 系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__ANDROID__) || defined(ANDROID)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ANativeWindow;</span><br><span class="line"><span class="keyword">struct</span> egl_native_pixmap_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ANativeWindow*           EGLNativeWindowType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> egl_native_pixmap_t*     EGLNativePixmapType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>*                           EGLNativeDisplayType;</span><br></pre></td></tr></table></figure><p>ANativeWindow 结构如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ANativeWindow&#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    <span class="keyword">int</span>   minSwapInterval; <span class="comment">//支持的最小交换间隔时间</span></span><br><span class="line">    <span class="keyword">int</span>   maxSwapInterval; <span class="comment">//支持的最大交换间隔时间</span></span><br><span class="line">    <span class="keyword">float</span> xdpi; <span class="comment">//水平方向的密度，以 dp 为单位</span></span><br><span class="line">    <span class="keyword">float</span> ydpi; <span class="comment">//竖直方向的密度，以 dp 为单位</span></span><br><span class="line">    intptr_t    oem[<span class="number">4</span>]; <span class="comment">//为 OEM 定制驱动所保留的空间</span></span><br><span class="line">    <span class="comment">//设置交换间隔时间</span></span><br><span class="line">    <span class="keyword">int</span> (*setSwapInterval)(<span class="keyword">struct</span> ANativeWindow* window, <span class="keyword">int</span> interval);</span><br><span class="line">    <span class="comment">//申请一个 buffer，即出队一个空闲缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> (*dequeueBuffer)(<span class="keyword">struct</span> ANativeWindow* window, </span><br><span class="line">                        <span class="keyword">struct</span> ANativeWindowBuffer** buffer);</span><br><span class="line">    <span class="comment">//当 EGL 渲染完一块 buffer 后，调用此接口来 unlock 和 post buffer</span></span><br><span class="line">    <span class="keyword">int</span> (*queueBuffer)(<span class="keyword">struct</span> ANativeWindow* window, </span><br><span class="line">                        <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="comment">//取消一个已经 dequeued 的 buffer</span></span><br><span class="line">    <span class="keyword">int</span> (*cancelBuffer)(<span class="keyword">struct</span> ANativeWindow* window, </span><br><span class="line">                        <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="comment">//用于向本地窗口查询相关信息</span></span><br><span class="line">    <span class="keyword">int</span> (*query)(<span class="keyword">const</span> <span class="keyword">struct</span> ANativeWindow* window, <span class="keyword">int</span> what, <span class="keyword">int</span>* value);</span><br><span class="line">    <span class="comment">//用于执行本地窗口支持的各种操作，比如</span></span><br><span class="line">    <span class="comment">//NATIVE_WINDOW_SET_CROP、NATIVE_WINDOW_SET_BUFFER_COUNT 等等</span></span><br><span class="line">    <span class="keyword">int</span> (*perform)(<span class="keyword">struct</span> ANativeWindow* window, <span class="keyword">int</span> operation, ... );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 ANativeWindow 的结构可以看出，它更像是一份协议，规定了一个本地窗口的形态和功能。FrameBufferNativeWindow 和 Surface 都履行了这份协议，可以看作 ANativeWindow 的两个实现。</p><h2 id="FrameBufferNativeWindow"><a href="#FrameBufferNativeWindow" class="headerlink" title="FrameBufferNativeWindow"></a>FrameBufferNativeWindow</h2><p>在介绍 Gralloc 时提到 Gralloc 设备是在 FrameBufferNativeWindow 的构造函数中打开的，这代表 FrameBufferNativeWindow 可以直接通过 Gralloc 操控屏幕帧内容的展示；在介绍 ANativeWindow 时提到 FrameBufferNativeWindow 实现了 ANativeWindow 接口，这代表上层可以通过 ANativeWindow 中定义的方法来调用 FrameBufferNativeWindow。</p><p>FrameBufferNativeWindow 的构造函数关键代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/ui/FramebufferNativeWindow.cpp</span></span><br><span class="line">framebufferNativeWindow::framebufferNativeWindow() </span><br><span class="line">    : BASE(),fbDev(<span class="number">0</span>),grDev(<span class="number">0</span>),mUpdateOnDemand(<span class="literal">false</span>)&#123;</span><br><span class="line">    hw_module_t <span class="keyword">const</span>* module;</span><br><span class="line">    <span class="comment">//加载 Gralloc 模块</span></span><br><span class="line">    <span class="keyword">if</span>(hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module) == <span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        err = framebuffer_open(module, &amp;fbDev); <span class="comment">//打开 fb 设备</span></span><br><span class="line">        err = gralloc_open(module, &amp;grDev); <span class="comment">//打开 gralloc 设备</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//初始化帧缓冲区相关的变量 </span></span><br><span class="line">        mNumBuffers = NUM_FRAME_BUFFERS; </span><br><span class="line">        mNumFreeBuffers = NUM_FRAME_BUFFERS;</span><br><span class="line">        mBufferHead = mNumBuffers<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mNumBuffers; i++)&#123; <span class="comment">//创建 NativeBuffer  </span></span><br><span class="line">            buffers[i] = new NativeBuffer(fbDev-&gt;width, fbDev-&gt;height, </span><br><span class="line">                                fbDev-&gt;format, GRALLOC_USAGE_HW_FB);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mNumBuffers; i++)&#123;<span class="comment">//为 NativeBuffer 分配空间  </span></span><br><span class="line">                err = grDev-&gt;alloc(grDev,fbDev-&gt;width, fbDev-&gt;height, </span><br><span class="line">                        fbDev-&gt;format, GRALLOC_USAGE_HW_FB, </span><br><span class="line">                        &amp;buffers[i]-&gt;handle, &amp;buffers[i]-&gt;stride);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化本地窗口 ANativeWindow 的相关属性  </span></span><br><span class="line">        const_cast&lt;uint32_t&amp;&gt;(ANativeWindow::flags) = fbDev-&gt;flags;   </span><br><span class="line">        const_cast&lt;<span class="keyword">float</span>&amp;&gt;(ANativeWindow::xdpi) = fbDev-&gt;xdpi;  </span><br><span class="line">        const_cast&lt;<span class="keyword">float</span>&amp;&gt;(ANativeWindow::ydpi) = fbDev-&gt;ydpi;  </span><br><span class="line">        const_cast&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::minSwapInterval) = fbDev-&gt;minSwapInterval;  </span><br><span class="line">        const_cast&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::maxSwapInterval) = fbDev-&gt;maxSwapInterval;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ALOGE(<span class="string">"Couldn't get gralloc module"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//本地窗口 ANativeWindow 的接口函数实现  </span></span><br><span class="line">    ANativeWindow::setSwapInterval = setSwapInterval;  </span><br><span class="line">    ANativeWindow::dequeueBuffer = dequeueBuffer;  </span><br><span class="line">    ANativeWindow::lockBuffer = lockBuffer;  </span><br><span class="line">    ANativeWindow::queueBuffer = queueBuffer;  </span><br><span class="line">    ANativeWindow::query = query;  </span><br><span class="line">    ANativeWindow::perform = perform;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameBufferNativeWindow 的构造函数主要做了以下工作：</p><ol><li>加载 Gralloc 模块，分别打开 fb 和 gralloc 设备</li><li>根据 fb 设备描述来初始化 FrameBufferNativeWindow，包括申请缓冲区及初始化本地窗口属性值</li><li>根据 FrameBufferNativeWindow 的实现来填充 ANativeWindow 中的”协议”</li></ol><p>可以看到帧缓冲区的数量为 mNumBuffers，FrameBufferNativeWindow 对应的是 1 个真实的物理屏幕，那为什么要准备多个 buffer 呢？这就是所谓的双缓冲/多缓冲技术，至少 2 个buffer，一个为 screen-buffer（用户直接看到的东西），一个为 off-screen-buffer（即将呈现给用户的东西），通过 swap buffer 交替显示，避免屏幕撕裂现象，以保证用户任何时候看到的都是完整的画面。</p><p>再来看 FrameBufferNativeWindow 中另一个重要的 dequeueBuffer 函数，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window,</span><br><span class="line">        ANativeWindowBuffer** buffer)&#123;</span><br><span class="line">    <span class="comment">//将 ANativeWindow 强转为 FramebufferNativeWindow</span></span><br><span class="line">    FramebufferNativeWindow* <span class="keyword">self</span> = getSelf(window);</span><br><span class="line">    Mutex::Autolock _l(<span class="keyword">self</span>-&gt;mutex); <span class="comment">//函数执行结束后自动释放锁</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//计算 mBufferHead，超出 mNumBuffers 时重指向 0 循环</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="keyword">self</span>-&gt;mBufferHead++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;mBufferHead &gt;= <span class="keyword">self</span>-&gt;mNumBuffers)</span><br><span class="line">        <span class="keyword">self</span>-&gt;mBufferHead = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//如果当前没有空闲的 buffer，即 mNumFreeBuffers = 0，则睡眠等待 buffer 的释放</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">self</span>-&gt;mNumFreeBuffers) &#123;</span><br><span class="line">        <span class="keyword">self</span>-&gt;mCondition.wait(<span class="keyword">self</span>-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存在了空闲 buffer 线程被唤醒，由于此时要申请一块 buffer，因此空闲 buffer 数减 1</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;mNumFreeBuffers--;</span><br><span class="line">    <span class="comment">// 保存当前申请的 buffer 在缓冲区数组中的索引位置</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;mCurrentBufferIndex = index;</span><br><span class="line">    <span class="comment">// 得到 buffer 数组中的 NativeBuffer 对象指针</span></span><br><span class="line">    *buffer = <span class="keyword">self</span>-&gt;buffers[index].get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dequeueBuffer 函数就是从 FramebufferNativeWindow 创建的缓冲区队列中取出一块空闲可用的 buffer，如果当前缓冲区队列中没有空闲的 buffer，则当前线程阻塞等待，等待其他线程释放图形缓冲区。</p><p>mNumFreeBuffers 用来描述可用的空闲 buffer 个数，mBufferHead 指向下一次申请的图形 buffer 的位置。由于是循环利用缓冲区，所以如果 mBufferHead 的值超过 mNumBuffers，就需要置 0。</p><p>再来看与之对应的 queueBuffer 函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> FramebufferNativeWindow::queueBuffer(ANativeWindow* window, </span><br><span class="line">                    ANativeWindowBuffer* buffer)&#123;</span><br><span class="line">    FramebufferNativeWindow* <span class="keyword">self</span> = getSelf(window);</span><br><span class="line">    Mutex::Autolock _l(<span class="keyword">self</span>-&gt;mutex);</span><br><span class="line">    framebuffer_device_t* fb = <span class="keyword">self</span>-&gt;fbDev;</span><br><span class="line">    buffer_handle_t handle = static_cast&lt;NativeBuffer*&gt;(buffer)-&gt;handle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = <span class="keyword">self</span>-&gt;mCurrentBufferIndex;</span><br><span class="line">    <span class="comment">//调用 fb 设备的 post 函数将绘制好的 buffer 渲染到 framebuffer</span></span><br><span class="line">    <span class="keyword">int</span> res = fb-&gt;post(fb, handle);</span><br><span class="line">    <span class="keyword">self</span>-&gt;front = static_cast&lt;NativeBuffer*&gt;(buffer);</span><br><span class="line">    <span class="comment">//当前 buffer 已经渲染完，将当前 buffer 入列，从而可以被申请</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;mNumFreeBuffers++;</span><br><span class="line">    <span class="comment">//唤醒申请 buffer 被阻塞等待的线程，表示已有空闲 buffer 可以被申请</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;mCondition.broadcast();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将调用 fb 设备的 post 方法将 buffer 渲染到屏幕上，然后修改空闲 buffer 个数，最后唤醒正在申请图形 buffer 出列却因无空闲 buffer 而睡眠的线程。</p><h2 id="FramebufferSurface"><a href="#FramebufferSurface" class="headerlink" title="FramebufferSurface"></a>FramebufferSurface</h2><p>Android 4.2 版本后不再使用 FramebufferNativeWindow，随着版本的升级，相关的代码一直在变动，从 FramebufferNativeWindow 到 SurfaceTextureClient，再到 FramebufferSurface… 变动历史可参考：<a href="https://www.cnblogs.com/bbqzsl/p/7826141.html" target="_blank" rel="noopener">https://www.cnblogs.com/bbqzsl/p/7826141.html</a> 。</p><p>本以为 FramebufferSurface 已经稳定，可发现即使是 FramebufferSurface，在 7.0 和 9.0 版本上的实现也不相同。这里就不再纠结各版本的 API 变动，只对比下 FramebufferNativeWindow 与 FramebufferSurface 的送显逻辑。</p><p>FramebufferNativeWindow 被 FramebufferSurface 代替后，原本 FramebufferNativeWindow 中的 fb 设备交由 HWComposer 管理，FramebufferSurface 中不再直接持有 fb 设备，而是通过 HWComposer 去控制屏幕显示。</p><p>对上层来说，FramebufferNativeWindow 与 FramebufferSurface 可以看作真实的物理屏幕，它们都直接或间接的与 fb 设备交互。所谓的 “上层”，一般就是指 SurfaceFlinger，在较早版本，它可以这样通过 FramebufferNativeWindow 将内容送显：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Android 2.3.7 版本</span></span><br><span class="line"><span class="comment">//frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="keyword">bool</span> SurfaceFlinger::handleBypassLayer()&#123;</span><br><span class="line">    sp&lt;Layer&gt; bypassLayer(mBypassLayer.promote());</span><br><span class="line">    <span class="keyword">if</span> (bypassLayer != <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; buffer(bypassLayer-&gt;getBypassBuffer());</span><br><span class="line">        <span class="keyword">if</span> (buffer!=<span class="number">0</span> &amp;&amp; (buffer-&gt;usage &amp; GRALLOC_USAGE_HW_FB)) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayHardware&amp; hw(graphicPlane(<span class="number">0</span>).displayHardware());</span><br><span class="line">            <span class="comment">//调用 DisplayHardware 送显</span></span><br><span class="line">            hw.postBypassBuffer(buffer-&gt;handle);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp</span></span><br><span class="line"><span class="keyword">void</span> DisplayHardware::init(uint32_t dpy)&#123;</span><br><span class="line">    <span class="comment">// FramebufferNativeWindow 封装在 DisplayHardware 中</span></span><br><span class="line">    mNativeWindow = new FramebufferNativeWindow();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t DisplayHardware::postBypassBuffer(<span class="keyword">const</span> native_handle_t* handle) <span class="keyword">const</span>&#123;</span><br><span class="line">   <span class="comment">//获取 FramebufferNativeWindow 中打开的 fb 设备</span></span><br><span class="line">   framebuffer_device_t *fbDev = (framebuffer_device_t *)mNativeWindow-&gt;getDevice();</span><br><span class="line">   <span class="comment">//调用 fb 设备送显</span></span><br><span class="line">   <span class="keyword">return</span> fbDev-&gt;post(fbDev, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面通过 FramebufferNativeWindow 送显的逻辑比较简单，调用链为： SurfaceFlinger -&gt; DisplayHardware -&gt; FramebufferNativeWindow -&gt; fb 设备 。</p><p>下面来看 FramebufferSurface 的送显逻辑，它便没那么直观了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Android 7.0</span></span><br><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::doDisplayComposition(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">        <span class="keyword">const</span> Region&amp; inDirtyRegion)&#123;</span><br><span class="line">    <span class="comment">// ...省略 doComposeSurfaces 等合成工作</span></span><br><span class="line">    <span class="comment">// 合成后通过 swap buffers 送显</span></span><br><span class="line">    hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp</span></span><br><span class="line"><span class="keyword">void</span> FramebufferSurface::onFrameAvailable(<span class="keyword">const</span> BufferItem&amp; <span class="comment">/* item */</span>) &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    status_t err = nextBuffer(buf, acquireFence);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用 HWComposer</span></span><br><span class="line">    err = mHwc.fbPost(mDisplayType, acquireFence, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer_hwc1.cpp</span></span><br><span class="line"><span class="keyword">int</span> HWComposer::fbPost(int32_t <span class="keyword">id</span>,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; acquireFence, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> setFramebufferTarget(<span class="keyword">id</span>, acquireFence, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acquireFence-&gt;waitForever(<span class="string">"HWComposer::fbPost"</span>);</span><br><span class="line">        <span class="comment">//调用 fb 设备送显</span></span><br><span class="line">        <span class="keyword">return</span> mFbDev-&gt;post(mFbDev, buffer-&gt;handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会有疑问，swapBuffers 是怎么触发 FramebufferSurface 的 onFrameAvailable 回调的呢？它是通过生产者-消费者模式通知调用 onFrameAvailable 的，具体代码就不再列出，可以参考： <a href="https://www.cnblogs.com/ztguang/p/12645201.html" target="_blank" rel="noopener">https://www.cnblogs.com/ztguang/p/12645201.html</a> 。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Android 手机屏幕内容是怎么显示的，底层的显示原理到底是怎样的？强烈的好奇心驱使，开始 GUI 系统的学习，跟预想的一样，它很复杂、有难度。目前已大概学习了从 SurfaceFlinger 到物理屏幕的显示过程，后面继续由底而上，学习 SurfaceFlinger、Surface、Vsnyc、Choreographer 等，打通到 View 的 draw，相信就会有 “拨开云雾见天日” 的感觉了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;GUI 系统综述&lt;/li&gt;
&lt;li&gt;BufferQueue 与图像数据流&lt;/li&gt;
&lt;li&gt;Gralloc&lt;/li&gt;
&lt;li&gt;ANativeWindow&lt;/li&gt;
&lt;li&gt;FrameBufferNativeWindow&lt;/li&gt;
&lt;li&gt;FramebufferSurface&lt;/li&gt;
&lt;li&gt;最后&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="BufferQueue" scheme="http://yhaowa.gitee.io/yhaowa/tags/BufferQueue/"/>
    
      <category term="GUI" scheme="http://yhaowa.gitee.io/yhaowa/tags/GUI/"/>
    
      <category term="ANativeWindow" scheme="http://yhaowa.gitee.io/yhaowa/tags/ANativeWindow/"/>
    
      <category term="Gralloc" scheme="http://yhaowa.gitee.io/yhaowa/tags/Gralloc/"/>
    
  </entry>
  
  <entry>
    <title>细读《深入理解 Android 内核设计思想》（五）Binder 机制 [下]</title>
    <link href="http://yhaowa.gitee.io/yhaowa/c74cb1a3/"/>
    <id>http://yhaowa.gitee.io/yhaowa/c74cb1a3/</id>
    <published>2020-05-03T02:02:35.000Z</published>
    <updated>2020-12-06T09:18:58.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>深入 binder 驱动内部<ol><li>binder_ioctl</li><li>binder_get_thread</li><li>binder_ioctl_write_read</li><li>binder_thread_write</li><li>binder_transaction</li><li>binder_thread_read</li><li>小结</li></ol></li><li>binder Q&amp;A<ol><li>如何找到目标进程 Binder 实体</li><li>如何实现 Binder 线程的睡眠与唤醒</li></ol></li><li>最后</li></ol></blockquote><a id="more"></a><p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em></p><h2 id="深入-binder-驱动内部"><a href="#深入-binder-驱动内部" class="headerlink" title="深入 binder 驱动内部"></a>深入 binder 驱动内部</h2><p>前两篇文章都有提到 binder_ioctl 方法，在 <a href="https://yhaowa.gitee.io/a7541469/">Binder 机制 [上]</a>  中介绍了 binder_ioctl 支持的命令；<a href="https://yhaowa.gitee.io/a7541469/">Binder 机制 [中]</a>  中提到 IPCThreadState 会调用到 binder_ioctl 方法。</p><p>书中对 binder 驱动内部调用的讲解没有分为较清晰的步骤，一口气就是 20 页篇幅的源码详解，理解起来有些难度，容易迷失。在细读了三四遍后，终于感觉对整体有些掌握了，结合前面的学习与自己的理解，将一次 IPC 调用中 binder 驱动的工作分为以下 5 步：</p><p><strong>1.准备数据，根据命令分发给具体的方法去处理<br>2.找到目标进程的相关信息<br>3.将数据一次拷贝到目标进程所映射的物理内存块<br>4.记录待处理的任务，唤醒目标线程<br>5.调用线程进入休眠<br>6.目标进程直接拿到数据进行处理，处理完后唤醒调用线程<br>7.调用线程返回处理结果</strong></p><p>与上篇文章一样仍以 getService() 为例，按照上面的工作步骤为脉络，深入分析驱动层中的执行逻辑，彻底搞定 binder 驱动！</p><h3 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h3><p>在 IPCThreadState 中这样调用了 binder_ioctl() 方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</span><br></pre></td></tr></table></figure></p><p>binder_ioctl() 方法中会根据 BINDER_WRITE_READ、BINDER_SET_MAX_THREADS 等不同 cmd 转调到不同的方法去执行，这里我们只关注 BINDER_WRITE_READ，简化后代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> binder_ioctl(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//拿到调用进程在 binder_open() 中记录的 binder_proc</span></span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">struct</span> binder_thread *thread;</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="comment">//获取调用线程 binder_thread</span></span><br><span class="line">    thread = binder_get_thread(proc);</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        <span class="comment">//处理 binder 数据读写,binder IPC 通信的核心逻辑</span></span><br><span class="line">    ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS:&#123;...&#125; <span class="comment">//设置 binder 最大线程数</span></span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:&#123;...&#125; <span class="comment">//设置 service 大管家，即 ServiceManager</span></span><br><span class="line">    <span class="keyword">case</span> BINDER_THREAD_EXIT:&#123;...&#125; <span class="comment">//binder 线程退出命令，释放相关资源</span></span><br><span class="line">    <span class="keyword">case</span> BINDER_VERSION: &#123;...&#125; <span class="comment">//获取 binder 驱动版本号</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://yhaowa.gitee.io/a7541469/">Binder 机制 [上]</a> 中详细介绍过 binder_open() 方法，它主要做了两个工作：1.创建及初始化每个进程独有一份的、用来存放 binder 相关数据的 binder_proc 结构体，2.<strong>将 binder_proc 记录起来，方便后续使用</strong>。正是通过 file 来记录的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_open(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)&#123;</span><br><span class="line">    ...</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿到调用进程后，进一步通过 binder_get_thread() 方法拿到调用线程，然后就交给 binder_ioctl_write_read() 方法去执行具体的 binder 数据读写了，可见 binder_ioctl() 方法本身的逻辑非常简单，将数据 arg 透传了出去。下面分别来看 binder_get_thread()、binder_ioctl_write_read() 这两个方法。</p><h3 id="binder-get-thread"><a href="#binder-get-thread" class="headerlink" title="binder_get_thread"></a>binder_get_thread</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_thread *binder_get_thread(<span class="keyword">struct</span> binder_proc *proc)&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_thread *thread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> rb_node *parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> rb_node **p = &amp;proc-&gt;threads.rb_node; <span class="comment">//从 proc 中获取红黑树根节点</span></span><br><span class="line">    <span class="comment">//查找 pid 等于当前线程 id 的thread，该红黑树以 pid 大小为序存放</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        thread = rb_entry(parent, <span class="keyword">struct</span> binder_thread, rb_node);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid) <span class="comment">//current-&gt;pid 是当前调用线程的 id</span></span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="literal">NULL</span>) &#123;<span class="comment">//如果没有找到，则新创建一个</span></span><br><span class="line">        thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">        thread-&gt;proc = proc;</span><br><span class="line">        thread-&gt;pid = current-&gt;pid;</span><br><span class="line">        init_waitqueue_head(&amp;thread-&gt;wait);    <span class="comment">//初始化等待队列</span></span><br><span class="line">        INIT_LIST_HEAD(&amp;thread-&gt;todo);       <span class="comment">//初始化待处理队列</span></span><br><span class="line">        rb_link_node(&amp;thread-&gt;rb_node, parent, p);  <span class="comment">//加入到 proc 的 threads 红黑树中</span></span><br><span class="line">        rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">        thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">        thread-&gt;return_error = BR_OK;</span><br><span class="line">        thread-&gt;return_error2 = BR_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_thread 是用来描述线程的结构体，binder_get_thread() 方法中逻辑也很简单，首先从调用进程 proc 中查找当前线程是否已被记录，如果找到就直接返回，否则新建一个返回，并记录到 proc 中。也就是说所有调用 binder_ioctl() 的线程，都会被记录起来。</p><h3 id="binder-ioctl-write-read"><a href="#binder-ioctl-write-read" class="headerlink" title="binder_ioctl_write_read"></a>binder_ioctl_write_read</h3><p>此方法分为两部分来看，首先是整体：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_ioctl_write_read(<span class="keyword">struct</span> file *filp,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span><br><span class="line"><span class="keyword">struct</span> binder_thread *thread)&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg; <span class="comment">//用户传下来的数据赋值给 ubuf</span></span><br><span class="line">    <span class="keyword">struct</span> binder_write_read bwr;</span><br><span class="line">    <span class="comment">//把用户空间数据 ubuf 拷贝到 bwr</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">    ret = -EFAULT;</span><br><span class="line">    <span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    处理数据...</span><br><span class="line">    <span class="comment">//将读写后的数据写回给用户空间</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">    ret = -EFAULT;</span><br><span class="line">    <span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">out</span>:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>起初看到 copy_from_user() 方法时难以理解，因为它看起来是将我们要传输的数据拷贝到内核空间了，但目前还没有看到 server 端的任何线索，bwr 跟 server 端没有映射关系，那后续再将 bwr 传输给 server 端的时候又要拷贝，这样岂不是多次拷贝了？</p><p>其实这里的 copy_from_user() 方法并没有拷贝要传输的数据，而仅是拷贝了持有传输数据内存地址的 bwr。后续处理数据时会根据 bwr 信息真正的去拷贝要传输的数据。</p><p>处理完数据后，会将处理结果体现在 bwr 中，然后返回给用户空间处理。那是如何处理数据的呢？所谓的处理数据，就是对数据的读写而已：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;<span class="comment">//写数据</span></span><br><span class="line">ret = binder_thread_write(proc, </span><br><span class="line">         thread,</span><br><span class="line">         bwr.write_buffer, bwr.write_size,</span><br><span class="line">         &amp;bwr.write_consumed);</span><br><span class="line">    trace_binder_write_done(ret);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">//写失败</span></span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;<span class="comment">//读数据</span></span><br><span class="line">ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">        bwr.read_size,</span><br><span class="line">        &amp;bwr.read_consumed,</span><br><span class="line">        filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">    trace_binder_read_done(ret);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">        wake_up_interruptible(&amp;proc-&gt;wait);<span class="comment">//唤醒等待状态的线程</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">//读失败</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 binder 驱动内部依赖用户空间的 binder_write_read 决定是要读取还是写入数据：其内部变量 read_size&gt;0 则代表要读取数据，write_size&gt;0 代表要写入数据，若都大于 0 则先写入，后读取。</p><p>至此焦点应该集中在 binder_thread_write() 和 binder_thread_read()，下面分析这两个方法。</p><h3 id="binder-thread-write"><a href="#binder-thread-write" class="headerlink" title="binder_thread_write"></a>binder_thread_write</h3><p>在上面的 binder_ioctl_write_read() 方法中调用 binder_thread_write() 时传入了 bwr.write_buffer、bwr.write_size 等，先搞清楚这些参数是什么。</p><p>最开始是在用户空间 IPCThreadState 的 transact() 中通过 writeTransactionData() 方法创建数据并写入 mOut 的，writeTransactionData 方法代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</span><br><span class="line">    int32_t handle, uint32_t code, <span class="keyword">const</span> Parcel&amp; data, status_t* statusBuffer)&#123;</span><br><span class="line">    binder_transaction_data tr; <span class="comment">//到驱动内部后会取出此结构体进行处理</span></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>;</span><br><span class="line">    tr.target.handle = handle; <span class="comment">//目标 server 的 binder 的句柄</span></span><br><span class="line">    tr.code = code; <span class="comment">//请求码，getService() 服务对应的是 GET_SERVICE_TRANSACTION</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> status_t err = data.errorCheck(); <span class="comment">//验证数据合理性</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize(); <span class="comment">//传输数据大小</span></span><br><span class="line">        tr.data.ptr.buffer = data.ipcData(); <span class="comment">//传输数据</span></span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(binder_size_t);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">    mOut.writeInt32(cmd); <span class="comment">// transact 传入的 cmd 是 BC_TRANSACTION</span></span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr)); <span class="comment">//打包成 binder_transaction_data</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 IPCThreadState 的 talkWithDriver() 方法中对 write_buffer 赋值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bwr.write_buffer = (uintptr_t)mOut.data();</span><br></pre></td></tr></table></figure></p><p>搞清楚了数据的来源，再来看 binder_thread_write() 方法，binder_thread_write() 方法中处理了大量的 BC_XXX 命令，代码很长，这里我们只关注当前正在处理的 BC_TRANSACTION 命令，简化后代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_thread_write(<span class="keyword">struct</span> binder_proc *proc,</span><br><span class="line">        <span class="keyword">struct</span> binder_thread *thread,</span><br><span class="line">        binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">        binder_size_t *consumed)&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    <span class="keyword">void</span> __user *buffer = (<span class="keyword">void</span> __user *)(uintptr_t)binder_buffer; <span class="comment">//就是 bwr.write_buffer</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed; <span class="comment">//数据起始地址</span></span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size; <span class="comment">//数据结束地址</span></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; <span class="comment">//可能有多个命令及对应数据要处理，所以要循环</span></span><br><span class="line">        <span class="keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr)) <span class="comment">// 读取一个 cmd</span></span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t); <span class="comment">//跳过 cmd 所占的空间，指向要处理的数据</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">            <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">                 <span class="keyword">struct</span> binder_transaction_data tr; <span class="comment">//与 writeTransactionData 中准备的数据结构体对应</span></span><br><span class="line">                 <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr))) <span class="comment">//拷贝到内核空间 tr 中</span></span><br><span class="line">                    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                 ptr += <span class="keyword">sizeof</span>(tr); <span class="comment">//跳过数据所占空间，指向下一个 cmd</span></span><br><span class="line">                 binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); <span class="comment">//处理数据</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            处理其他 BC_XX 命令...</span><br><span class="line">        &#125;</span><br><span class="line">    *consumed = ptr - buffer; <span class="comment">//被写入处理消耗的数据量，对应于用户空间的 bwr.write_consumed</span></span><br></pre></td></tr></table></figure></p><p>binder_thread_write() 中从 bwr.write_buffer 中取出了 cmd 和 cmd 对应的数据，进一步交给 binder_transaction() 处理，需要注意的是，BC_TRANSACTION、BC_REPLY 这两个命令都是由 binder_transaction() 处理的。</p><p>简单梳理一下，由 binder_ioctl -&gt; binder_ioctl_write_read -&gt; binder_thread_write ，到目前为止还只是在准备数据，没有看到跟目标进程相关的任何处理，都属于 “准备数据，根据命令分发给具体的方法去处理” 第 1 个工作。而到此为止，第 1 个工作便结束，下一步的 binder_transaction() 方法终于要开始后面的工作了。</p><h3 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction"></a>binder_transaction</h3><p>binder_transaction() 方法中代码较长，先总结它干了哪些事：对应开头列出的工作，此方法中做了非常关键的 2-4 步：</p><ul><li>找到目标进程的相关信息</li><li>将数据一次拷贝到目标进程所映射的物理内存块</li><li>记录待处理的任务，唤醒目标线程</li></ul><p>以这些工作为线索，将代码分为对应的部分来看，首先是<strong>找到目标进程的相关信息</strong>，简化后代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> binder_transaction(<span class="keyword">struct</span> binder_proc *proc,</span><br><span class="line">       <span class="keyword">struct</span> binder_thread *thread,</span><br><span class="line">       <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *t; <span class="comment">//用于描述本次 server 端要进行的 transaction</span></span><br><span class="line">    <span class="keyword">struct</span> binder_work *tcomplete; <span class="comment">//用于描述当前调用线程未完成的 transaction</span></span><br><span class="line">    binder_size_t *offp, *off_end;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *target_proc; <span class="comment">//目标进程</span></span><br><span class="line">    <span class="keyword">struct</span> binder_thread *target_thread = <span class="literal">NULL</span>; <span class="comment">//目标线程</span></span><br><span class="line">    <span class="keyword">struct</span> binder_node *target_node = <span class="literal">NULL</span>; <span class="comment">//目标 binder 节点</span></span><br><span class="line">    <span class="keyword">struct</span> list_head *target_list; <span class="comment">//目标 TODO 队列</span></span><br><span class="line">    wait_queue_head_t *target_wait; <span class="comment">//目标等待队列</span></span><br><span class="line">    <span class="keyword">if</span>(reply)&#123; </span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        ...处理 BC_REPLY，暂不关注</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">//处理 BC_TRANSACTION</span></span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123; <span class="comment">//handle 不为 0</span></span><br><span class="line">            <span class="keyword">struct</span> binder_ref *ref;</span><br><span class="line">            <span class="comment">//根据 handle 找到目标 binder 实体节点的引用</span></span><br><span class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">            target_node = ref-&gt;node; <span class="comment">//拿到目标 binder 节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// handle 为 0 则代表目标 binder 是 service manager</span></span><br><span class="line">            <span class="comment">// 对于本次调用来说目标就是 service manager</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    target_proc = target_node-&gt;proc; <span class="comment">//拿到目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *tmp;</span><br><span class="line">    tmp = thread-&gt;transaction_stack;</span><br><span class="line">    <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</span><br><span class="line">                target_thread = tmp-&gt;from; <span class="comment">//拿到目标线程</span></span><br><span class="line">            tmp = tmp-&gt;from_parent;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    target_list = &amp;target_thread-&gt;todo; <span class="comment">//拿到目标 TODO 队列</span></span><br><span class="line">    target_wait = &amp;target_thread-&gt;wait; <span class="comment">//拿到目标等待队列</span></span><br></pre></td></tr></table></figure><p>binder_transaction、binder_work 等结构体在上一篇中有介绍，上面代码中也详细注释了它们的含义。比较关键的是 binder_get_ref() 方法，它是如何找到目标 binder 的呢？这里暂不延伸，下文再做分析。</p><p>继续看 binder_transaction() 方法的第 2 个工作，<strong>将数据一次拷贝到目标进程所映射的物理内存块</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL); <span class="comment">//创建用于描述本次 server 端要进行的 transaction</span></span><br><span class="line">tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL); <span class="comment">//创建用于描述当前调用线程未完成的 transaction</span></span><br><span class="line"><span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) <span class="comment">//将信息记录到 t 中：</span></span><br><span class="line">    t-&gt;from = thread; <span class="comment">//记录调用线程</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">t-&gt;to_proc = target_proc; <span class="comment">//记录目标进程</span></span><br><span class="line">t-&gt;to_thread = target_thread; <span class="comment">//记录目标线程</span></span><br><span class="line">t-&gt;code = tr-&gt;code; <span class="comment">//记录请求码，getService() 对应的是 GET_SERVICE_TRANSACTION</span></span><br><span class="line">t-&gt;flags = tr-&gt;flags;</span><br><span class="line"><span class="comment">//实际申请目标进程所映射的物理内存，准备接收要传输的数据</span></span><br><span class="line">t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">    tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line"><span class="comment">//申请到 t-&gt;buffer 后，从用户空间将数据拷贝进来，这里就是一次拷贝数据的地方！！</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(uintptr_t)</span><br><span class="line">    tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">    return_error = BR_FAILED_REPLY;</span><br><span class="line">    <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在拷贝之前要先申请物理内存呢？在 <a href="https://yhaowa.gitee.io/a7541469/">Binder 机制 [上]</a> 中介绍 binder_mmap() 时详细分析过，虽然 binder_mmap() 直接映射了 (1M-8K) 的虚拟内存，但却只申请了 1 页的物理页面，等到实际使用时再动态申请。也就是说，在 binder_ioctl() 实际传输数据的时候，再通过 binder_alloc_buf() 方法去申请物理内存。</p><p>至此已经将要传输的数据拷贝到目标进程，目标进程可以直接读取到了，接下来要做的就是将目标进程要处理的任务记录起来，然后唤醒目标进程，这样在目标进程被唤醒后，才能知道要处理什么任务。</p><p>最后来看 binder_transaction() 方法的第 3 个工作，<strong>记录待处理的任务，唤醒目标线程</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (reply) &#123; <span class="comment">//如果是处理 BC_REPLY，pop 出来栈顶记录的 transaction(实际上是删除链表头元素)</span></span><br><span class="line">binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">       <span class="comment">//如果不是 oneway，将 server 端要处理的 transaction 记录到当前调用线程</span></span><br><span class="line">t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">thread-&gt;transaction_stack = t;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...暂不关注 <span class="keyword">oneway</span> 的情况</span><br><span class="line">&#125;</span><br><span class="line">t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">   list_add_tail(&amp;t-&gt;work.entry, target_list); <span class="comment">//加入目标的处理队列中</span></span><br><span class="line">   tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; <span class="comment">//设置调用线程待处理的任务类型</span></span><br><span class="line">   list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); <span class="comment">//记录调用线程待处理的任务</span></span><br><span class="line">   <span class="keyword">if</span> (target_wait)</span><br><span class="line">       wake_up_interruptible(target_wait); <span class="comment">//唤醒目标线程</span></span><br></pre></td></tr></table></figure><p>再次梳理一下，至此已经完成了前四个工作：</p><p><strong>1.准备数据，根据命令分发给具体的方法去处理<br>2.找到目标进程的相关信息<br>3.将数据一次拷贝到目标进程所映射的物理内存块<br>4.记录待处理的任务，唤醒目标线程</strong></p><p>其中第 1 个工作涉及到的方法为 binder_ioctl() -&gt; binder_get_thread() -&gt; binder_ioctl_write_read()  -&gt; binder_thread_write() ，主要是一些数据的准备和方法转跳，没做什么实质的事情。而 binder_transaction()  方法中做了非常重要的 2-4 工作。</p><p>剩下的工作还有：</p><p><strong>5.调用线程进入休眠<br>6.目标进程直接拿到数据进行处理，处理完后唤醒调用线程<br>7.调用线程返回处理结果</strong></p><p>可以想到，5 和 6 其实没有时序上的限制，而是并行处理的。下面先来看第 5 个工作：调用线程是如何进入休眠等待服务端执行结果的。</p><h3 id="binder-thread-read"><a href="#binder-thread-read" class="headerlink" title="binder_thread_read"></a>binder_thread_read</h3><p>在唤醒目标线程后，调用线程就执行完 binder_thread_write() 写完了数据，返回到 binder_ioctl_write_read() 方法中，接着执行 binder_thread_read() 方法。</p><p>而调用线程的休眠就是在此方法中触发的，下面将 binder_thread_read() 分为两部分来看，首先是是否阻塞当前线程的判断逻辑：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_thread_read(<span class="keyword">struct</span> binder_proc *proc,</span><br><span class="line">            <span class="keyword">struct</span> binder_thread *thread,</span><br><span class="line">            binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">            binder_size_t *consumed, <span class="keyword">int</span> non_block)&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *buffer = (<span class="keyword">void</span> __user *)(uintptr_t)binder_buffer; <span class="comment">//bwr.read_buffer</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed; <span class="comment">//数据起始地址</span></span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size; <span class="comment">//数据结束地址</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (uint32_t __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否要准备睡眠当前线程</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            list_empty(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123; <span class="comment">//non_block 为 false</span></span><br><span class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        ret = wait_event_freezable_exclusive(proc-&gt;wait, </span><br><span class="line">                        binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123; <span class="comment">//non_block 为 false</span></span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, </span><br><span class="line">                        binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>consumed 即用户空间的 bwr.read_consumed，这里是 0 ，所以将一个 BR_NOOP 加到了 ptr 中。</p><p>怎么理解 wait_for_proc_work 条件呢？在 binder_transaction() 方法中将 server 端要处理的 transaction 记录到了当前调用线程 thread-&gt;transaction_stack 中；将当前调用线程待处理的任务记录到了 thread-&gt;todo 中。所以这里的 thread-&gt;transaction_stack 和 thread-&gt;todo 都不为空，wait_for_proc_work 为 false，代表不准备阻塞当前线程。</p><p>但 wait_for_proc_work 并不是决定是否睡眠的最终条件，接着往下看，其中 non_block 恒为 false，那是否要睡眠当前线程就取决于 binder_has_thread_work() 的返回值，binder_has_thread_work() 方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_has_thread_work(<span class="keyword">struct</span> binder_thread *thread)&#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;thread-&gt;todo) || thread-&gt;return_error != BR_OK ||</span><br><span class="line">        (thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread-&gt;todo 不为空，所以 binder_has_thread_work() 返回 true，当前调用线程不进入休眠，继续往下执行。你可能会有疑问，不是说调用线程的休眠就是在 binder_thread_read() 方法中触发的吗？确实是，只不过不是本次，先接着分析 binder_thread_read() 继续往下要执行的逻辑：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_work *w;</span><br><span class="line">w = list_first_entry(&amp;thread-&gt;todo, <span class="keyword">struct</span> binder_work,entry);</span><br><span class="line"><span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">        cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(uint32_t);</span><br><span class="line">        binder_stat_br(proc, thread, cmd);</span><br><span class="line">        list_del(&amp;w-&gt;entry); <span class="comment">//删除 binder_work 在 thread-&gt;todo 中的引用</span></span><br><span class="line">        kfree(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WORK_NODE&#123;...&#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER&#123;...&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在上面 binder_transaction() 方法最后，将 BINDER_WORK_TRANSACTION_COMPLETE 类型的 binder_work 加入到 thread-&gt;todo 中。而这里就是对这个 binder_work 进行处理，将一个 BR_TRANSACTION_COMPLETE 命令加到了 ptr 中。</p><p>梳理一下目前的逻辑，至此已经顺序执行完 binder_thread_write()、binder_thread_read() 方法，并且在 binder_thread_read() 中往用户空间传输了两个命令：BR_NOOP 和 BR_TRANSACTION_COMPLETE。</p><p>本次 binder_ioctl() 调用就执行完了，然后会回到 IPCThreadState 中，上一篇文章中详细分析了 IPCThreadState 中的代码，这里就不再展开，简单概括一下后续执行的逻辑：</p><p>mIn 中有 BR_NOOP 和 BR_TRANSACTION_COMPLETE 两个命令，首先处理 BR_NOOP 命令，此命令什么也没做，由于 talkWithDriver() 处于 while 循环中，会再一次进入 talkWithDriver()，但因为此时 mIn 中还有数据没读完，不会调用 binder_ioctl()。</p><p>然后处理 BR_TRANSACTION_COMPLETE 命令，如果是 oneway 就直接结束本次 IPC 调用，否则再一次进入 talkWithDriver()，第二次进入 talkWithDriver 时，bwr.write_size = 0，bwr.read_size &gt; 0，所以会第二次调用 binder_ioctl() 方法。第二次执行 binder_ioctl() 时，bwr.write_size = 0，bwr.read_size &gt; 0，所以不会再执行 binder_thread_write() 方法，而只执行 binder_thread_read() 方法。</p><p>第二次执行 binder_thread_read() 时，thread-&gt;todo 已经被处理为空，但是 thread-&gt;transaction_stack 还不为空，wait_for_proc_work 仍然为 false，但最终决定是否要休眠的条件成立了： binder_has_thread_work(thread) 返回 false，由此当前调用线程通过 wait_event_freezable() 进入休眠。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此还剩下两个工作：</p><p><strong>6.目标进程直接拿到数据进行处理，处理完后唤醒调用线程<br>7.调用线程返回处理结果</strong></p><p>但是已经不用再看代码了，因为上述方法已经覆盖了剩下的工作。对于 getService() 来说，目标进程就是 Service Manager，相关的代码在 <a href="https://yhaowa.gitee.io/a7541469/">Binder 机制 [上]</a> 也已经做过详细的分析。用图来概括整体的工作。调用进程逻辑：</p><p><img src="../img/binderDriver.png" alt></p><div style="display: none"><br>BpBinder-&gt;IPCThreadState:transact()<br>IPCThreadState-&gt;IPCThreadState:writeTransactionData()<br>IPCThreadState-&gt;IPCThreadState:waitForResponse()<br>IPCThreadState-&gt;BinderDriver:talkWithDriver()<br>BinderDriver-&gt;BinderDriver:binder_ioctl()<br>BinderDriver-&gt;BinderDriver:binder_get_thread()<br>BinderDriver-&gt;BinderDriver:binder_ioctl_write_read()<br>BinderDriver-&gt;BinderDriver:binder_thread_write()<br>BinderDriver-&gt;BinderDriver:binder_transaction()<br>BinderDriver–&gt;BinderDriver:唤醒目标进程<br>BinderDriver-&gt;BinderDriver:binder_thread_read()<br>BinderDriver–&gt;IPCThreadState:<br>IPCThreadState-&gt;IPCThreadState:处理 BR_NOOP<br>IPCThreadState-&gt;IPCThreadState:处理 BR_TRANSACTION_COMPLETE<br>IPCThreadState-&gt;BinderDriver:talkWithDriver()<br>BinderDriver-&gt;BinderDriver:binder_ioctl()<br>BinderDriver-&gt;BinderDriver:binder_get_thread()<br>BinderDriver-&gt;BinderDriver:binder_ioctl_write_read()<br>BinderDriver-&gt;BinderDriver:binder_thread_read()<br>BinderDriver–&gt;BinderDriver:进入休眠<br>BinderDriver–&gt;BinderDriver:目标进程处理完<br>BinderDriver–&gt;BinderDriver:被唤醒<br>BinderDriver–&gt;IPCThreadState:<br>IPCThreadState-&gt;IPCThreadState:处理 BR_REPLY<br></div><p>Service Manager 端逻辑：</p><p><img src="../img/serviceManagerBinder.png" alt></p><div style="display: none"><br>servicemanager-&gt;servicemanager:启动<br>servicemanager-&gt;servicemanager:binder_open()<br>servicemanager-&gt;servicemanager:binder_become_context_manager()<br>servicemanager-&gt;BinderDriver:binder_loop()<br>BinderDriver-&gt;BinderDriver:binder_ioctl()<br>BinderDriver-&gt;BinderDriver:binder_get_thread()<br>BinderDriver-&gt;BinderDriver:binder_ioctl_write_read()<br>BinderDriver-&gt;BinderDriver:binder_thread_read()<br>BinderDriver–&gt;BinderDriver:进入休眠<br>BinderDriver–&gt;BinderDriver:其他进程 getService()<br>BinderDriver–&gt;BinderDriver:被唤醒<br>BinderDriver–&gt;servicemanager:<br>servicemanager-&gt;servicemanager:binder_parse()<br>servicemanager-&gt;servicemanager:处理 BR_TRANSACTION<br>servicemanager-&gt;servicemanager:do_find_service()<br>servicemanager-&gt;BinderDriver:binder_write(BC_REPLY)<br>BinderDriver-&gt;BinderDriver:binder_ioctl()<br>BinderDriver-&gt;BinderDriver:binder_get_thread()<br>BinderDriver-&gt;BinderDriver:binder_ioctl_write_read()<br>BinderDriver-&gt;BinderDriver:binder_thread_write()<br>BinderDriver-&gt;BinderDriver:binder_transaction()<br>BinderDriver–&gt;BinderDriver:唤醒调用进程<br>BinderDriver-&gt;BinderDriver:binder_thread_read()<br>BinderDriver–&gt;servicemanager:<br>servicemanager-&gt;servicemanager:处理 BR_TRANSACTION_COMPLETE<br>servicemanager-&gt;BinderDriver:binder_loop()<br>servicemanager-&gt;BinderDriver:binder_loop() 再次进入休眠<br></div><p>本节完整的分析了一次 IPC 调用中 binder 驱动内部具体的执行逻辑，此部分也是 binder 机制中最难的，而将最难的部分掌握后，可以极大的提高信心。</p><p>想要完全掌握本节内容，前提是必须对前两篇 binder 文章已经熟悉，因为 binder 驱动和用户空间的 IPCThreadState 以及 servicemanager 关联是十分紧密的，如果没有掌握，是无法真正理清本节内容的。</p><h2 id="binder-Q-amp-A"><a href="#binder-Q-amp-A" class="headerlink" title="binder Q&amp;A"></a>binder Q&amp;A</h2><p>在上面分析 binder 驱动代码过程中，主要是根据文章开头的七个工作为线索，为了不偏离主线，在遇到比较重要的知识点时都没做延伸，这里以 Q&amp;A 的方式补充分析。</p><h3 id="如何找到目标进程-Binder-实体"><a href="#如何找到目标进程-Binder-实体" class="headerlink" title="如何找到目标进程 Binder 实体"></a>如何找到目标进程 Binder 实体</h3><p>servicemanager 的 binder 实体固定为 binder_context_mgr_node，直接返回即可。如何获取其他 binder 实体呢？在上面的 binder_transaction() 方法中是这样获取目标 binder 的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据 handle 找到目标 binder 实体节点的引用</span></span><br><span class="line">ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br></pre></td></tr></table></figure><p>binder_get_ref() 方法如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> binder_ref *binder_get_ref(<span class="keyword">struct</span> binder_proc *proc,</span><br><span class="line">                uint32_t desc)&#123;</span><br><span class="line">    <span class="keyword">struct</span> rb_node *n = proc-&gt;refs_by_desc.rb_node; <span class="comment">//取红黑树根结点</span></span><br><span class="line">    <span class="keyword">struct</span> binder_ref *ref;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123; <span class="comment">//遍历查询指定 desc(handle) 值的 binder 实体</span></span><br><span class="line">        ref = rb_entry(n, <span class="keyword">struct</span> binder_ref, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (desc &lt; ref-&gt;desc)</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; ref-&gt;desc)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见是在调用进程的 binder_proc 结构体中获取到的，那目标 binder 实体又是什么时候存储到调用进程中的呢？</p><p>对于实名的 Server，当它利用 addService() 把自身加到 ServiceManager 中时，会”路过” binder 驱动，binder 驱动就会把这一 binder 实体记录到 ServiceManager 的 binder_proc-&gt;refs_by_desc 和 binder_proc-&gt;refs_by_node 中。</p><p>当一个 Binder Client 通过 getService() 向 ServiceManager 发起查询时，ServiceManager 就可以准确的告诉 Client 目标 Binder 实体，将其也记录到 Client 的 binder_proc-&gt;refs_by_desc 和 binder_proc-&gt;refs_by_node 中。</p><p>上面说的是通过 addService() 将自身注册到 Service Manager 中的 Server，任何 Binder Client 都能通过 Service Manager 获取到，这种叫做 “实名” Server。 而 Android 中还存在另一种 Binder Server，并不在 Service Manager 中注册，比如我们自定义的 Service，这种可以叫做 “匿名” Server。</p><p>如何找到一个匿名 Server 的 binder 实体呢？匿名 Server 一般要通过其他实名 Server 为中介来传递，比如 IWindowSession 是靠 WindowManagerService 来传递的，当 Binder Client 调用 openSession 真正生成一个 Session 对象，这个对象作为 reply 第一次 “路过” binder 驱动时，就会被记录到 Client 的 binder_proc-&gt;refs_by_desc 和 binder_proc-&gt;refs_by_node 中。</p><h3 id="如何实现-Binder-线程的睡眠与唤醒"><a href="#如何实现-Binder-线程的睡眠与唤醒" class="headerlink" title="如何实现 Binder 线程的睡眠与唤醒"></a>如何实现 Binder 线程的睡眠与唤醒</h3><p>答案在上文中已经有很详细的分析了，这里再概括一下：</p><p>唤醒：在 binder_transaction() 方法中写完数据后，通过 wake_up_interruptible(target_wait) 唤醒目标线程<br>睡眠：在 binder_thread_read() 中，通过 wait_event_freezable_exclusive() 或 wait_event_freezable() 调用进入睡眠</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后再对 binder 的整体架构做一个简要的概述。对于一个比较典型的、两个应用之间的 IPC 通信流程而言：</p><p><img src="../img/binder_design.jpg" alt></p><p>Client 通过 ServiceManager 或 AMS 获取到的远程 binder 实体，一般会用 <strong>Proxy</strong> 做一层封装，比如 ServiceManagerProxy、 AIDL 生成的 Proxy 类。而被封装的远程 binder 实体是一个 <strong>BinderProxy</strong>。</p><p><strong>BpBinder</strong> 和 BinderProxy 其实是一个东西：远程 binder 实体，只不过一个 Native 层、一个 Java 层，BpBinder 内部持有了一个 binder 句柄值 handle。</p><p><strong>ProcessState</strong> 是进程单例，负责打开 Binder 驱动设备及 mmap；<strong>IPCThreadState</strong> 为线程单例，负责与 binder 驱动进行具体的命令通信。</p><p>由 Proxy 发起 transact() 调用，会将数据打包到 Parcel 中，层层向下调用到 BpBinder ，在 BpBinder 中调用 IPCThreadState 的 transact() 方法并传入 handle 句柄值，IPCThreadState 再去执行具体的 binder 命令。</p><p>由 binder 驱动到 Server 的大概流程就是：Server 通过 IPCThreadState 接收到 Client 的请求后，层层向上，最后回调到 <strong>Stub</strong> 的 onTransact() 方法。</p><p>当然这不代表所有的 IPC 流程，比如 Service Manager 作为一个 Server 时，便没有上层的封装，也没有借助 IPCThreadState，而是初始化后通过 binder_loop() 方法直接与 binder 驱动通信的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;深入 binder 驱动内部&lt;ol&gt;
&lt;li&gt;binder_ioctl&lt;/li&gt;
&lt;li&gt;binder_get_thread&lt;/li&gt;
&lt;li&gt;binder_ioctl_write_read&lt;/li&gt;
&lt;li&gt;binder_thread_write&lt;/li&gt;
&lt;li&gt;binder_transaction&lt;/li&gt;
&lt;li&gt;binder_thread_read&lt;/li&gt;
&lt;li&gt;小结&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;binder Q&amp;amp;A&lt;ol&gt;
&lt;li&gt;如何找到目标进程 Binder 实体&lt;/li&gt;
&lt;li&gt;如何实现 Binder 线程的睡眠与唤醒&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="读书笔记" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="binder" scheme="http://yhaowa.gitee.io/yhaowa/tags/binder/"/>
    
  </entry>
  
  <entry>
    <title>细读《深入理解 Android 内核设计思想》（四）Binder 机制 [中]</title>
    <link href="http://yhaowa.gitee.io/yhaowa/a8eae25c/"/>
    <id>http://yhaowa.gitee.io/yhaowa/a8eae25c/</id>
    <published>2020-04-23T15:24:46.000Z</published>
    <updated>2020-12-06T09:18:58.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>智能指针</li><li>binder 驱动中的结构体</li><li>ProcessState</li><li>IPCThreadState</li><li>BpBinder</li><li>BinderProxy</li><li>ServiceManager getService 流程</li></ol></blockquote><a id="more"></a><p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>在 binder 相关源码可以看到 sp、wp 类型的引用：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; result = new BpBinder(handle);</span><br><span class="line"></span><br><span class="line">wp&lt;IBinder&gt; result = new BpBinder(handle);</span><br></pre></td></tr></table></figure></p><p>sp 即 strong pointer 强指针引用；wp 是 weak pointer 弱指针引用。在 Java 中我们不用关心对象的销毁及内存释放，GC 机制会自动辨别回收无用对象，而<strong>智能指针</strong>就是 native 层一个小型的 GC 实现。</p><p>智能指针以引用计数的方式来标识无用对象，使用智能指针的对象需继承自 RefBase，RefBase 中维护了此对象被强引用数量和弱引用数量。</p><p>强引用 sp 重载了 “=” 运算符，在引用其他对象时将强引用计数 +1，在 sp 析构函数中将强引用计数 -1，当强引用计数减至 0 时销毁引用的对象。这样就实现了对象的自动释放，但若只靠强引用计数方式，会存在循环引用的问题，导致对象永远无法被释放，弱引用就是专门用来解决循环引用问题的。</p><p>若在 A 中强引用了 B，那 B 需要引用 A 时就使用弱引用，当判断对象是否无用时仅考虑强引用计数是否为 0，不关心弱引用计数的数量。当 B 要访问 A 时，若发现 A 已经被销毁，那就表示 A 已经不存在了，需要进行重新创建等其他操作。</p><p>RefBase 提供了 extendObjectLifetime() 方法，可以用来设置引用计数器的规则，不同规则对删除目标对象的时机判断也是不一样的，包括以下三种规则：</p><p><strong>OBJECT_LIFETIME_STRONG</strong>：只有在这个对象内存空间中的强计数器值为 0 的时候才会销毁对象）</p><p><strong>OBJECT_LIFETIME_WEAK</strong>：只有在这个对象内存空间中的强计数器和弱计数器的值都为 0 的时候才会销毁对象</p><p><strong>OBJECT_LIFETIME_MASK</strong>：不管这两个计数器是不是都为 0，都不销毁对象，即与一般指针无异，还是要自己手动去释放对象</p><h2 id="binder-驱动相关的结构体"><a href="#binder-驱动相关的结构体" class="headerlink" title="binder 驱动相关的结构体"></a>binder 驱动相关的结构体</h2><table><thead><tr><th>结构体</th><th>说明</th></tr></thead><tbody><tr><td>binder_proc</td><td>描述使用 binder 的进程，当调用 binder_open 函数时会创建</td></tr><tr><td>binder_thread</td><td>描述使用 binder 的线程，当调用 binder_ioctl 函数时会创建</td></tr><tr><td>binder_node</td><td>描述 binder 实体节点，对应于一个 serve，即用户态的 BpBinder 对象</td></tr><tr><td>binder_ref</td><td>描述对 binder 实体节点的引用，关联到一个 binder_node</td></tr><tr><td>binder_buffer</td><td>描述 binder 通信过程中存储数据的Buffer</td></tr><tr><td>binder_work</td><td>描述一个 binder 任务</td></tr><tr><td>binder_transaction</td><td>描述一次 binder 任务相关的数据信息</td></tr><tr><td>binder_ref_death</td><td>描述 binder_node 即 binder server 的死亡信息</td></tr></tbody></table><p>其中主要结构体引用关系如下：</p><p><img src="../img/binder_proc.png" alt></p><p>以上结构体仅存在于 binder 驱动内部，还有一类结构体是与用户态共用的：</p><table><thead><tr><th>结构体</th><th>说明</th></tr></thead><tbody><tr><td>flat_binder_object</td><td>描述在 binder IPC 过程传递的对象</td></tr><tr><td>binder_write_read</td><td>描述存储读写操作的数据</td></tr><tr><td>binder_version</td><td>描述 binder 的版本号</td></tr><tr><td>transaction_flags</td><td>描述事务的 flag，例如是否是异步请求，是否支持 fd</td></tr><tr><td>binder_transaction_data</td><td>描述一次事务的相关数据</td></tr></tbody></table><p><strong>参考： <a href="http://www.codeceo.com/article/android-binder-part-one.html" target="_blank" rel="noopener">http://www.codeceo.com/article/android-binder-part-one.html</a></strong></p><h2 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h2><p>ProcessState 专门管理每个应用进程的 Binder 操作，同一个进程中只有一个 ProcessState 实例存在，且只在 ProcessState 对象创建时才打开 Binder 设备以及内存映射。相关代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line">sp&lt;ProcessState&gt; ProcessState::<span class="keyword">self</span>()&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123; <span class="comment">//如果创建过 ProcessState 就直接返回</span></span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = new ProcessState;</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>外部统一通过 ProcessState::self() 方法获取 ProcessState，以此保证 ProcessState 的进程单例，ProcessState 的构造函数如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line"></span><br><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver()) <span class="comment">//打开 binder 设备</span></span><br><span class="line">    , mVMStart(MAP_FAILED) <span class="comment">//初始化为 MAP_FAILED，映射成功后会变更</span></span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) <span class="comment">//binder 线程最大数量</span></span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123; <span class="comment">//已经成功打开 binder 驱动设备</span></span><br><span class="line">           <span class="comment">// 将应用进程一块虚拟内存空间与 binder 驱动映射，在此内存块上进行数据通信</span></span><br><span class="line">           mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123; <span class="comment">//映射失败处理</span></span><br><span class="line">               ALOGE(<span class="string">"Using /dev/binder failed: unable to mmap transaction memory.\n"</span>);</span><br><span class="line">               close(mDriverFD);</span><br><span class="line">               mDriverFD = <span class="number">-1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ProcessState 的构造函数初始化了一些重要的变量，包括调用 open_driver() 打开 binder 设备，初始化 binder 线程最大数量，将 BINDER_VM_SIZE (接近 1M ) 的内存与 binder 驱动 mmap.</p><p>除了 ProcessState 的初始化，ProcessState 中还有一些比较重要的方法，比如 getStrongProxyForHandle()、getWeakProxyForHandle() 等，可以通过 handle 值获取对应 IBinder 对象，getWeakProxyForHandle() 方法如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wp&lt;IBinder&gt; ProcessState::getWeakProxyForHandle(int32_t handle)&#123;</span><br><span class="line">    wp&lt;IBinder&gt; result;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="comment">//查找 IBinder 是否已经创建过 </span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = new BpBinder(handle); <span class="comment">//没创建过就新建 BpBinder</span></span><br><span class="line">            result = b;</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = b;</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>lookupHandleLocked() 方法用于查找本进程中是否已经创建过要获取的 IBinder，如果没有获取到，就创建一个，lookupHandleLocked() 内部通过一个 Vector 来存放创建过的 IBinder：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;handle_entry&gt; mHandleToObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> handle_entry&#123;</span><br><span class="line">    IBinder* binder;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码所示，每个 IBinder 对象通过一个 handle_entry 结构体存放，也就是说，ProcessState 中有一个全局列表来记录所有的 IBinder 对象。</p><h2 id="IPCThreadState"><a href="#IPCThreadState" class="headerlink" title="IPCThreadState"></a>IPCThreadState</h2><p>ProcessState 对应于一个进程，是进程内单例，而 IPCThreadState 对应于一个线程，是线程单例(Thread Local)。</p><p>ProcessState 中打开了 binder 驱动、进行 mmap 映射，虽然调用了 ioctl() 函数，但主要是一些初始化配置。而具体的 BR_TRANSACTION 等命令都是由 IPCThreadState 负责执行的，当上层传来一个命令，会调用它的 transact 函数，该函数精简后如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)&#123;</span><br><span class="line">    <span class="comment">//检查数据是否有效</span></span><br><span class="line">    status_t err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//将数据打包塞到 mOut 里</span></span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123; <span class="comment">//不是 one way 调用，需要等待回复</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//one way 调用，不用等待回复</span></span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>IPCThreadState 中有 mIn、mOut 两个 Parcel 数据，mIn 用来存放从别处读取而来的数据，mOut 存放要写入到别处的数据，在 writeTransactionData() 方法中将数据存放到 mOut，准备写入到 binder 驱动。</p><p>waitForResponse() 方法去实际执行写入到 binder 驱动，简化后的 waitForResponse() 方法如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//进一步调用 talkWithDriver 去执行写入数据到 binder 驱动</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        err = mIn.errorCheck(); <span class="comment">//检查数据有效性</span></span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//检查数据有效性</span></span><br><span class="line">        cmd = (uint32_t)mIn.readInt32(); <span class="comment">//拿到 binder 驱动发过来的命令</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            <span class="comment">//处理命令</span></span><br><span class="line">            <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:&#123;...&#125;</span><br><span class="line">            <span class="keyword">case</span> BR_DEAD_REPLY:&#123;...&#125;</span><br><span class="line">            <span class="keyword">case</span> BR_FAILED_REPLY:&#123;...&#125;</span><br><span class="line">            <span class="keyword">case</span> BR_ACQUIRE_RESULT:&#123;...&#125;</span><br><span class="line">            <span class="keyword">case</span> BR_REPLY:&#123;...&#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">//其他命令在 executeCommand 方法中处理</span></span><br><span class="line">                err = executeCommand(cmd);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 waitForResponse() 中并没有直接执行写入数据到 binder，而是进一步调用 talkWithDriver 去处理，随后 waitForResponse() 方法处理了由 binder 驱动发送过来的命令，比如 BR_TRANSACTION_COMPLETE ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">       <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>在 transact() 方法中判断如果是 one way 调用，reply 及 acquireResult 都传入 NULL，所以上面条件成立，直接退出循环，不用再等待 binder 驱动的回复。在上一篇文章<a href="https://yhaowa.gitee.io/a7541469/">细读《深入理解 Android 内核设计思想》（三）Binder 机制 [上]</a> 中 IPC 调用中提到过 BR_TRANSACTION_COMPLETE 命令，再来回顾下：</p><div id="sequence-0"></div><p>到目前为止，由 transact() 到 waitForResponse()，已经将要发送的数据准备好，并对后续 binder 驱动的回复也做了处理，但还没看到真正写入数据给 binder 驱动的代码，但已经知道就在 talkWithDriver() 方法中，此方法中主要做了三个工作：1.准备 binder_write_read 数据，2.写入 binder 驱动 3.处理驱动回复。以此将 talkWithDriver() 代码简化分为对应的三部分来看，首先是准备 binder_write_read 数据：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)&#123;</span><br><span class="line">    binder_write_read bwr; <span class="comment">//binder 驱动接受的数据格式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    <span class="keyword">const</span> size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    bwr.write_size = outAvail; <span class="comment">//要写入的数据量</span></span><br><span class="line">    bwr.write_buffer = (uintptr_t)mOut.data(); <span class="comment">//要写入的数据</span></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity(); <span class="comment">//要读取的数据量</span></span><br><span class="line">        bwr.read_buffer = (uintptr_t)mIn.data(); <span class="comment">//存放读取数据的内存空间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不需要读也不需要写，那就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br></pre></td></tr></table></figure></p><p>在 IPCThreadState.h 中声明了 talkWithDriver() 方法的参数 doReceive 默认为 true，waitForResponse() 中没有传入参数，所以这里的 doReceive 为 true。</p><p>在上文 binder 驱动相关的结构体 中提到过 binder_write_read，它是 binder 驱动与用户态共用的、存储读写操作的数据，在 binder 驱动内部依赖 binder_write_read 决定是要读取还是写入数据：其内部变量 read_size&gt;0 则代表要读取数据，write_size&gt;0 代表要写入数据，若都大于 0 则先写入，后读取。</p><p>准备好 binder_write_read 后，再来看是怎么写入 binder 驱动的，其实很简单，真正执行写入的操作就一行代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</span><br></pre></td></tr></table></figure></p><p>对应的会调用到 binder 驱动的 binder_ioctl() 函数，这里不延伸此函数，接着看 talkWithDriver() 方法的第三个工作，处理驱动的回复：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123; <span class="comment">//成功写入了数据</span></span><br><span class="line">         <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">             mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123; <span class="comment">//成功读取到了数据</span></span><br><span class="line">         mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">         mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>bwr.write_consumed &gt; 0 代表 binder 驱动消耗了 mOut 中的数据，所以要把这部分已经处理过的数据移除调；bwr.read_consumed &gt; 0 代表 binder 驱动成功的返回了数据给我们，并写入了上面通过 bwr.read_buffer 指定的内存地址，即 mIn 中，所以要对 mIn 对相关的修正。</p><p>到这里 talkWithDriver 执行完毕，读取到的数据放到了 mIn 中，也正好对应于上面 waitForResponse() 方法中从 mIn 中取数据的逻辑。</p><h2 id="BpBinder"><a href="#BpBinder" class="headerlink" title="BpBinder"></a>BpBinder</h2><p>上文介绍 ProcessState 中的 getWeakProxyForHandle() 方法时，构造了一个 BpBinder 对象返回：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new BpBinder(handle)</span><br></pre></td></tr></table></figure></p><p>IPCThreadState 作为主要与 binder 驱动交互的对象，它的 transact 方法第一个参数就是 handle 值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br></pre></td></tr></table></figure></p><p>注意这两个线索：一是将 handle 交给 BpBinder 持有，二是在调用 IPCThreadState transact 方法时需要传入 handle，这意味着什么呢？<strong>一个 BpBinder 对象就是关联了一个远程 handle 的操作封装，其内部是通过 IPCThreadState 来实现的</strong> 。但这个仅是猜想，下面通过 BpBinder 源码来验证是否属实，首先是构造函数：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BpBinder::BpBinder(int32_t handle)</span><br><span class="line">   : mHandle(handle)</span><br><span class="line">   , mAlive(<span class="number">1</span>)</span><br><span class="line">   , mObitsSent(<span class="number">0</span>)</span><br><span class="line">   , mObituaries(<span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">   ALOGV(<span class="string">"Creating BpBinder %p handle %d\n"</span>, <span class="keyword">this</span>, mHandle);</span><br><span class="line"></span><br><span class="line">   extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line">   IPCThreadState::<span class="keyword">self</span>()-&gt;incWeakHandle(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上文<strong>智能指针</strong>介绍过 OBJECT_LIFETIME_WEAK，其代表 BpBinder 对象的强计数器和弱计数器的值都为 0 时才会被销毁。另外可以看到通过内部变量 mHandle 持有 handle 值，在 BpBinder 的 transact 方法中使用了 mHandle：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, uint32_t flags)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        status_t status = IPCThreadState::<span class="keyword">self</span>()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其内部确实是调用了 IPCThreadState 的 transact 方法，这便验证了 “一个 BpBinder 对象就是关联了一个远程 handle 的操作封装，其内部是通过 IPCThreadState 来实现的” 的描述是正确的。</p><h2 id="BinderProxy"><a href="#BinderProxy" class="headerlink" title="BinderProxy"></a>BinderProxy</h2><p>先给出结论：BinderProxy 就是 BpBinder，”BpBinder” 中的 “p” 即 Proxy，只不过 BpBinder 是 Native 层的，BinderProxy 是 Java 层的。BinderProxy 和 BpBinder 分别继承自 Java 和 Native 层的 IBinder 接口，即 IBinder.h 和 IBinder.java，它们可以看作同一个接口，都定义了 transact 等方法。</p><p>下面根据源码来验证这个结论，ServiceManager.java 中获取 Service Manager 的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 asInterface 方法接收的参数就是一个 IBinder 类型对象，可想而知，BinderInternal 的 getContextObject() 方法返回的是一个 BinderProxy 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the global "context object" of the system.  This is usually</span></span><br><span class="line"><span class="comment"> * an implementation of IServiceManager, which you can use to find</span></span><br><span class="line"><span class="comment"> * other services.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> IBinder <span class="title">getContextObject</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>这里保留了注释，因为书中专门对为什么将 Service Manager 命名为 Context Object 做了解释：每个进程都需要 IPC 操作，IPC 是作为进程的基础配置存在的。而上面代码的注释更直接的描述了此方法，有助于我们理解。</p><p>接着看这个方法，对应的 native 实现在 android_util_Binder.cpp 中：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::<span class="keyword">self</span>()-&gt;getContextObject(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ProcessState 的 getContextObject() 方法如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上文介绍过 ProcessState 的 getWeakProxyForHandle() 方法，其内部构造了一个 BpBinder 对象返回，getStrongProxyForHandle() 方法跟 getWeakProxyForHandle() 一样，也是返回了一个 BpBinder 对象，只不过是强引用类型。</p><p>javaObjectForIBinder() 方法不再展开，它根据 BpBinder 对象构造了一个 BinderProxy 对象，并且记录了 BpBinder 的内存地址，以便后续从 Java-&gt;Native 时，可以根据 BinderProxy 获取到对应的 BpBinder 对象。与 javaObjectForIBinder() 对应， 由 BinderProxy -&gt; BpBinder 调用的是  android_util_Binder.cpp 的 ibinderForJavaObject() 方法。</p><h2 id="ServiceManager-getService-流程"><a href="#ServiceManager-getService-流程" class="headerlink" title="ServiceManager getService 流程"></a>ServiceManager getService 流程</h2><p>在对 binder 驱动、ProcessState、IPCThreadState、BpBinder、BinderProxy 一一单点突破之后，通过一个示例将它们串联起来。对于 ServiceManager getService 流程，首先需要获取 handle 值为 0 的 IBinder 对象：</p><p><img src="../img/BinderProxy.png" alt></p><p>然后调用 transact() 函数进行 IPC 通信：</p><p><img src="../img/transact.jpg" alt></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Service Manager 自身也是一个 Server，相当于 DNS 服务器本身也要提供 IP 地址才能被访问一样，只不过 Service Manager 的 IP 地址是预先就设定好的，句柄值固定为 0。所以任何 Binder Client 都可以直接通过 0 这个 binder 句柄值创建一个 BpBinder，再通过 Binder 驱动去使用 Service Manager 的服务。具体来说，就是调用 BinderInternal 的 getContextObject() 方法来获取 Service Manager 的 BpBinder。</p><p>Android 系统同时支持 Java 与 Native 层的 Binder 机制，所以很多对象都有 “双重身份”，比如 IBinder 在 Java 层用 BinderProxy 表示，在 Native 层用 BpBinder 表示。</p><p>大多数程序都有 IPC 的需要，而且进程间通信本身又是非常繁琐的，所以 Android 系统特别为 Binder 机制封装了两个类：ProcessState 和 IPCThreadState，分别对应于进程和线程。ProcessState 负责打开 Binder 驱动设备及 mmap；IPCThreadState 负责与 binder 驱动进行具体的命令通信。</p><p><script src="https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js"></script><script src="https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js"></script><script src="https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js"></script><script src="https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Client->Binder Driver:BC_TRANSACTIONBinder Driver->Client:BR_TRANSACTION_COMPLETEBinder Driver->Server:BR_TRANSACTIONServer->Binder Driver:BC_REPLYBinder Driver->Server:BR_TRANSACTION_COMPLETEBinder Driver->Client:BR_REPLY</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;智能指针&lt;/li&gt;
&lt;li&gt;binder 驱动中的结构体&lt;/li&gt;
&lt;li&gt;ProcessState&lt;/li&gt;
&lt;li&gt;IPCThreadState&lt;/li&gt;
&lt;li&gt;BpBinder&lt;/li&gt;
&lt;li&gt;BinderProxy&lt;/li&gt;
&lt;li&gt;ServiceManager getService 流程&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="读书笔记" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="binder" scheme="http://yhaowa.gitee.io/yhaowa/tags/binder/"/>
    
      <category term="ProcessState" scheme="http://yhaowa.gitee.io/yhaowa/tags/ProcessState/"/>
    
      <category term="IPCThreadState" scheme="http://yhaowa.gitee.io/yhaowa/tags/IPCThreadState/"/>
    
      <category term="BpBinder" scheme="http://yhaowa.gitee.io/yhaowa/tags/BpBinder/"/>
    
      <category term="BinderProxy" scheme="http://yhaowa.gitee.io/yhaowa/tags/BinderProxy/"/>
    
  </entry>
  
  <entry>
    <title>细读《深入理解 Android 内核设计思想》（三）Binder 机制 [上]</title>
    <link href="http://yhaowa.gitee.io/yhaowa/a7541469/"/>
    <id>http://yhaowa.gitee.io/yhaowa/a7541469/</id>
    <published>2020-04-12T09:58:51.000Z</published>
    <updated>2020-12-06T09:18:58.355Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>必备知识<ol><li>设备驱动</li><li>文件描述符</li><li>页框</li></ol></li><li>Binder 概述</li><li>binder 驱动<ol><li>binder_open</li><li>binder_mmap</li><li>binder_ioctl</li></ol></li><li>Service Manager<ol><li>启动</li><li>注册与查询</li></ol></li><li>最后</li></ol></blockquote><a id="more"></a><p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em></p><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>Linux 把所有的硬件访问都抽象为对文件的读写、设置，这一”抽象”的具体实现就是驱动程序。驱动程序充当硬件和软件之间的枢纽，提供了一套标准化的调用，并将这些调用映射为实际硬件设备相关的操作，对应用程序来说隐藏了设备工作的细节。  </p><p>Linux 设备分为三类，分别是字符设备、块设备和网络设备：</p><p><strong>1.字符设备：</strong> 能够像字节流（类似文件）一样被访问的设备。对字符设备进行读/写操作时，实际硬件的 I/O 操作一般也紧接着发生。字符设备驱动程序通常都会实现 open、close、read 和 write 系统调用，比如触摸屏、键盘、串口、LCD、LED 等。<br><strong>2.块设备：</strong> 指通过传输数据块（一般为 512 或 1k）来访问的设备，比如硬盘、SD卡、U盘、光盘等。<br><strong>3.网络设备：</strong> 能够和其他主机交换数据的设备，比如网卡设备、蓝牙设备等。</p><p>通过 cat /proc/devices 命令可以查看字符设备和块设备：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Character devices:</span><br><span class="line">  <span class="number">1</span> mem</span><br><span class="line">  <span class="number">4</span> ttyS</span><br><span class="line"> <span class="number">10</span> misc</span><br><span class="line">   ...</span><br><span class="line">Block devices:</span><br><span class="line">  <span class="number">1</span> ramdisk</span><br><span class="line">  <span class="number">7</span> loop</span><br><span class="line">  <span class="number">8</span> sd</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p><p>可以看到属于字符设备的 misc 杂项设备，设备号为 10。通过  ls /dev -l 命令可以查看具体的注册设备：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crw-rw-rw- <span class="number">1</span> root   root    <span class="number">10</span>,  <span class="number">61</span> <span class="number">2020</span><span class="number">-03</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span> ashmem</span><br><span class="line">crw-rw-rw- <span class="number">1</span> root   root    <span class="number">10</span>,  <span class="number">58</span> <span class="number">2020</span><span class="number">-03</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span> binder</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>其中 Ashmem、Binder 的设备号是 10，都属于 misc 杂项设备，10 是 <strong>主设备号</strong>，61、58 叫做 <strong>从设备号</strong>，有了主、从设备号，就可以唯一标识一个设备。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。</p><p>文件描述符与文件是什么关系呢？下图 Linux 中的三张表可以体现：<br><img src="../img/fd.png" alt></p><ul><li><p><strong>进程级别的文件描述符表</strong>：内核为每个进程维护一个文件描述符表，该表记录了文件描述符的相关信息，包括文件描述符、指向打开文件表中记录的指针。</p></li><li><p><strong>系统级别的打开文件表</strong>：内核对所有打开文件维护的一个进程共享的打开文件描述表，表中存储了处于打开状态文件的相关信息，包括文件类型、访问权限、文件操作函数(file_operations)等。</p></li><li><p><strong>系统级别的 i-node 表</strong>：i-node 结构体记录了文件相关的信息，包括文件长度，文件所在设备，文件物理位置，创建、修改和更新时间等，”ls -i” 命令可以查看文件 i-node 节点</p></li></ul><p>文件描述符是一种系统资源，可以通过以下命令来查看文件描述符的上限：<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有进程允许打开的最大 fd 数量</span></span><br><span class="line">126|generic_x86:/ # cat /proc/sys/fs/file-max</span><br><span class="line">174139</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有进程已经打开的 fd 数量以及允许的最大数量</span></span><br><span class="line">generic_x86:/ # cat /proc/sys/fs/file-nr</span><br><span class="line">11040   0       174139</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看单个进程允许打开的最大 fd 数量.</span></span><br><span class="line">generic_x86:/ # ulimit -n</span><br><span class="line">32768</span><br></pre></td></tr></table></figure></p><p>也可以查看某进程当前已使用的 fd ：<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看某进程（进程 id 为 15077）已经打开的 fd</span></span><br><span class="line">generic_x86:/ # ls -l /proc/15077/fd/</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 0 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 1 -&gt; /dev/null</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 35 -&gt; /dev/binder</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-09 01:01 44 -&gt; socket:[780404]</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 55 -&gt; /dev/ashmem</span><br><span class="line">lrwx------ 1 u0_a136 u0_a136 64 2020-04-15 23:04 60 -&gt; /dev/ashmem</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>上面这个进程是一个 Android 应用进程，所以能看到 ashmem、binder 等 Android 特有设备文件相关的 fd 。再来看一个实际打开磁盘文件的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(getCacheDir(), <span class="string">"testFdFile"</span>);</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br></pre></td></tr></table></figure></p><p>执行上面代码后会申请一个对应的 fd：<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -l /proc/&#123;pid&#125;/fd/</span></span><br><span class="line">...</span><br><span class="line">l-wx------ u0_a55   u0_a55  2020-04-16 00:24 995 -&gt; /data/data/com.example.test/cache/testFdFile</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>实际开发中，可能会遇到 fd 资源超过上限导致的 “Too many open files” 之类的问题，一般都是因为没有及时释放掉 fd，比如上面代码中 FileOutputStream 没有关闭，若循环执行超过单个进程允许打开的最大 fd 数量，程序就会出现异常。</p><h3 id="页框"><a href="#页框" class="headerlink" title="页框"></a>页框</h3><p>页框（Page Frame）是指一块实际的物理内存块，页是指程序的一块内存数据单元。内存数据一定是存储在实际的物理内存上，即页必然对应于一个页框，页数据实际是存储在页框上的。</p><p>页框和页一样大，都是内核对内存的分块单位。一个页框可以映射给多个页，也就是说一块实际的物理存储空间可以映射给多个进程的多个虚拟内存空间，这也是 mmap 机制依赖的基础规则。</p><h2 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h2><p>不同进程处于不同的内存空间，具有不同的虚拟地址映射规则，所以不能直接通信。 Binder 是 Android 中使用最广泛的 IPC 机制，正因为有了 Binder，Android 系统中形形色色的进程与组件才能真正统一成有机的整体。Binder 通信机制与 TCP/IP 有共通之处，其组成元素可以这样来类比：</p><ul><li>binder 驱动  -&gt;  路由器</li><li>Service Manager  -&gt; DNS</li><li>Binder Client  -&gt;  客户端</li><li>Binder Server  -&gt;  服务器</li></ul><p>Binder 的本质目标就是客户端要与服务器通信，但由于是不同的进程，必须通过 binder 驱动（路由器）把请求正确投递到对方进程中，所以通信的进程需要持有一个唯一的 Binder 标志（IP 地址）。</p><p>而 Binder 标志可能是会动态更新的 “IP 地址”，对通信进程来说获取难度较大且可读性差，这就需要一个 Service Manager（DNS）来解决这个问题。但 Service Manager 自身也是一个 Binder Server（服务器），怎么找到它的 “IP 地址”呢？Binder 机制对此做了特别规定：Service Manager 在 Binder 通信过程中的唯一标志永远是 0。</p><h2 id="binder-驱动"><a href="#binder-驱动" class="headerlink" title="binder 驱动"></a>binder 驱动</h2><p>binder 驱动运行在内核态，向上层提供 /dev/binder 设备节点，并不对应真实的硬件设备。binder 驱动的注册逻辑在 Binder.c 中：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/staging/android/Binder.c</span></span><br><span class="line"><span class="keyword">static</span> init __init binder_init(<span class="keyword">void</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = misc_register(&amp;binder_miscdev); <span class="comment">//注册为 misc 驱动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>binder_miscdev 即 Binder 设备描述如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice binder_miscdev = &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR, <span class="comment">//自动分配次设备号</span></span><br><span class="line">    .name = <span class="string">"binder"</span>, <span class="comment">//驱动名称</span></span><br><span class="line">    .fops = &amp;binder_fops <span class="comment">//binder 驱动支持的文件操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>binder_fops 为 Binder 设备支持的操作函数，如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>与 Ashmem 设备类似，最关键的是 binder_open()、binder_mmap()、binder_ioctl()，下面分别介绍这三个函数。</p><h3 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h3><p>用户应用程序通过 Binder 通信时，需先调用 binder_open() 方法打开 binder 驱动，binder_open() 中主要做了两个工作，对应的分为两部分来看：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//binder.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_open(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc;</span><br><span class="line">    ...</span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); <span class="comment">//创建 binder_proc</span></span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo); <span class="comment">//初始化 todo 队列</span></span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait); <span class="comment">//初始化 todo 队列</span></span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br></pre></td></tr></table></figure></p><p>上面代码的主要工作是 <strong>创建及初始化 binder_proc</strong>，binder_proc 就是用来存放 binder 相关数据的结构体，每个进程独有一份。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    binder_lock(__func__);</span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个主要工作是 <strong>将 binder_proc 记录起来</strong>，方便后续使用，如上代码所示，通过 hlist_add_head() 方法将 binder_proc 记录到了内核的 binder_procs 表中，另外还将 binder_proc 存放在 filp 的 private_data 域，以便于在后续调用 mmap、ioctl 等方法时获取。</p><h3 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h3><p>对于 binder 驱动来说，上层应用调用的 mmap() 最终会执行到 binder_mmap() 方法，binder_mmap() 的主要工作是<strong>将上层应用的虚拟内存块和 Binder 申请的物理内存块建立映射</strong>，应用程序和 Binder 就拥有了共享的内存空间，这样不同的应用程序之间可以通过 Binder 实现数据共享。举个例子：</p><ul><li>Binder 中有一物理内存块 P；A 进程中有一内存块 a ；B 进程中有一内存块 b</li><li>将 P 分别与 a、b 建立映射，这样 a、b 就可以看作同一块内存</li><li>若 A 进程想要发送数据给 B 进程，只需将数据拷贝到 a 内存，B 进程就能直接读取到了</li></ul><p>所以 Binder 只需一次拷贝，binder_mmap() 要做的就是将 P 与 a 建立映射，该方法代码较长，分段看关键部分代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_mmap(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)&#123;</span><br><span class="line">    <span class="keyword">struct</span> vm_struct *area;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</span><br><span class="line">    <span class="comment">//映射空间至多 4M</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">          vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line">    <span class="comment">//检查 vma 是否被禁用</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">          ret = -EPERM;</span><br><span class="line">          failure_string = <span class="string">"bad vm_flags"</span>;</span><br><span class="line">          <span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>vma(vm_area_struct) 是<strong>用户态虚拟内存地址空间</strong>，也就是 a</li><li>area(vm_struct) 是<strong>内核态虚拟地址空间</strong>，指向 P</li><li>proc(binder_proc) 即 binder_open() 中创建的、存放 binder 相关数据的结构体</li><li>另外还做了限制映射空间至多 4M 等映射规则的检查和处理</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> mutex_lock(&amp;binder_mmap_lock);</span><br><span class="line"><span class="comment">//检查是否已执行过 binder_mmap 映射过</span></span><br><span class="line"><span class="keyword">if</span> (proc-&gt;buffer) &#123; </span><br><span class="line">      ret = -EBUSY;</span><br><span class="line">      failure_string = <span class="string">"already mapped"</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//申请内核虚拟内存地址空间</span></span><br><span class="line">area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line"><span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将内核虚拟内存地址记录在 proc 中 </span></span><br><span class="line">proc-&gt;buffer = area-&gt;addr;</span><br><span class="line"><span class="comment">//记录用户态虚拟内存地址和内核态虚拟内存地址的偏移量</span></span><br><span class="line">proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;</span><br><span class="line">mutex_unlock(&amp;binder_mmap_lock);</span><br></pre></td></tr></table></figure><ul><li>proc-&gt;buffer 用于存储最终映射的内核态虚拟地址，并通过此变量控制只能映射一次</li><li>get_vm_area() 方法申请了与用户态空间大小一致的内核态虚拟地址空间，注意此时还没分配实际的物理内存</li><li>proc-&gt;user_buffer_offset 记录了用户态虚拟内存和内核态虚拟内存地址的偏移量，这样后续方便获取用户态虚拟内存地址</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配存放物理页地址的数组</span></span><br><span class="line">proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"><span class="comment">//申请一页物理内存</span></span><br><span class="line"><span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      failure_string = <span class="string">"alloc small buf"</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后的收尾工作：将内存记录到相应链表中，设置状态等</span></span><br><span class="line">INIT_LIST_HEAD(&amp;proc-&gt;buffers);</span><br><span class="line">list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</span><br><span class="line">buffer-&gt;free = <span class="number">1</span>;</span><br><span class="line">binder_insert_free_buffer(proc, buffer);</span><br><span class="line">proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">proc-&gt;files = get_files_struct(current);</span><br><span class="line">proc-&gt;vma = vma;</span><br></pre></td></tr></table></figure><ul><li>proc-&gt;pages 是一个二维指针，用于存放管理物理页面</li><li>binder_update_page_range() 方法真正的申请物理页面，并分别映射到内核态和用户态的虚拟内存地址空间</li></ul><p>至此 binder_mmap 方法执行结束，书中并没有对 <strong>binder_update_page_range()</strong> 方法具体展开介绍，但个人认为此方法代码非常有助于我们理解页框以及与虚拟内存地址的映射逻辑，所以继续分析，先了解此方法的参数：</p><ul><li>proc：申请内存的进程所持有的 binder_proc 对象</li><li>allocate：1 表示申请内存，0 表示释放内存</li><li>start：虚拟内存地址起点</li><li>end：虚拟内存地址终点</li><li>vma：用户态虚拟内存地址空间</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_update_page_range(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">int</span> allocate,</span><br><span class="line">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</span><br><span class="line">                    <span class="keyword">struct</span> vm_area_struct *vma)&#123;</span><br><span class="line">    <span class="keyword">if</span> (allocate == <span class="number">0</span>)  <span class="comment">//区分是申请还是释放</span></span><br><span class="line">         <span class="keyword">goto</span> free_range;</span><br><span class="line">    <span class="comment">//依据 start、end 循环分配物理页</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">          <span class="comment">//每次分配 1 个页框*/</span></span><br><span class="line">         *page = **alloc_page**(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);</span><br><span class="line">         <span class="comment">//将页框映射到内核态虚拟内存地址</span></span><br><span class="line">         ret = **map_kernel_range_noflush**((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr, PAGE_SIZE, PAGE_KERNEL, page);</span><br><span class="line">         <span class="comment">//根据 binder_mmap 方法中记录的偏移量计算出用户态虚拟内存地址</span></span><br><span class="line">         user_page_addr = (uintptr_t)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line">         <span class="comment">//将页框映射到用户态虚拟内存地址</span></span><br><span class="line">         ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>binder_mmap() 的 allocate 参数传入 1 为申请内存，执行上面的代码。若为释放则执行以下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">free_range:</span><br><span class="line">    <span class="comment">//依据 start、end 从后往前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = end - PAGE_SIZE; page_addr &gt;= start; page_addr -= PAGE_SIZE) &#123;</span><br><span class="line">        page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line">        <span class="keyword">if</span> (vma)</span><br><span class="line">            <span class="comment">//解除用户态虚拟地址和物理页框的映射</span></span><br><span class="line">            zap_page_range(vma, (uintptr_t)page_addr + proc-&gt;user_buffer_offset, PAGE_SIZE, <span class="literal">NULL</span>);</span><br><span class="line">err_vm_insert_page_failed:</span><br><span class="line">        <span class="comment">//解除内核态虚拟地址和物理页框的映射</span></span><br><span class="line">        unmap_kernel_range((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr, PAGE_SIZE);</span><br><span class="line">err_map_kernel_failed:</span><br><span class="line">        <span class="comment">//释放页框物理内存</span></span><br><span class="line">        __free_page(*page);</span><br><span class="line">        *page = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h3><p>binder 驱动并不提供常规的 read()、write() 等文件操作，全部通过 binder_ioctl() 实现，所以 binder_ioctl() 是 binder 驱动中工作量最大的一个，它承担了 binder 驱动的大部分业务。这里不深入分析源码，只列出 binder_ioctl() 支持的命令列表：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>BINDER_WRITE_READ</td><td>向 binder 驱动写入或读取数据</td></tr><tr><td>BINDER_SET_MAX_THREADS</td><td>设置支持的最大线程数</td></tr><tr><td>BINDER_SET_CONTEXT_MGR</td><td>Service Manager 专用的注册命令</td></tr><tr><td>BINDER_THREAD_EXIT</td><td>通知 binder 驱动某线程退出，释放相应资源</td></tr><tr><td>BINDER_VERSION</td><td>获取 Binder 版本号</td></tr></tbody></table><p>其中 BINDER_WRITE_READ 最为关键，分为若干子命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>BC_INCREFS、BC_ACQUIRE、BC_RELEASE、BC_DECREFS</td><td>管理 binder_ref 的引用计数</td></tr><tr><td>BC_INCREFS_DONE、BC_ACQUIRE_NODE</td><td>管理 binder_node 的引用计数</td></tr><tr><td>BC_FREE_BUFFER</td><td>释放 Binder 内存缓冲区</td></tr><tr><td>BC_TRANSACTION</td><td>向 binder 驱动发送通信数据(主动调用)</td></tr><tr><td>BC_REPLY</td><td>向 binder 驱动发送通信数据(返回结果)</td></tr><tr><td>BC_REGISTER_LOOPER、BC_ENTER_LOOPER、BC_EXIT_LOOPER</td><td>设置 Binder looper 状态</td></tr><tr><td>BC_REQUEST_DEATH_NOTIFICATION</td><td>注册 Binder 死亡通知</td></tr><tr><td>BC_CLEAR_DEATH_NOTIFICATION</td><td>清除 Binder 死亡通知</td></tr><tr><td>BC_DEAD_BINDER_DONE</td><td>告知 Binder 已处理完 Binder 死亡通知</td></tr></tbody></table><p>以上均为 binder 驱动作为接收方 binder_ioctl() 方法接收的命令，还有一些与之对应的 BR_ 开头的命令，由 binder 驱动主动发出，比如 BR_TRANSACTION、BR_REPLY，在一次 IPC 调用中是这样应用的：</p><div id="sequence-0"></div><h2 id="Service-Manager"><a href="#Service-Manager" class="headerlink" title="Service Manager"></a>Service Manager</h2><p>Service Manager 是为了完成 Binder Server Name（域名）和 Service Handle（IP 地址）之间对应关系的查询而存在的，可以推测它主要包含的功能：<br><strong>注册</strong>：当一个 Binder Server 创建后，应该将这个 Server 的 name 和 Handle 对应关系记录到 Service Manager 中<br><strong>查询</strong>：其他应用可以根据 Server 的 name 查询到对应的 Service Handle</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Android 系统第一个启动的 init 进程解析 init.rc 脚本时构建出系统的初始运行状态，Android 系统服务程序大多是在这个脚本中描述并被相继启动的，包括 zygote、mediaserver、surfaceflinger 以及 servicemanager 等，其中 servicemanager 描述如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#init.rc</span></span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="keyword">class</span> core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br></pre></td></tr></table></figure></p><p>可以看到，当 servicemanager 发生问题重启时，其他 healthd、zygote、media 等服务也会被重启。servicemanager 服务启动后执行 service_manager.c 的 main 函数，关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/cmds/servicemanager/service_manager.c</span></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_state *bs;</span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中三个函数对应了 servicemanager 初始化的三个关键工作：</p><ol><li>binder 驱动并映射内存块大小为 128KB ：binder_open()</li><li>将自己设置为 Binder “DNS” 管理者 ：binder_become_context_manager()</li><li>进入循环，等待 binder 驱动发来消息 ：binder_loop()</li></ol><p>下面分别来分析这三个函数，binder_open() 关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_state *binder_open(size_t mapsize)&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_state *bs;</span><br><span class="line">    <span class="keyword">struct</span> binder_version vers;</span><br><span class="line">    bs = malloc(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开 binder 驱动，最终调用 binder_open() 函数</span></span><br><span class="line">    bs-&gt;fd = open(<span class="string">"/dev/binder"</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取 Binder 版本，最终调用 binder_ioctl() 函数</span></span><br><span class="line">    ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将虚拟内存映射到 Binder，最终调用 binder_mmap() 函数</span></span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>binder_become_context_manager() ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binder_become_context_manager(<span class="keyword">struct</span> binder_state *bs)&#123;</span><br><span class="line">    <span class="comment">//发送 BINDER_SET_CONTEXT_MGR 命令，最终调用 binder_ioctl() 函数</span></span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>binder_loop() 关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> binder_loop(<span class="keyword">struct</span> binder_state *bs, binder_handler func)&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">//执行 BINDER_WRITE_READ 命令所需的数据格式：</span></span><br><span class="line">    <span class="keyword">struct</span> binder_write_read bwr;</span><br><span class="line">    uint32_t readbuf[<span class="number">32</span>]; <span class="comment">//每次读取数据的大小</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER; </span><br><span class="line">    <span class="comment">//先将 binder 驱动的进入循环命令发送给 binder 驱动：</span></span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(uint32_t));</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//进入循环</span></span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_buffer = (uintptr_t) readbuf; <span class="comment">//读取到的消息数据存储在 readbuf</span></span><br><span class="line">        <span class="comment">//执行 BINDER_WRITE_READ 命令读取消息数据</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理读取到的消息数据</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, (uintptr_t) readbuf, bwr.read_consumed, func);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BINDER_WRITE_READ 命令既可以用来读取数据也可以写入数据，具体是写入还是读取依赖 binder_write_read 结构体的 write_size 和 read_size 哪个大于 0，上面代码通过 bwr.read_size = sizeof(readbuf) 赋值，所以是读取消息。</p><p>binder_parse() 方法内部处理由 binder 驱动主动发出的、一系列 BR_ 开头的命令，包括上面提到过的 BR_TRANSACTION、BR_REPLY 等，简化后的代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binder_parse(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</span><br><span class="line">                 uintptr_t ptr, size_t size, binder_handler func)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            ...</span><br><span class="line">            res = func(bs, txn, &amp;msg, &amp;reply); <span class="comment">//处理消息</span></span><br><span class="line">            <span class="comment">//返回处理结果</span></span><br><span class="line">            inder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); </span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY: &#123;...&#125;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_BINDER: &#123;...&#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于 BR_TRANSACTION 命令主要做了两个工作，一是调用 func() 具体处理消息；二是调用 inder_send_reply() 将消息处理结果告知给 binder 驱动，注意这里的 func 是由 service_manager.c main 函数中传过来的方法指针，也就是 svcmgr_handler() 方法。</p><h3 id="注册与查询"><a href="#注册与查询" class="headerlink" title="注册与查询"></a>注册与查询</h3><p>经过上面 Service Manager 服务启动的过程分析，已经知道由 binder 驱动主动发过来的 BR_TRANSACTION 命令最终在 service_manager.c 的 svcmgr_handler() 方法中处理，那服务的注册与查询请求想必就是在这个方法中实现的了，确实如此，简化后的关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> svcmgr_handler(<span class="keyword">struct</span> binder_state *bs,</span><br><span class="line">                   <span class="keyword">struct</span> binder_transaction_data *txn,</span><br><span class="line">                   <span class="keyword">struct</span> binder_io *msg,</span><br><span class="line">                   <span class="keyword">struct</span> binder_io *reply)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">         <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">         <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">              <span class="comment">//查询服务，根据 name 查询 Server Handle</span></span><br><span class="line">              handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">             <span class="comment">//注册服务，记录服务的 name(下面的参数 s) 与 handle</span></span><br><span class="line">             <span class="keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">                 allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> SVC_MGR_LIST_SERVICES: &#123;</span><br><span class="line">             <span class="comment">//查询所有服务，返回存储所有服务的链表 svclist</span></span><br><span class="line">             si = svclist;</span><br><span class="line">             <span class="keyword">while</span> ((n-- &gt; <span class="number">0</span>) &amp;&amp; si)</span><br><span class="line">                 si = si-&gt;next;</span><br><span class="line">             <span class="keyword">if</span> (si) &#123;</span><br><span class="line">                 bio_put_string16(reply, si-&gt;name);</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 bio_XX 系列函数的作用是方便读写数据。注册的服务都会存储在 svclist 链表上，do_find_service() 方法遍历 svclist 查找对应的服务，do_add_service() 则是将服务插入到 svclist 链表上记录下来。</p><p>svcmgr_handler() 方法执行完后会进一步调用 inder_send_reply() 将执行结果回复给 binder 驱动，然后进入下一轮的循环继续等待处理消息。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>非常认可书中一个观点：或许我们不应该从已经完善的架构类图去推导它们各自的作用，而是从 Binder 设计者的角度出发，去思考如果要提供某个功能，应该怎么做？</p><p>通过上面的分析知道，Service Manager 开始工作后等待执行 binder 驱动发来的命令就行了，那其他进程如何访问 Service Manager 呢？无非就是以下步骤：</p><ul><li>1.打开 binder 驱动，将进程内虚拟内存块与 binder 驱动进行 mmap</li><li>2.通过 ioctl 通信，让 binder 驱动向 Service Manager 发送命令</li><li>3.binder 驱动返回结果</li></ul><p>不要怀疑，核心工作确实只有这些，只是还有一些细节待商榷，比如：</p><ul><li>打开并映射 binder 驱动需占用进程内存，可以限制一下打开次数或映射大小</li><li>binder 驱动的操作比较繁琐，native 层应该封装一下</li><li>Java 层也需要封装接口，方便上层应用调用…</li></ul><p>然后 ProcessState、IPCThreadState、BBinder、BpBinder 等等相继出现…</p><p><script src="https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js"></script><script src="https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js"></script><script src="https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js"></script><script src="https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Client->Binder Driver:BC_TRANSACTIONBinder Driver->Client:BR_TRANSACTION_COMPLETEBinder Driver->Server:BR_TRANSACTIONServer->Binder Driver:BC_REPLYBinder Driver->Server:BR_TRANSACTION_COMPLETEBinder Driver->Client:BR_REPLY</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;必备知识&lt;ol&gt;
&lt;li&gt;设备驱动&lt;/li&gt;
&lt;li&gt;文件描述符&lt;/li&gt;
&lt;li&gt;页框&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Binder 概述&lt;/li&gt;
&lt;li&gt;binder 驱动&lt;ol&gt;
&lt;li&gt;binder_open&lt;/li&gt;
&lt;li&gt;binder_mmap&lt;/li&gt;
&lt;li&gt;binder_ioctl&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Service Manager&lt;ol&gt;
&lt;li&gt;启动&lt;/li&gt;
&lt;li&gt;注册与查询&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="读书笔记" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="binder" scheme="http://yhaowa.gitee.io/yhaowa/tags/binder/"/>
    
      <category term="Linux driver" scheme="http://yhaowa.gitee.io/yhaowa/tags/Linux-driver/"/>
    
      <category term="Service Manager" scheme="http://yhaowa.gitee.io/yhaowa/tags/Service-Manager/"/>
    
  </entry>
  
  <entry>
    <title>细读《深入理解 Android 内核设计思想》（二）内存管理</title>
    <link href="http://yhaowa.gitee.io/yhaowa/2d9a78ad/"/>
    <id>http://yhaowa.gitee.io/yhaowa/2d9a78ad/</id>
    <published>2020-04-06T06:18:55.000Z</published>
    <updated>2020-12-06T09:18:58.330Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>操作系统内存管理基础<ol><li>虚拟内存</li><li>内存分配与回收</li><li>mmap</li><li>Copy on Write</li></ol></li><li>Android 内存管理<ol><li>Low Memory Killer</li><li>Ashmem 驱动</li><li>MemoryFile 原理</li></ol></li><li>总结</li></ol></blockquote><a id="more"></a><p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em></p><h2 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h2><p>不论什么操作系统，内存管理都是绝对的重点和难点。内存管理旨在为系统中所有 Task 提供稳定可靠的内存分配、释放和保护机制。你可能会疑问，学习 Android 系统有必要了解 Linux Kernel 的内存管理机制吗？</p><p>是的！不论是 Android 的音频系统、GUI 系统，还是 Binder 的实现机理等，都是和内存管理息息相关的。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存就是当内存资源不足时，借用硬盘中的一部分的空间，充当内存使用。系统会挑选优先级低的内存数据放入硬盘，后续若要用到硬盘中的数据，系统会产生一次<strong>缺页中断</strong>，然后把数据交换回内存中。</p><p>要理解虚拟内存机制，就要理解三种地址空间，分别是逻辑地址、线性地址和物理地址：</p><p><strong>1.逻辑地址(Logical Address)</strong><br>逻辑地址是程序编译后产生的地址，也称为相对地址，由两部分组成：</p><ul><li>段选择子(Segment Selector)：描述逻辑地址所处的段</li><li>Offset：描述所在段内的偏移值</li></ul><p><strong>2.线性地址(Linear Address)</strong><br>线性地址是由逻辑地址经过<strong>分段机制转换</strong>后得到的。</p><p>大致转换过程为：通过段选择子确定段的基地址，然后结合 Offset 得到线性地址。</p><p><strong>3.物理地址(Physical Address)</strong><br>物理地址就是指机器真实的物理内存地址，任何操作系统，最终都要通过物理地址来访问内存。</p><p>若系统开启了分页机制，则在得到线性地址后需要通过<strong>分页机制转换</strong>后，才能得到物理地址。</p><p>简单来说，由逻辑地址得到物理地址过程如下：</p><ul><li>逻辑地址 -&gt; 分段机制转换 -&gt; 线性地址 -&gt; 分页机制转换 -&gt; 物理地址</li></ul><h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><p>内存的分配与回收是操作系统的重要组成部分，需要解决的核心问题包括：</p><ul><li>操作系统应保证应用程序的硬件无关性，硬件差异不能体现在应用程序上</li><li>内存划分的区域、分配粒度、最小单位，管理区分已使用和未使用的内存，回收等等</li><li>优化内存碎片，考虑整体机制的高效性</li></ul><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>mmap(Memory Map) 可以将某个设备或文件映射到应用进程的内存空间中，这样应用程序访问这块内存，相当于直接对设备/文件读写，不再需要 read、write 等 IO 操作。</p><p>mmap 函数如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射成功返回0，否则返回错误码</span></span><br><span class="line"><span class="keyword">void</span> *mmap(<span class="keyword">void</span> *addr, size_t len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, off_t offset);</span><br></pre></td></tr></table></figure></p><ul><li>addr：指文件/设备应该映射到进程空间的哪个起始地址</li><li>len：指被映射到进程空间的内存块大小</li><li>prot：指定被映射内存的访问权限，包括 PROT_READ(可读)、PROT_WRITE(可写) 等</li><li>flags：指定程序对内存块所做改变造成的影响，包括 MAP_SHARED(保存到文件) 等</li><li>fd：被映射到进程空间的文件描述符</li><li>offset：指定从文件的哪一部分开始映射</li></ul><p>源码见 <a href="http://androidxref.com/9.0.0_r3/xref/bionic/libc/bionic/mmap.cpp" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/bionic/libc/bionic/mmap.cpp</a> 。mmap 可用于跨进程通信，Linux Kernel 和 Android 中就频繁的用到了这个函数，比如 Android 的 Binder 驱动，下面分析 MemoryFile 原理时还会提到这个函数。</p><h3 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h3><p>Copy on Write(写时拷贝) 是指如果有多个调用者要请求同一资源，他们会获取到相同的指向这一资源的指针，直到某个调用者需修改资源时，系统才会复制一份副本给该调用者，而其他调用者仍使用最初的资源。</p><p>如果调用者不需要修改资源，就不会建立副本，多个调用者共享读取同一份资源。</p><p>Linux 的 fork() 函数就是 Copy on Write 的，实际开销很小，主要是给子进程创建进程描述符等，并且推迟甚至免除了数据拷贝操作。比如 fork() 后子进程需立即调用 exec() 装载新程序到进程的内存空间，即不需要父进程的任何数据，这种情况 Copy on Write 技术就避免了不必要的数据拷贝，从而提升了运行速度。</p><h2 id="Android-内存管理"><a href="#Android-内存管理" class="headerlink" title="Android 内存管理"></a>Android 内存管理</h2><h3 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h3><p>Linux Kernel 有自己的内存监控机制，即 OOMKiller。当系统的可用内存达到临界值时，OOMKiller 就会按照优先级从低到高杀掉进程。优先级该如何衡量呢？OOMKiller 会综合进程当前消耗内存、进程占用 CPU 时间、进程类型等因素，对进程实时评分。分值存储在 /proc/{PID}/oom_score 中，可通过 cat 命令查看。分值越低的进程，优先级越高，被杀死的概率越小。</p><p>基于 Linux 内核 OOMKiller 的核心思想，Android 系统拓展出了自己的内存监控体系，相比 Linux 达到临界值才触发，Android 实现了<strong>不同梯级</strong>的 Killer。Android 系统为此开发了专门的驱动，名为 Low Memory Killer，源码在内核的 /drivers/staging/android/Lowmemorykiller.c 中。</p><p>Lowmemorykiller.c 中有如下定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_adj[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_adj_size = <span class="number">4</span>; <span class="comment">//页大小</span></span><br><span class="line"><span class="keyword">static</span> size_t lowmem_minfree[<span class="number">6</span>] = &#123; <span class="comment">//元素使用时以 lowmem_adj_size 为单位</span></span><br><span class="line">    <span class="number">3</span> * <span class="number">512</span>, <span class="comment">//6MB</span></span><br><span class="line">    <span class="number">2</span> * <span class="number">1024</span>, <span class="comment">//8MB</span></span><br><span class="line">    <span class="number">4</span> * <span class="number">1024</span>, <span class="comment">//16MB</span></span><br><span class="line">    <span class="number">16</span> * <span class="number">1024</span>，<span class="comment">//64MB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>lowmem_minfree 定义了可用内存容量对应的不同梯级。lowmem_adj 与 lowmem_minfree 中的梯级一一对应，表示处于某梯级时需要被处理的 adj 值。adj 值用来描述进程的优先级，取值范围为 -17~15，数字越小表示进程优先级越高，被杀死的概率越小。</p><p>比如当可用内存低于 64MB 时，即 lowmem_minfree 第 4 梯级，对应于 lowmem_adj 的 12，那就会清理掉优先级低于 12（即 adj&gt;12）的进程。</p><p>上面这两个数组中梯级的定义只是系统的预定义值，Android 系统还提供了相应的文件供我们修改这两组值，路径为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sys/module/lowmemorykiller/parameters/adj</span><br><span class="line">/sys/module/lowmemorykiller/parameters/minfree</span><br></pre></td></tr></table></figure><p>可以在 init.rc(系统启动时由 init 进程解析的一个脚本) 中，这样修改：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write /sys/module/lowmemorykiller/parameters/adj        <span class="number">0</span>, <span class="number">8</span></span><br><span class="line">write /sys/module/lowmemorykiller/parameters/minfree <span class="number">1024</span>, <span class="number">4096</span></span><br></pre></td></tr></table></figure></p><p>另外 ActivityManagerService 中有一个 updateOomLevels 方法也是通过修改这两个文件来实现的，AMS 在运行时会根据当前的系统配置自动调整 adj 和 minfree，以尽可能适配不同的硬件设备。 </p><p>了解了 Low Memory Killer 的梯级规则后，来看下 Android 进程的 adj 值含义：</p><table><thead><tr><th>ADJ</th><th>说明</th></tr></thead><tbody><tr><td>HIDDEN_APP_MAX_AD = 15</td><td>只运行了不可见 Activity 的进程</td></tr><tr><td>HIDDEN_APP_MIN_ADJ = 9</td><td>只运行了不可见 Activity 的进程</td></tr><tr><td>SERVICE_B_ADJ = 8</td><td>B list of Service</td></tr><tr><td>PREVIOUS_APP_ADJ = 7</td><td>用户的上一个产生交互的进程</td></tr><tr><td>HOME_APP_ADJ = 6</td><td>Launcher 进程</td></tr><tr><td>SERVICE_ADJ = 5</td><td>当前运行了 application service 的进程</td></tr><tr><td>BACKUP_APP_ADJ = 4</td><td>用于承载 backup 相关操作的进程</td></tr><tr><td>HEAVY_WEIGHT_APP_ADJ = 3</td><td>重量级应用程序进程</td></tr><tr><td>PERCEPTIBLE_APP_ADJ = 2</td><td>能被用户感觉但不可见，如后台运行的音乐播放器</td></tr><tr><td>VISIBLE_APP_ADJ = 1</td><td>有前台可见的 Activity</td></tr><tr><td>FOREGROUND_APP_ADJ = 0</td><td>当前正在前台运行与用户交互的进程</td></tr><tr><td>PERSISTENT_PROC_ADJ = -12</td><td>Persistent 性质的进程，如 telephony</td></tr><tr><td>SYSTEM_ADJ = -16</td><td>系统进程</td></tr></tbody></table><p>除了表格中系统的评定标准，有没有办法改变某一进程的 adj 值呢？和修改上面的 adj、minfree 梯级类似，进程的 adj 值也可以通过写文件的方式来修改，路径为 /proc/{PID}/oom_adj，比如 init.rc 中：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write /proc/<span class="number">1</span>/oom_adj <span class="number">-16</span></span><br></pre></td></tr></table></figure></p><p>另外还可以在 AndroidManifest.xml 中给 application 添加 “android:persistent=true” 属性。</p><h3 id="Ashmem-驱动"><a href="#Ashmem-驱动" class="headerlink" title="Ashmem 驱动"></a>Ashmem 驱动</h3><p>Anonymous Shared Memory 匿名共享内存是 Android 特有的内存共享机制，它可以将指定的物理内存分别映射到各个进程自己的虚拟地址空间中，从而便捷的实现进程间内存共享，Ashmem 的实现依赖 Ashmem 设备节点。</p><p>怎么理解设备节点呢？Linux 抽象了对硬件的处理，所有的硬件设备都可以当作普通文件一样来看待，设备节点文件是设备驱动的逻辑文件，其中对设备的描述包括文件操作函数集合，应用程序可以通过这些函数来访问硬件设备。</p><p>除了磁盘等真正的硬件设备，还可以通过内存抽象，使用设备节点文件的方式来描述一个”设备”并使用它，Ashmem、Binder 驱动都是属于这种内存抽象的”设备”。</p><p>介绍 Ashmem 设备节点前，先了解下 ueventd 进程。ueventd 就是 Android 中负责创建和管理设备节点的进程，创建设备节点文件有两种方式：<br><strong>1</strong>.静态节点文件：以预先定义的设备信息为基础，当 ueventd 进程启动后，统一创建设备节点文件<br><strong>2</strong>.动态节点文件：即在系统运行中，当有设备插入 USB 端口时，ueventd 进程就会接收到这一事件，为插入的设备动态创建设备节点文件</p><p>Ashmem 设备节点就属于静态节点文件，创建过程如下：<br><strong>1</strong>.Android 系统启动，解析 init.rc，启动 ueventd 进程<br><strong>2</strong>.ueventd 进程会去解析 ueventd.rc，读取 ashmem 设备节点信息到系统中</p><p>其中 ueventd.rc 文件格式如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/dev/null                 <span class="number">0666</span>   root       root</span><br><span class="line">/dev/zero                 <span class="number">0666</span>   root       root</span><br><span class="line">/dev/random               <span class="number">0666</span>   root       root</span><br><span class="line">/dev/ashmem               <span class="number">0666</span>   root       root</span><br><span class="line">/dev/binder               <span class="number">0666</span>   root       root</span><br></pre></td></tr></table></figure></p><p>可以看到包括 binder、ashmem 在内的一系列设备节点信息都会在这里读取到系统中。</p><p>随后 ashmem 会调用 ashmem.c 文件的 ashmem_init 进行初始化：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _init ashmem_init(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ashmem_area_cachep = kmem_cache_create(<span class="string">"ashmem_area_cache"</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ashmem_area),<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>); </span><br><span class="line">    ashmem_range_cachep = kmem_cache_create(<span class="string">"ashmem_range_cache"</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ashmem_range),<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    ret = misc_register(&amp;ashmem_misc);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 kmem_cache_create() 函数创建了两个 cache，后面申请内存时需要用到。对于 kmem_cache_create() 函数，书中提及 Slab、Slub、Slob 三种机制，这里不再延伸，仅理解： kmem_cache_create() 并没有真正的分配内存，后续还要调用 kmem_cache_alloc() 。</p><p>由于 ashmem 属于 misc 杂项设备，所以调用 misc_register(&amp;ashmem_misc) 进行设备注册。ashmem_misc 就是 Ashmem 的设备描述，定义如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice ashmem_misc = &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR, <span class="comment">//自动分配次设备号</span></span><br><span class="line">    .name = <span class="string">"ashmem"</span>, <span class="comment">//设备节点的名称</span></span><br><span class="line">    .fops = &amp;ashmem_fops, <span class="comment">//文件操作集合</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>.fops 就是上面提到的”文件操作函数集合”，即 Ashmem 设备的操作函数集，如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> file_operations ashmem_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = ashmem_open,</span><br><span class="line">    .release = ashmem_release,</span><br><span class="line">    .read = ashmem_read,</span><br><span class="line">    .llseek = ashmem_llseek,</span><br><span class="line">    .mmap = ashmem_mmap,</span><br><span class="line">    .unlocked_ioctl = ashmem_ioctl,</span><br><span class="line">    .compat_ioctl = ashmem_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中 ashmem_open、ashmem_mmap 及 ashmem_ioctl 函数比较重要，依次来看：</p><p><strong>1.ashmem_open</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)&#123;</span><br><span class="line">    <span class="keyword">struct</span> ashmem_area *asma;</span><br><span class="line">    ...</span><br><span class="line">    asma = kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL)；</span><br><span class="line">    ...</span><br><span class="line">    file-&gt;private_data = asma;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//申请成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ashmem_open 主要做了两个工作，1.调用 kmem_cache_zalloc 方法从 ashmem_area_cachep 分配了一块内存，这个方法和 cache 上面都提到过；2.将 ashmem_area 记录在 file 中 。</p><p><strong>2.ashmem_mmap</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ashmem_mmap(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)&#123;</span><br><span class="line">    <span class="keyword">struct</span> ashmem_area *asma = file-&gt;private_data;</span><br><span class="line">    ...</span><br><span class="line">    mutex_lock(&amp;ashmem_mutex);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!asma-&gt;file)&#123;</span><br><span class="line">        shmem_file_setup(name, asma-&gt;size, vma-&gt;vm_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    shmem_set_file(vma, asma-&gt;file);</span><br><span class="line">    ...</span><br><span class="line">    mutex_unlock(&amp;ashmem_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先拿到在 ashmem_open 函数中创建的 ashmem_area，然后判断如果 asma-&gt;file 为空，说明这是第一个访问该共享内存的进程，调用 shmem_file_setup() 函数在 tmpfs 中创建一个临时文件，用于进程间的内存共享；如果 asma-&gt;file 不为空，直接调用 shmem_set_file 进行内存映射。</p><p><strong>3.ashmem_ioctl</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> ashmem_ioctl(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)&#123;</span><br><span class="line">    <span class="keyword">struct</span> ashmem_area * asma = file-&gt;private_data;</span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">    <span class="keyword">case</span> ASHMEM_SET_NAME:<span class="comment">//设置名称</span></span><br><span class="line">    set_name(asma, (<span class="keyword">void</span> __user *) arg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ASHMEM_GET_NAME:<span class="comment">//获取名称</span></span><br><span class="line">    get_name(asma, (<span class="keyword">void</span> __user *) arg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ASHMEM_SET_NAME:<span class="comment">//设置大小</span></span><br><span class="line">    <span class="keyword">if</span>(!asma-&gt;file)&#123;</span><br><span class="line">        asma-&gt;size = (size_t) arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ashmem_ioctl 即根据 ioctl 命令做相应的操作，设置或获取 size、名称等。</p><h3 id="MemoryFile-原理"><a href="#MemoryFile-原理" class="headerlink" title="MemoryFile 原理"></a>MemoryFile 原理</h3><p>书中通过 MemoryDealer 讲解了 Ashmem 示例，触类旁通，我来分析一下 Ashmem 的另一个应用示例：MemoryFile。MemoryFile 是 Java 层对 Ashmem 的一个封装，使用方法大致如下：</p><p><strong>进程 A 中申请一块共享内存写入数据，并准备好文件描述符：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MemoryFile memoryFile = <span class="keyword">new</span> MemoryFile(name, size);</span><br><span class="line">memoryFile.getOutputStream().write(data);</span><br><span class="line">Method method = MemoryFile.class.getDeclaredMethod("getFileDescriptor");</span><br><span class="line">FileDescriptor des = (FileDescriptor) method.invoke(memoryFile);</span><br><span class="line">ParcelFileDescriptor pfd = ParcelFileDescriptor.dup(des);</span><br></pre></td></tr></table></figure></p><p><strong>进程 B 中通过 binder 拿到 A 进程中准备好的文件描述符，然后直接读取数据：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileDescriptor descriptor = pfd.getFileDescriptor();</span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(descriptor);</span><br><span class="line">fileInputStream.read(data);</span><br></pre></td></tr></table></figure></p><p>使用起来和文件读写一样很简单，如果不了解 Ashmem 机制，也就只能停留在仅会使用的浅显层面了。现在有了 Ashmem 驱动知识的铺垫，来看 MemoryFile 是怎么从 Java API 调用到 Ashmem 驱动函数的，先来看 MemoryFile 的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryFile</span><span class="params">(String name, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSharedMemory = SharedMemory.create(name, length);</span><br><span class="line">        mMapping = mSharedMemory.mapReadWrite();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        ex.rethrowAsIOException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到构造 MemoryFile 时通过 SharedMemory create 方法申请了一块匿名共享内存，SharedMemory create 方法中调用了 nCreate native 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> FileDescriptor <span class="title">nCreate</span><span class="params">(String name, <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> ErrnoException</span>;</span><br></pre></td></tr></table></figure></p><p>对应的 native 实现在 android_os_SharedMemory.cpp 中，源码见 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_os_SharedMemory.cpp" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_os_SharedMemory.cpp</a> ，具体 native 实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> jobject SharedMemory_create(JNIEnv* env, jobject, jstring jname, jint size) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = jname ? env-&gt;GetStringUTFChars(jname, nullptr) : nullptr;</span><br><span class="line">    <span class="keyword">int</span> fd = ashmem_create_region(name, size); <span class="comment">//创建匿名共享内存</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> jniCreateFileDescriptor(env, fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ashmem_create_region 方法的对应实现在 ashmem-dev.cpp 中，源码见 <a href="http://androidxref.com/9.0.0_r3/xref/system/core/libcutils/ashmem-dev.cpp#ashmem_create_region" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/system/core/libcutils/ashmem-dev.cpp#ashmem_create_region</a> ，其中 ashmem_create_region 的后续调用链如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASHMEM_DEVICE <span class="meta-string">"/dev/ashmem"</span> <span class="comment">//Ashmem 设备驱动</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ashmem_create_region(<span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size)&#123;</span><br><span class="line">    <span class="keyword">int</span> ret, save_errno;</span><br><span class="line">    <span class="keyword">int</span> fd = __ashmem_open(); <span class="comment">//创建匿名共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[ASHMEM_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        strlcpy(buf, name, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        ret = TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_SET_NAME, buf)); <span class="comment">//设置 Ashmem 名字</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __ashmem_open()&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;__ashmem_lock);</span><br><span class="line">    fd = __ashmem_open_locked(); <span class="comment">//创建匿名共享内存</span></span><br><span class="line">    pthread_mutex_unlock(&amp;__ashmem_lock);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __ashmem_open_locked()&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> stat st;</span><br><span class="line">    <span class="keyword">int</span> fd = TEMP_FAILURE_RETRY(open(ASHMEM_DEVICE, O_RDWR | O_CLOEXEC)); <span class="comment">//创建匿名共享内存</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直到 __ashmem_open_locked 方法中调用到 open(ASHMEM_DEVICE, O_RDWR | O_CLOEXEC) 方法，终于是到 Ashmem 设备驱动函数了，对应于上面的 <strong>ashmem_open</strong> 函数。另外 <strong>ashmem_ioctl</strong> 函数也被调用到了，即 ioctl(fd, ASHMEM_SET_NAME, buf)。</p><p>通过上面的分析知道 Ashmem 驱动的 ashmem_open 函数是由 SharedMemory 的 create 方法触发一步一步调用到的，那 ashmem_mmap 驱动函数是怎么被调用到的呢？看 MemoryFile 的构造方法，只可能是通过 SharedMemory 的 mapReadWrite 方法触发，下面来分析这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.os.SharedMemory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ByteBuffer <span class="title">mapReadWrite</span><span class="params">()</span> <span class="keyword">throws</span> ErrnoException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map(OsConstants.PROT_READ | OsConstants.PROT_WRITE, <span class="number">0</span>, mSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ByteBuffer <span class="title">map</span><span class="params">(<span class="keyword">int</span> prot, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> ErrnoException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> address = Os.mmap(<span class="number">0</span>, length, prot, OsConstants.MAP_SHARED, mFileDescriptor, offset);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(length, address, mFileDescriptor, unmapper, readOnly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的是 mFileDescriptor，它是执行 SharedMemory create 方法申请匿名共享内存后，返回的文件描述符。SharedMemory 中直接调用了系统的通用 mmap 函数，并没有对应的 native 实现，那它最终真的能调用到 ashmem_mmap 函数吗？ 继续来跟踪 mmap 调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.system.Os.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mmap</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> byteCount, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, FileDescriptor fd, <span class="keyword">long</span> offset)</span> <span class="keyword">throws</span> ErrnoException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Libcore.os.mmap(address, byteCount, prot, flags, fd, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//libcore.io.Libcore.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Libcore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Libcore</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Os rawOs = <span class="keyword">new</span> Linux();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Os os = <span class="keyword">new</span> BlockGuardOs(rawOs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//libcore.io.Linux.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">mmap</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> byteCount, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, FileDescriptor fd, <span class="keyword">long</span> offset)</span> <span class="keyword">throws</span> ErrnoException</span>;</span><br></pre></td></tr></table></figure></p><p>Libcore 中使用 BlockGuardOs 对 Linux 进行了一层包装，但实际还是通过 Linux 来执行的，最后调用到 Linux 中的 native mmap 方法，native 中对应的实现是 mmap.cpp，源码见 <a href="http://androidxref.com/9.0.0_r3/xref/bionic/libc/bionic/mmap.cpp#mmap" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/bionic/libc/bionic/mmap.cpp#mmap</a> ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* mmap(<span class="keyword">void</span>* addr, size_t size, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, off_t offset) &#123;</span><br><span class="line">    <span class="keyword">return</span> mmap64(addr, size, prot, flags, fd, static_cast&lt;off64_t&gt;(offset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此为止，由 SharedMemory 的 mapReadWrite 方法调用到 native mmap 函数，传递的关键参数是文件描述符，后续它将这样调用到 ashmem_mmap：<br><strong>1.</strong>通过 fd 可以找到所属设备，也就是 Ashmem 设备<br><strong>2.</strong>调用 Ashmem 设备的 ashmem_mmap 驱动函数</p><p>这属于 mmap 函数的内部实现，调用链比较复杂就不再具体展开，关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(file)&#123;</span><br><span class="line">    ...</span><br><span class="line">    error = file-&gt;f_op-&gt;mmap(file,vma);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>file 代表文件或设备驱动，这里指的就是 Ashmem 设备，f_op 就是 Ashmem 设备驱动函数集，也就是上文提过的通过 misc_register 注册的 Ashmem 设备描述，至此便是 ashmem_mmap 驱动函数的调用过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者在原书中是这样描述的：本小节为读者完整地还原了操作系统虚拟地址的概念与转换原理，相信大家会在后续<strong> Android 各子系统的学习中受益匪浅</strong>。 这让我想到前几天看到的一个问题 “为什么要分析算法的时间复杂度和空间复杂度，是因为现在的计算机都是冯诺依曼结构吗？”，基于基础知识能有自己的理解和发散才是可贵的。</p><p>那本文涉及的知识点对上层建筑有什么帮助呢？比如学习了 Ashmem 后，再遇到跨进程传输大数据的问题，是不是更有底气了呢？比如学习了 Android 的 Low Memory Killer 机制原理后，才知道应用保活本质到底是在解决什么问题，相比只是知道从网上搜来的几个保活方案，是不是更加胸有成竹呢？比如在阅读本文涉及的源码时发现 mutex_lock 随处可见，是不是很庆幸自己掌握了本系列第一章中的 <strong>进程间同步机制</strong> 呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;操作系统内存管理基础&lt;ol&gt;
&lt;li&gt;虚拟内存&lt;/li&gt;
&lt;li&gt;内存分配与回收&lt;/li&gt;
&lt;li&gt;mmap&lt;/li&gt;
&lt;li&gt;Copy on Write&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Android 内存管理&lt;ol&gt;
&lt;li&gt;Low Memory Killer&lt;/li&gt;
&lt;li&gt;Ashmem 驱动&lt;/li&gt;
&lt;li&gt;MemoryFile 原理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="mmap" scheme="http://yhaowa.gitee.io/yhaowa/tags/mmap/"/>
    
      <category term="读书笔记" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="虚拟内存" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="COW" scheme="http://yhaowa.gitee.io/yhaowa/tags/COW/"/>
    
      <category term="LMK" scheme="http://yhaowa.gitee.io/yhaowa/tags/LMK/"/>
    
      <category term="Ashmem" scheme="http://yhaowa.gitee.io/yhaowa/tags/Ashmem/"/>
    
  </entry>
  
  <entry>
    <title>细读《深入理解 Android 内核设计思想》（一）进程间通信与同步机制</title>
    <link href="http://yhaowa.gitee.io/yhaowa/12a8b16b/"/>
    <id>http://yhaowa.gitee.io/yhaowa/12a8b16b/</id>
    <published>2020-03-31T16:50:13.000Z</published>
    <updated>2020-12-06T09:18:58.313Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>进程间通信的经典实现<ol><li>共享内存</li><li>管道</li><li>UNIX Domain Socket</li><li>Remote Procedure Calls</li></ol></li><li>同步机制的经典实现<ol><li>信号量</li><li>Mutex</li><li>管程</li><li>Linux Futex</li></ol></li><li>Android 中的进程间同步机制<ol><li>进程间同步 Mutex</li><li>条件判断 Condition</li><li>加解锁的自动化操作 Autolock</li><li>Mutex+Autolock+Condition 示例</li></ol></li><li>最后</li></ol></blockquote><a id="more"></a><p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em></p><h2 id="进程间通信的经典实现"><a href="#进程间通信的经典实现" class="headerlink" title="进程间通信的经典实现"></a>进程间通信的经典实现</h2><p>进程间通信（Inter-process communication，IPC）指运行在不同进程中的若干线程间的数据交换，可发生在同一台机器上，也可通过网络跨机器实现，以下几种因高效稳定的优点几乎被应用在所有操作系统中，分别是共享内存、管道、UNIX Domain Socket 和 RPC 。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是一种常用的进程间通信机制，不同进程可以直接共享访问同一块内存区域，避免了数据拷贝，速度较快。实现步骤：</p><ol><li><p>创建内存共享区<br>Linux 通过 shmget 方法创建与特定 key 关联的共享内存块：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回共享内存块的唯一 Id 标识</span></span><br><span class="line"><span class="keyword">int</span> shmget(key_t key, size_t size, <span class="keyword">int</span> shmflg);</span><br></pre></td></tr></table></figure></li><li><p>映射内存共享区<br>Linux 通过 shmat 方法将某内存块与当前进程某内存地址映射</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功返回指向共享存储段的指针　</span></span><br><span class="line"><span class="keyword">void</span> *shmat(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg);</span><br></pre></td></tr></table></figure></li><li><p>访问内存共享区<br>其他进程要访问一个已存在的内存共享区的话，可以通过 key 调用 shmget 获取到共享内存块 Id，然后调用 shmat 方法映射</p></li><li>进程间通信<br>当两个进程都实现对同一块内存共享区做映射后，就可以利用此内存共享区进行数据交换，但要自己实现同步机制</li><li><p>撤销内存映射<br>进程间通信结束后，各个进程需要撤销之前的映射，Linux 可以调用 shmdt 方法撤销映射：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功则返回 0，否则出错</span></span><br><span class="line"><span class="keyword">int</span> shmdt(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr);</span><br></pre></td></tr></table></figure></li><li><p>删除内存共享区<br>最后需要删除内存共享区，以便回收内存，Linux 可以调用 shctl 进行删除：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功则返回 0，否则出错，删除操作 cmd 需传 IPC_RMID</span></span><br><span class="line"><span class="keyword">int</span> shmctl(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf);</span><br></pre></td></tr></table></figure></li></ol><p>shmget 方法名言简意赅，share memory get ！其中 get 还有一层含义，为什么不叫 create 呢？之前如果创建过某一 key 的共享内存块，再次调用便直接返回该内存块，不会发生创建操作了。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道（Pipe）是操作系统中常见的一种进程间通信方式，一根管道有”读取”和”写入”两端，读、写操作和普通文件操作类似，并且是单向的。管道有容量限制，当写满时，写操作会被阻塞；为空时读操作会被阻塞。</p><p>Linux 通过 pipe 方法打开一个管道：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pipe_fd[0] 代表读端，pipe_fd[1] 代表写端，</span></span><br><span class="line"><span class="keyword">int</span> pipe(<span class="keyword">int</span> pipe_fd[<span class="number">2</span>], <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure></p><p>以上方式只能用于父子进程，因为只有一个进程中定义的 pipe_fd 文件描述符只有通过 fork 方式才能传给另一个进程继承获取到，也正是因为这个限制，Named Pipe 得以发展，改变了前者匿名管道的方式，可以在没有任何关系的两个进程间使用。</p><h3 id="UNIX-Domain-Socket"><a href="#UNIX-Domain-Socket" class="headerlink" title="UNIX Domain Socket"></a>UNIX Domain Socket</h3><p>UNIX Domain Socket（UDS）是专门针对单机内的进程间通信，也称 IPC Socket，与 Network Socket 使用方法基本一致，但实现原理区别很大：</p><ul><li>Network Socket 基于 TCP/IP 协议，通过 IP 地址或端口号进行跨进程通信</li><li>UDS 基于本机 socket 文件，不需要经过网络协议栈，不需要打包拆包、计算校验等</li></ul><p>Android 中使用最多的 IPC 是 Binder，其次就是 UDS。</p><h3 id="Remote-Procedure-Calls"><a href="#Remote-Procedure-Calls" class="headerlink" title="Remote Procedure Calls"></a>Remote Procedure Calls</h3><p>RPC 即远程过程调用（Remote Procedure Call），RPC 是指计算机 A 上的进程，调用另外一台计算机 B 上的进程，其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行，当值返回给 A 时，A 进程继续执行。调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。</p><p>Java RMI 就是一种 RPC 框架，指的是远程方法调用 (Remote Method Invocation)。它能够让一个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象的方法。</p><p>RPC 可以理解为一种编程模型，就像 IPC 一样，比如我们常说 Android AIDL 是一种 IPC 实现方式，也可以称为一种 RPC 方式。</p><h2 id="同步机制的经典实现"><a href="#同步机制的经典实现" class="headerlink" title="同步机制的经典实现"></a>同步机制的经典实现</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量与 PV 原语操作是一种广泛使用的实现进程/线程互斥与同步的有效方法，Semaphore S 信号量用于指示共享资源的可用数量。<br><strong>P 操作：</strong></p><ol><li>S = S - 1</li><li>然后判断若 S 大于等于 0，代表共享资源允许访问，进程继续执行</li><li>若 S 小于 0，代表共享资源被占用，需等待别人主动释放资源，该进程阻塞放入等待该信号量的队列中，等待被唤醒</li></ol><p><strong>V 操作：</strong></p><ol><li>S = S + 1</li><li>然后判断若 S 大于 0，代表没有正在等待访问该资源的进程，无需处理</li><li>若 S 小于等于 0，从该信号的等待队列中唤醒一个进程</li></ol><p>Java 中的信号量的实现类为 Semaphore，P、V 操作分别对应 acquire、release 方法。</p><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Mutex 即互斥锁，可以和信号量对比来理解，信号量可以使资源同时被多个线程访问，而互斥锁同时只能被一个线程访问，也就是说，互斥锁相当于一个只允许取值 0 或 1 的信号量。</p><p>Java 中 ReentrantLock 就是互斥锁的一种实现。</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>采用 Semaphore 机制的程序中 P、V 操作大量分散在程序中，代码易读性差，不易管理，容易发生死锁，所以引入了管程 Monitor。</p><p>管程把分散在各进程中的临界区集中起来进行管理，防止进程有意或无意的违法同步操作，便于用高级语言来书写程序，也便于程序正确性验证。</p><p>管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。</p><p>Java 中 synchronized 同步代码块就是 Monitor 的一种实现。</p><h3 id="Linux-Futex"><a href="#Linux-Futex" class="headerlink" title="Linux Futex"></a>Linux Futex</h3><p>Futex 全称 Fast Userspace muTexes，直译为<strong>快速用户空间互斥体</strong>，那他比普通的 Mutex 快在哪里呢？</p><p>Semaphore 等传统同步机制需要从用户态进入到内核态，通过一个提供了共享状态信息和原子操作的内核对象来完成同步。但大多数场景同步是无竞争的，不需要进入互斥区等待就可以直接获取到锁，但依然进行了内核态的切换操作，这造成了大量的性能开销。</p><p>Futex 通过 mmap 让进程间共享一段内存，当进程尝试进入互斥区或退出互斥区的时候，先查看共享内存中的 Futex 变量，如果没有竞争发生，则只修改 Futex 变量而不执行系统调用切换内核态。</p><p>Futex 的 Fast 就体现在对于大多数不存在竞争的情况，可以在用户态就完成锁的获取，而不需要进入内核态，从而提高了效率。</p><p>如果说 Semaphore 等传统同步机制是一种内核态同步机制，那 Futex 就是一种用户态和内核态混合的同步机制。</p><p>Futex 在 Android 中的一个重要应用场景是 ART 虚拟机，如果 Android 版本开启了 ART_USE_FUTEXES 宏，那 ART 虚拟机中的同步机制就会以 Futex 为基石来实现，省略后的关键代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art/runtime/base/mutex.cc</span></span><br><span class="line"><span class="keyword">void</span> Mutex::ExclusiveLock(Thread* <span class="keyword">self</span>)&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> ART_USE_FUTEXES</span></span><br><span class="line">        <span class="comment">//若开启 Futex 宏就通过 Futex 实现互斥加锁</span></span><br><span class="line">        futex(...) </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">//否则通过传统 pthread 实现</span></span><br><span class="line">        CHECK_MUTEX_CALL(pthread_mutex_lock,(&amp;mutex_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码见 <a href="http://androidxref.com/7.0.0_r1/xref/art/runtime/base/mutex.cc" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/art/runtime/base/mutex.cc</a></p><h2 id="Android-中的进程间同步机制"><a href="#Android-中的进程间同步机制" class="headerlink" title="Android 中的进程间同步机制"></a>Android 中的进程间同步机制</h2><p>了解了操作系统经典的同步机制后，再来看 Android 中是怎么实现的。</p><h3 id="进程间同步-Mutex"><a href="#进程间同步-Mutex" class="headerlink" title="进程间同步 Mutex"></a>进程间同步 Mutex</h3><p>Mutex 实现类源码很短，见 <a href="http://androidxref.com/7.0.0_r1/xref/system/core/include/utils/Mutex.h" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/system/core/include/utils/Mutex.h</a></p><p>注意这里说的 Mutex 和上面的 mutex.cc 是两个东西，mutex.cc 是 ART 中的实现类，支持 Futex 方式； 而 Mutex.h 只是对 pthread 的 API 进行了简单封装，函数声明和实现都在 Mutex.h 一个文件中。</p><p>源码中可以看到一个枚举类型定义：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Mutex &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        PRIVATE = <span class="number">0</span>,</span><br><span class="line">        SHARED = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>其中 PRIVATE 代表进程内同步，SHARED 代表进程间同步。Mutex 相比 Semaphore 较简单，只有 0 和 1 两种状态，关键方法为：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> status_t Mutex::lock() &#123;<span class="comment">//获取资源锁，可能阻塞等待</span></span><br><span class="line">    <span class="keyword">return</span> -pthread_mutex_lock(&amp;mMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Mutex::unlock() &#123;<span class="comment">//释放资源锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> status_t Mutex::tryLock() &#123;<span class="comment">//获取资源锁，不论成功与否都立即返回</span></span><br><span class="line">    <span class="keyword">return</span> -pthread_mutex_trylock(&amp;mMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当要访问临界资源时，需先通过 lock() 获得资源锁，如果资源可用会此函数会立即返回，否则阻塞等待，直到其他进程(线程)调用 unlock() 释放了资源锁从而被唤醒。</p><p>tryLock() 函数存在有什么意义呢？它在资源被占用的情况下，不会像 lock() 一样进入等待，而是立即返回，所以可以用来试探性查询资源锁是否被占用。</p><h3 id="加解锁的自动化操作-Autolock"><a href="#加解锁的自动化操作-Autolock" class="headerlink" title="加解锁的自动化操作 Autolock"></a>加解锁的自动化操作 Autolock</h3><p>Autolock 为 Mutex.h 中的一个嵌套类，实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manages the mutex automatically. It'll be locked when Autolock is</span></span><br><span class="line"><span class="comment">// constructed and released when Autolock goes out of scope.</span></span><br><span class="line"><span class="keyword">class</span> Autolock &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">inline</span> Autolock(Mutex&amp; mutex) : mLock(mutex)  &#123; mLock.lock(); &#125;</span><br><span class="line">    <span class="keyword">inline</span> Autolock(Mutex* mutex) : mLock(*mutex) &#123; mLock.lock(); &#125;</span><br><span class="line">    <span class="keyword">inline</span> ~Autolock() &#123; mLock.unlock(); &#125;</span><br><span class="line">private:</span><br><span class="line">    Mutex&amp; mLock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如注释所示，Autolock 会在构造时主动去获取锁，在析构时会自动释放掉锁，也就是说，在生命周期结束时会自动把资源锁释放掉。</p><p>这就可以在一个方法开始时为某 Mutex 构造一个 Autolock，当方法执行完后此锁会自动释放，无需再主动调用 unlock，这让 lock/unlock 的配套使用更加简便，不易出错，</p><h3 id="条件判断-Condition"><a href="#条件判断-Condition" class="headerlink" title="条件判断 Condition"></a>条件判断 Condition</h3><p>条件判断的核心思想是判断某 “条件” 是否满足，满足的话马上返回，否则阻塞等待，直到条件满足时被唤醒。</p><p>你可能会疑问，Mutex 不就可以实现吗，干嘛又来一个 Condition，它有什么特别之处？</p><p>Mutex 确实可以实现基于条件判断的同步，假如条件是 a 为 0，实现代码会是这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  acquire_mutex_lock(a); <span class="comment">//获取 a 的互斥锁</span></span><br><span class="line">  <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">    release_mutex_lock(a); <span class="comment">//释放锁</span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//条件满足，退出死循环</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    release_mutex_lock(a); <span class="comment">//释放锁</span></span><br><span class="line">    sleep()；<span class="comment">//休眠一段时间后继续循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>什么时候满足 a==0 是未知的，可能是很久之后，但上面方式无限循环去判断条件，极大浪费 CPU。</p><p>而条件判断不需要死循环，可以在满足条件时才去通知唤醒等待者。</p><p>Condition 源码见 <a href="http://androidxref.com/7.0.0_r1/xref/system/core/include/utils/Condition.h" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/system/core/include/utils/Condition.h</a> ，它和 Mutex 一样也有 PRIVATE、SHARED 类型，PRIVATE 代表进程内同步，SHARED 为进程间同步。关键方法为：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某个条件上等待</span></span><br><span class="line">status_t wait(Mutex&amp; mutex)</span><br><span class="line"><span class="comment">//在某个条件上等待，增加超时机制</span></span><br><span class="line">status_t waitRelative(Mutex&amp; mutex, nsecs_t reltime)</span><br><span class="line"><span class="comment">//条件满足时通知相应等待者</span></span><br><span class="line"><span class="keyword">void</span> signal()</span><br><span class="line"><span class="comment">//条件满足时通知所有等待者</span></span><br><span class="line"><span class="keyword">void</span> broadcast()</span><br></pre></td></tr></table></figure></p><h3 id="Mutex-Autolock-Condition-示例"><a href="#Mutex-Autolock-Condition-示例" class="headerlink" title="Mutex+Autolock+Condition 示例"></a>Mutex+Autolock+Condition 示例</h3><p>书中通过 Barrier 呈现 Condition 使用示例，还有一个我们更为熟知的 LinkedBlockingQueue 也很适合，源码见 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/av/media/libstagefright/webm/LinkedBlockingQueue.h。" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/frameworks/av/media/libstagefright/webm/LinkedBlockingQueue.h。</a></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedBlockingQueue &#123;</span><br><span class="line">    List&lt;T&gt; mList;</span><br><span class="line">    Mutex mLock;</span><br><span class="line">    Condition mContentAvailableCondition;</span><br><span class="line"></span><br><span class="line">    T front(<span class="keyword">bool</span> remove) &#123;</span><br><span class="line">        Mutex::Autolock autolock(mLock);</span><br><span class="line">        <span class="keyword">while</span> (mList.empty()) &#123;</span><br><span class="line">            mContentAvailableCondition.wait(mLock);</span><br><span class="line">        &#125;</span><br><span class="line">        T e = *(mList.begin());</span><br><span class="line">        <span class="keyword">if</span> (remove) &#123;</span><br><span class="line">            mList.erase(mList.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> push(T e) &#123;</span><br><span class="line">        Mutex::Autolock autolock(mLock);</span><br><span class="line">        mList.push_back(e);</span><br><span class="line">        mContentAvailableCondition.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 front 方法出队元素时，首先获取 mLock 锁，然后判断若列表为空就调用 wait 方法进入等待状态，待 push 方法入队元素后通过 signal 方法唤醒。</p><p>front 方法占有了 mLock 锁，push 方法不应该阻塞在第一行代码无法往下执行吗？</p><p>很简单，wait 方法中释放了 mLock 锁，见 pthread_cond.cpp：<a href="http://androidxref.com/7.0.0_r1/xref/bionic/libc/bionic/pthread_cond.cpp#173" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/bionic/libc/bionic/pthread_cond.cpp#173</a></p><p>可以不依赖 Mutex 仅通过 Condition 的 wait/signal 实现吗？</p><p>不行，因为对 mList 的访问需要加互斥锁，否则可能出现 signal 无效的情况。比如 A 进程调用 front ，判断 mList 为空，即将执行 wait 方法时，B 进程调用 push 方法并执行完，那么 A 进程将得不到唤醒，尽管此队列中有元素。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>书中说到：不论什么样的操作系统，其技术本质都类似，而更多的是把这些核心的理论应用到符合自己需求的场景中。</p><p>不知道在讲这句话时，作者脑中一闪而过的，是怎样庞大而深厚的技术栈。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;进程间通信的经典实现&lt;ol&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;UNIX Domain Socket&lt;/li&gt;
&lt;li&gt;Remote Procedure Calls&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;同步机制的经典实现&lt;ol&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;Mutex&lt;/li&gt;
&lt;li&gt;管程&lt;/li&gt;
&lt;li&gt;Linux Futex&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Android 中的进程间同步机制&lt;ol&gt;
&lt;li&gt;进程间同步 Mutex&lt;/li&gt;
&lt;li&gt;条件判断 Condition&lt;/li&gt;
&lt;li&gt;加解锁的自动化操作 Autolock&lt;/li&gt;
&lt;li&gt;Mutex+Autolock+Condition 示例&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="Linux IPC" scheme="http://yhaowa.gitee.io/yhaowa/tags/Linux-IPC/"/>
    
      <category term="Mutex" scheme="http://yhaowa.gitee.io/yhaowa/tags/Mutex/"/>
    
      <category term="Autolock" scheme="http://yhaowa.gitee.io/yhaowa/tags/Autolock/"/>
    
      <category term="读书笔记" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Framework &amp; startActivity</title>
    <link href="http://yhaowa.gitee.io/yhaowa/a608ff50/"/>
    <id>http://yhaowa.gitee.io/yhaowa/a608ff50/</id>
    <published>2019-09-15T11:42:33.000Z</published>
    <updated>2020-12-06T09:28:19.378Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>理解 Instrumentation</li><li>IPC 发生在何处？</li><li>Activity 栈是如何管理的？</li><li>何处读取 manifest 中 Activity 节点的启动模式等配置</li><li>何处检测 Activity 是否在 manifest 注册？</li><li>为什么单独配置 taskAffinity 不会生效</li><li>理解 ClientTransactionItem 与 ActivityLifecycleItem</li><li>为什么不能在 Activity 的 onPause 方法中做耗时操作？</li><li>activity 实例在何处创建？</li><li>Launcher 中点击图标启动 App</li><li>理解 ActivityThread 与 ApplicationThread</li><li>如何启动一个未在 manifest 中注册的 Activity ？</li></ol></blockquote><a id="more"></a><p>源码基于 <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:" target="_blank" rel="noopener">Android 10</a></p><p><img src="../img/startActivity-Android10.jpg" alt="Android 10.0 startActivity 流程图"><br><a href="../img/startActivity-Android10.jpg">大图</a></p><p>此图着重提炼了生命周期的部分，Android 10 中 新增了 ActivityTaskManager ，专门用于管理 Activity，接替了 ActivityManager 的一部分工作</p><h3 id="1-理解-Instrumentation"><a href="#1-理解-Instrumentation" class="headerlink" title="1. 理解 Instrumentation"></a>1. 理解 Instrumentation</h3><p>Activity 首先会通过 Instrumentation 去调用，Instrumentation 中包含 callActivityOnCreate、callActivityOnPause、callApplicationOnCreate 等调用，具有强大的跟踪 Activity 及 Application 生命周期的功能，所以也被作为应用测试框架中的基类使用。一个进程有一个 ActivityThread 对象，ActivityThread 对象持有一个 Instrumentation 对象，每个 Activity 都持有 Instrumentation</p><h3 id="2-IPC-发生在何处？"><a href="#2-IPC-发生在何处？" class="headerlink" title="2. IPC 发生在何处？"></a>2. IPC 发生在何处？</h3><p>在 Instrumentation 中通过 IActivityTaskManager.aidl 接口由 App 进程进入到 system_server 进程；在 ClientTransaction 中通过 IApplicationThread.aidl 接口由 system_server 回到 App 进程</p><h3 id="3-Activity-栈是如何管理的？"><a href="#3-Activity-栈是如何管理的？" class="headerlink" title="3. Activity 栈是如何管理的？"></a>3. Activity 栈是如何管理的？</h3><p>ActivityRecord：Activity 以 ActivityRecord 形式记录，一个 ActivityRecord 对应一个 Activity 实例<br>TaskRecord：这个才是一个真正的 Activity 栈，内部持有 ArrayList&lt; ActivityRecord &gt;，记录当前栈中所有的 Activity<br>ActivityStack：负责管理 Activity 栈，存放了多个 TaskRecord</p><h3 id="4-何处读取-manifest-中-Activity-节点的启动模式等配置"><a href="#4-何处读取-manifest-中-Activity-节点的启动模式等配置" class="headerlink" title="4. 何处读取 manifest 中 Activity 节点的启动模式等配置"></a>4. 何处读取 manifest 中 Activity 节点的启动模式等配置</h3><p><img src="../img/startActivity-Android10-2.jpg" alt="读取 manifest 配置图"></p><p>如图通过 PackageManagerService#resolveIntentInternal 方法返回 ResolveInfo ，ResolveInfo 包括 ActivityInfo、ServiceInfo、ProviderInfo 等信息，此调用已经处于 system_server 进程了，所以并不是 IPC，PackageManagerService 主要负责解析 AndroidManifest.xml、扫描本地 apk 目录、管理 App 安装删除等</p><h3 id="5-何处检测-Activity-是否在-manifest-注册？"><a href="#5-何处检测-Activity-是否在-manifest-注册？" class="headerlink" title="5. 何处检测 Activity 是否在 manifest 注册？"></a>5. 何处检测 Activity 是否在 manifest 注册？</h3><p>关键代码在 ActivityStarter#startActivity 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">    <span class="comment">// Also the end of the line.</span></span><br><span class="line">    err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>aInfo 就是 ActivityInfo ，而 ActivityInfo 为空导致后续报错返回。那 aInfo 是从哪来的呢？当然就是通过 PackageManagerService#resolveIntentInternal 方法解析出来的。然后在 Instrumentation#checkStartActivityResult 方法中检测到 ActivityManager.START_CLASS_NOT_FOUND 返回值后，就抛出 “Unable to find explicit activity class {xxx}; have you declared this activity in your AndroidManifest.xml? “异常了 </p><h3 id="6-为什么单独配置-taskAffinity-不会生效"><a href="#6-为什么单独配置-taskAffinity-不会生效" class="headerlink" title="6. 为什么单独配置 taskAffinity 不会生效"></a>6. 为什么单独配置 taskAffinity 不会生效</h3><p>关键代码在 ActivityStarter#startActivityUnchecked 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mStartActivity.resultTo == <span class="keyword">null</span> &amp;&amp; mInTask == <span class="keyword">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">              &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">       newTask = <span class="keyword">true</span>;</span><br><span class="line">       result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">       result = setTaskFromSourceRecord();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">       result = setTaskFromInTask();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       result = setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只有 mLaunchFlags 标记为 FLAG_ACTIVITY_NEW_TASK 才会去创建一个新的 Activity 栈即 TaskRecord，而系统并没有对单独配置一个 taskAffinity 的情况做处理。那在 AndroidManifest.xml 中配置的 launchMode 是在何处处理，并反应到 mLaunchFlags 中的呢？<br>ActivityStarter#startActivityUnchecked 方法中调用了 ActivityStarter#computeLaunchingTaskFlags 方法，该方法中配置 mLaunchFlags 的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span> &amp;&amp; mInTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Slog.w(TAG, <span class="string">"startActivity called from non-Activity context; forcing "</span> +</span><br><span class="line">                     <span class="string">"Intent.FLAG_ACTIVITY_NEW_TASK for: "</span> + mIntent);</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">      mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 LAUNCH_SINGLE_INSTANCE 模式会在一个新的栈中启动等我们早已熟知的规则</p><h3 id="7-理解-ClientTransactionItem-与-ActivityLifecycleItem"><a href="#7-理解-ClientTransactionItem-与-ActivityLifecycleItem" class="headerlink" title="7. 理解 ClientTransactionItem 与 ActivityLifecycleItem"></a>7. 理解 ClientTransactionItem 与 ActivityLifecycleItem</h3><p>ClientLifecycleManager 可以将一或多个生命周期事件组合到一起作为一个事务即 ClientTransaction 来执行，startActivity 时新 Activity 的 onCreate、onStart、onResume 事件就是存放在一个事务中被执行的</p><p>startActivity 时新 Activity 的 onCreate 事件存放在 ClientTransaction 的 List &lt; ClientTransactionItem &gt; 类型的成员变量中，载体为 LaunchActivityItem。 LaunchActivityItem 也是 ClientTransactionItem 的子类，即启动 Activity 事件。另外还有 NewIntentItem（触发 onNewIntent 回调）、ActivityResultItem（触发 onActivityResult）、ConfigurationChangeItem（触发 onConfigurationChanged 回调）等事件</p><p>startActivity 时新 Activity 的 onResume 事件存放在 ClientTransaction 的 ActivityLifecycleItem 类型的变量成员变量中，这个变量也表示最终的生命周期状态，载体为 ResumeActivityItem。ActivityLifecycleItem 也是 ClientTransactionItem 的一个子类</p><h3 id="8-为什么不能在-Activity-的-onPause-方法中做耗时操作？"><a href="#8-为什么不能在-Activity-的-onPause-方法中做耗时操作？" class="headerlink" title="8. 为什么不能在 Activity 的 onPause 方法中做耗时操作？"></a>8. 为什么不能在 Activity 的 onPause 方法中做耗时操作？</h3><p>ClientTransaction 为 Parcelable 数据，会通过 IApplicationThread.aidl 的 scheduleTransaction 方法发送到 App 端，然后加入到主线程 ActivityThread.H 消息队列中等待执行。startActivity 时会依次发送前一个 Activity 的 pause 和新 Activity 的 resume 事务，然后这两个事务会通过 ActivityThread.H 依次执行，所以不能在 Activity 的 onPause 方法中做耗时操作，因为只有 onPause 方法执行完后，下一个 Activity 的生命周期事件才能被执行，否则会阻塞新界面显示</p><h3 id="9-activity-实例在何处创建？"><a href="#9-activity-实例在何处创建？" class="headerlink" title="9. activity 实例在何处创建？"></a>9. activity 实例在何处创建？</h3><p>在 ActivityThread#performLaunchActivity 方法中，会通过 Instrumentation#newActivity 方法创建 Activity 的实例对象，随后就调用了 Instrumentation#callActivityOnCreate 方法回调 Activity 的 onCreate 方法</p><h3 id="10-Launcher-中点击图标启动-App"><a href="#10-Launcher-中点击图标启动-App" class="headerlink" title="10. Launcher 中点击图标启动 App"></a>10. Launcher 中点击图标启动 App</h3><p>Launcher 中点击图标启动同样是调用 startActivity 方法，但需要创建进程，关键代码在 ActivityStackSupervisor#startSpecificActivityLocked 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowProcessController wpc =</span><br><span class="line">        mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"><span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">     <span class="comment">//判断进程存在，继续启动</span></span><br><span class="line">     realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程不存在，创建进程</span></span><br><span class="line"><span class="keyword">final</span> Message msg = PooledLambda.obtainMessage(</span><br><span class="line">        ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,</span><br><span class="line">        r.info.applicationInfo, knownToBeDead, <span class="string">"activity"</span>, r.intent.getComponent());</span><br><span class="line">mService.mH.sendMessage(msg);</span><br></pre></td></tr></table></figure><p><img src="../img/startActivity-Android10-3.jpg" alt="startProcess 流程图"></p><p>与 zygote 进程通信采取了 Socket 方式，为什么不使用更安全、数据只需拷贝一次的 binder 呢？zygote 作为 Android 的受精卵进程，通过 fork 方法创建进程，而 fork 是不允许多线程的，否则会因为 Copy-on-Write 机制导致死锁，而 binder 正是基于多线程运行的</p><p>在 ProcessList#startProcessLocked 方法中，传入了值为 “android.app.ActivityThread” 的 entryPoint 参数，后续会透传给 zygote 进程，zygote fork 新进程成功后，新进程的 ActivityThread#main 函数会被调用，即 App 真正的启动入口</p><p><img src="../img/startActivity-Android10-4.jpg" alt="ActivityThread.main 流程图"><br><a href="../img/startActivity-Android10-4.jpg">大图</a></p><p>在 ActivityManagerService#attachApplicationLocked 方法中执行了两个关键逻辑，一是通过 IApplicationThread 回到 App 进程中创建 Application 实例并回调 onCreate 方法；二是调用 ActivityTaskManagerService#attachApplication 方法，进一步去启动首页 Activity 。<br>启动 Activity 和普通的 startActivity 一样，都会调用到 ActivityStackSupervisor#realStartActivityLocked 方法</p><h3 id="11-理解-ActivityThread-与-ApplicationThread"><a href="#11-理解-ActivityThread-与-ApplicationThread" class="headerlink" title="11. 理解 ActivityThread 与 ApplicationThread"></a>11. 理解 ActivityThread 与 ApplicationThread</h3><p>ActivityThread.main() 方法是程序的启动入口，初始化了主线程 Looper，在 ActivityThread.H 中处理消息。ApplicationThread 是 ActivityThread 的内部类，实现了 IApplicationThread.aidl 接口以接受 AMS 等系统服务的回调，而大多数都是四大组件相关的任务，所以发送 Handler 消息到 ActivityThread.H ，即从 binder 线程切换到主线程中处理</p><h3 id="12-如何启动一个未在-manifest-中注册的-Activity-？"><a href="#12-如何启动一个未在-manifest-中注册的-Activity-？" class="headerlink" title="12. 如何启动一个未在 manifest 中注册的 Activity ？"></a>12. 如何启动一个未在 manifest 中注册的 Activity ？</h3><p>加载 manifest 信息及检测注册在 system_server 进程，即无法干扰检测逻辑。常见做法是在 manifest 中注册一个占位 Activity，在进入 system_server 进程之前把未注册的 Activity 修改为占位 Activity，然后等从 system_server 返回到 App 进程后再修改回未注册的 Activity，然后去创建、启动，也就是说需 hook 两处：</p><p>hook ActivityTaskManager：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Field singletonField = ActivityTaskManager<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">             .getDeclaredField("IActivityTaskManagerSingleton");</span><br><span class="line">singletonField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton singleton = (Singleton) singletonField.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">final</span> Object activityTaskManagerObject = singleton.get();</span><br><span class="line">final Field mInstanceField = Singleton.class.getDeclaredField("mInstance");</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object value = Proxy.newProxyInstance(ActivityTaskManager<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span></span><br><span class="line">     , new Class[]&#123;Class.forName("android.app.IActivityTaskManager")&#125;</span><br><span class="line">     , <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">                  Intent raw;</span><br><span class="line">                  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">                        index = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (!(args[index] <span class="keyword">instanceof</span> Intent)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">                  raw = (Intent) args[index];</span><br><span class="line">                  <span class="keyword">if</span> (raw.getComponent().getClassName()</span><br><span class="line">                         .equals(<span class="string">"com.yinghao.test.UnRegisterActivity"</span>)) &#123;</span><br><span class="line">                      ntent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">                      <span class="comment">//将未注册的 UnRegisterActivity 替换为占位 FakeActivity</span></span><br><span class="line">                      newIntent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.yinghao.test"</span>, </span><br><span class="line">                                   FakeActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">                      <span class="comment">//记录 UnRegisterActivity</span></span><br><span class="line">                      newIntent.putExtra(EXTRA_TARGET_INTENT, raw); </span><br><span class="line">                      args[index] = newIntent;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(activityTaskManagerObject, args);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mInstanceField.set(singleton, value);</span><br></pre></td></tr></table></figure></p><p>hook ActivityThread：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread activityThread = ActivityThread.currentActivityThread();</span><br><span class="line">Field mH1 = activityThread.getClass().getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mH1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">final</span> Handler mH = (Handler) mH1.get(activityThread);</span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField("mCallback");</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (msg.what == <span class="number">159</span>) &#123; <span class="comment">// ActivityThread.H.EXECUTE_TRANSACTION</span></span><br><span class="line">    <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">    Field mActivityCallbacksField = transaction</span><br><span class="line">               .getClass().getDeclaredField(<span class="string">"mActivityCallbacks"</span>);</span><br><span class="line">    mActivityCallbacksField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    List&lt;ClientTransactionItem&gt; clientTransactionItems = </span><br><span class="line">        (List&lt;ClientTransactionItem&gt;) mActivityCallbacksField.get(transaction);</span><br><span class="line">    <span class="keyword">if</span> (clientTransactionItems != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (ClientTransactionItem c : clientTransactionItems) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c <span class="keyword">instanceof</span> LaunchActivityItem) &#123;</span><br><span class="line">       <span class="comment">//修正 Activity 启动事件实体 LaunchActivityItem</span></span><br><span class="line">       LaunchActivityItem item = (LaunchActivityItem) c;</span><br><span class="line">       Field intentField = item.getClass().getDeclaredField(<span class="string">"mIntent"</span>);</span><br><span class="line">       intentField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Intent intent = (Intent) intentField.get(item);</span><br><span class="line">       Field mInfoField = item.getClass().getDeclaredField(<span class="string">"mInfo"</span>);</span><br><span class="line">       mInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       ActivityInfo aInfo = (ActivityInfo) mInfoField.get(item);</span><br><span class="line">       Intent realIntent = intent.getParcelableExtra(EXTRA_TARGET_INTENT);</span><br><span class="line">       <span class="keyword">if</span> (realIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//将占位 FakeActivity 改回未注册的 UnRegisterActivity</span></span><br><span class="line">         intent.setComponent(realIntent.getComponent());</span><br><span class="line">         aInfo.packageName = realIntent.getComponent().getPackageName();</span><br><span class="line">         aInfo.name = realIntent.getComponent().getClassName();</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//返回 false 正好可以让 ActivityThread 继续处理</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>实现启动未注册 Activity 的前提必然是已掌握 startActivity 流程，这也是插件化的入门，实际应用需要去兼容各个 Android 版本</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>带着问题去分析、学习源码，自然的就会聚焦出一条主线</p><div style="display: none"><br>participant Activity<br>participant Instrumentation<br>participant ActivityTaskManager<br>participant IActivityTaskManager<br>Note over IActivityTaskManager:AIDL<br>participant ActivityTaskManagerService<br>participant ActivityStartController<br>participant ActivityStarter<br>participant RootActivityContainer<br>participant ActivityStack<br>participant ActivityStackSupervisor<br>participant ClientLifecycleManager<br>participant ClientTransaction<br>participant IApplicationThread<br>Note over IApplicationThread:AIDL<br>participant ApplicationThread<br>participant ActivityThread<br>participant ActivityThread.H<br>participant TransactionExecutor<br>participant PauseActivityItem<br>participant LaunchActivityItem<br>participant ResumeActivityItem<br>Activity-&gt; Instrumentation:startActivityAsUser()<br>Instrumentation-&gt; ActivityTaskManager:execStartActivity()<br>ActivityTaskManager-&gt; IActivityTaskManager:startActivity()<br><br>IActivityTaskManager-&gt; ActivityTaskManagerService:startActivity()<br>ActivityTaskManagerService-&gt; ActivityStartController:getActivityStartController()<br>ActivityStartController-&gt; ActivityStarter:obtainStarter()<br>ActivityStarter-&gt; ActivityStarter:startActivityMayWait()<br>ActivityStarter-&gt; ActivityStarter:startActivity()<br>ActivityStarter-&gt;RootActivityContainer:startActivityUnchecked()<br>RootActivityContainer-&gt;ActivityStack:resumeFocusedStacksTopActivities()<br>ActivityStack-&gt;ActivityStack: resumeTopActivityUncheckedLocked()<br>ActivityStack–&gt;ClientLifecycleManager:startPausingLocked()<br>ClientLifecycleManager-&gt;ClientTransaction:scheduleTransaction(PauseActivityItem)<br>ClientTransaction-&gt;IApplicationThread:schedule()<br>IApplicationThread-&gt;ApplicationThread:scheduleTransaction()<br>ApplicationThread-&gt;ActivityThread:scheduleTransaction()<br>ActivityThread-&gt;ActivityThread.H:sendMessage(EXECUTE_TRANSACTION)<br>ActivityStack-&gt;ActivityStackSupervisor:resumeTopActivityInnerLocked()<br>ActivityStackSupervisor-&gt;ActivityStackSupervisor:startSpecificActivityLocked()<br>ActivityStackSupervisor-&gt;ClientLifecycleManager:realStartActivityLocked()<br>ClientLifecycleManager-&gt;ClientTransaction:scheduleTransaction(ResumeActivityItem)<br>ClientTransaction-&gt;IApplicationThread:schedule()<br>IApplicationThread-&gt;ApplicationThread:scheduleTransaction()<br>ApplicationThread-&gt;ActivityThread:scheduleTransaction()<br>ActivityThread-&gt;ActivityThread.H:sendMessage(EXECUTE_TRANSACTION)<br><br>ActivityThread.H-&gt;TransactionExecutor:handleMessage()<br>TransactionExecutor-&gt;TransactionExecutor:execute()<br>TransactionExecutor-&gt;PauseActivityItem:executeLifecycleState()<br>PauseActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handlePauseActivity()<br>ActivityThread-&gt;ActivityThread:performPauseActivity()<br>ActivityThread–&gt;Instrumentation:performPauseActivityIfNeeded()<br>Instrumentation-&gt;Activity:callActivityOnPause()<br>Activity-&gt;Activity:performPause()<br>Activity-&gt;Activity:onPause()<br><br>ActivityThread.H-&gt;TransactionExecutor:handleMessage()<br>TransactionExecutor-&gt;TransactionExecutor:execute()<br>TransactionExecutor–&gt;LaunchActivityItem:executeCallbacks()<br>LaunchActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handleLaunchActivity()<br>ActivityThread–&gt;Instrumentation:performLaunchActivity()<br>Instrumentation-&gt;Activity:callActivityOnCreate()<br>Activity-&gt;Activity:performCreate()<br>Activity-&gt;Activity:onCreate()<br><br>TransactionExecutor–&gt;ResumeActivityItem:executeLifecycleState()<br>ResumeActivityItem–&gt;ActivityThread:execute()<br>ActivityThread-&gt;ActivityThread:handleResumeActivity()<br>ActivityThread–&gt;Activity:performResumeActivity()<br>Activity-&gt;Instrumentation:performResume()<br>Instrumentation-&gt;Activity:callActivityOnResume()<br>Activity-&gt;Activity:onResume()<br></div><div style="display: none"><br><div id="sequence-0"></div><br></div><div style="display: none"><br><div id="sequence-1"></div><br></div><div style="display: none"><br><br>ActivityThread-&gt;ActivityThread:Loop#prepareMainLooper()<br>ActivityThread–&gt;IActivityManager:attach()<br>Note over IActivityManager:AIDL<br>IActivityManager-&gt;ActivityManagerService:attachApplication()<br>ActivityManagerService-&gt;IApplicationThread:attachApplicationLocked()<br>Note over IApplicationThread:AIDL<br>IApplicationThread-&gt;ApplicationThread:bindApplication()<br>ApplicationThread-&gt;ActivityThread.H:sendMessage(BIND_APPLICATION)<br><br>ActivityManagerService–&gt;ActivityTaskManagerService.LocalService:attachApplicationLocked()<br>ActivityTaskManagerService.LocalService-&gt;RootActivityContainer:attachApplication()<br>RootActivityContainer-&gt;ActivityStackSupervisor:attachApplication()<br>ActivityStackSupervisor-&gt;ClientLifecycleManager:realStartActivityLocked()<br>ClientLifecycleManager-&gt;ClientLifecycleManager:scheduleTransaction()<br><br>ActivityThread-&gt;ActivityThread:Looper#loop()<br><br>ActivityThread.H–&gt;ActivityThread:handleMessage(BIND_APPLICATION)<br>ActivityThread–&gt;LoadedApk:handleBindApplication()<br>LoadedApk-&gt;Instrumentation:makeApplication()<br>Instrumentation-&gt;CoreComponentFactory:newApplication()<br>CoreComponentFactory-&gt;CoreComponentFactory:instantiateApplication()<br>Instrumentation–&gt;Application:callApplicationOnCreate()<br>Application-&gt;Application:onCreate()<br><br></div><p><script src="https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.8/raphael.min.js"></script><script src="https://cdn.bootcss.com/snap.svg/0.5.1/snap.svg-min.js"></script><script src="https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js"></script><script src="https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">ActivityStarter->ActivityStackSupervisor:startActivityMayWait()ActivityStackSupervisor->ActivityTaskManagerService:resolveIntent()ActivityTaskManagerService->PackageManagerInternalImpl:getPackageManagerInternalLocked()PackageManagerInternalImpl->PackageManagerService:resolveIntent()PackageManagerService->PackageManagerService:resolveIntentInternal()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">ActivityStackSupervisor->ActivityManagerInternal(ActivityManagerService.LocalService):startSpecificActivityLocked()ActivityManagerInternal(ActivityManagerService.LocalService)->ActivityManagerService:startProcess()ActivityManagerService->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->ProcessList:startProcessLocked()ProcessList->Process:startProcess()Process->ZygoteProcess:start()ZygoteProcess->ZygoteProcess:startViaZygote()ZygoteProcess->ZygoteProcess:openZygoteSocketIfNeeded()ZygoteProcess->ZygoteProcess:zygoteSendArgsAndGetResult()</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;理解 Instrumentation&lt;/li&gt;
&lt;li&gt;IPC 发生在何处？&lt;/li&gt;
&lt;li&gt;Activity 栈是如何管理的？&lt;/li&gt;
&lt;li&gt;何处读取 manifest 中 Activity 节点的启动模式等配置&lt;/li&gt;
&lt;li&gt;何处检测 Activity 是否在 manifest 注册？&lt;/li&gt;
&lt;li&gt;为什么单独配置 taskAffinity 不会生效&lt;/li&gt;
&lt;li&gt;理解 ClientTransactionItem 与 ActivityLifecycleItem&lt;/li&gt;
&lt;li&gt;为什么不能在 Activity 的 onPause 方法中做耗时操作？&lt;/li&gt;
&lt;li&gt;activity 实例在何处创建？&lt;/li&gt;
&lt;li&gt;Launcher 中点击图标启动 App&lt;/li&gt;
&lt;li&gt;理解 ActivityThread 与 ApplicationThread&lt;/li&gt;
&lt;li&gt;如何启动一个未在 manifest 中注册的 Activity ？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://yhaowa.gitee.io/yhaowa/categories/Framework/"/>
    
    
      <category term="ams" scheme="http://yhaowa.gitee.io/yhaowa/tags/ams/"/>
    
      <category term="startActivity" scheme="http://yhaowa.gitee.io/yhaowa/tags/startActivity/"/>
    
  </entry>
  
  <entry>
    <title>Android 集成 FFmpeg (四) 轻松实现一个音视频编辑 App</title>
    <link href="http://yhaowa.gitee.io/yhaowa/798144ac/"/>
    <id>http://yhaowa.gitee.io/yhaowa/798144ac/</id>
    <published>2019-06-16T12:07:18.000Z</published>
    <updated>2020-12-06T06:59:08.601Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看到一篇关于 FFmpeg 的文章，讲的大概是基于 FFmpeg 实现了一个 App，支持视频拼图等强大炫酷的音视频编辑功能，其原理是在 Android 端集成 FFmpeg，通过命令方式调用 FFmpeg。</p><p>尽管在 Android 端集成命令方式调用并不复杂，但一个具有强大炫酷音视频编辑功能的 App 是有价值的。由此启发，并决定敲下 Android 集成 FFmpeg 系列的第四篇，以一个实际应用的方式展现 FFmpeg 强大的音视频编辑功能。</p><a id="more"></a><p>应用截图：</p><p><img src="../img/19.jpg" alt></p><blockquote><p>源码：<a href="https://github.com/yhaolpz/FFmpegCmd" target="_blank" rel="noopener">https://github.com/yhaolpz/FFmpegCmd</a></p></blockquote><p>若想实现更多效果，见 <a href="http://ffmpeg.org/ffmpeg.html" target="_blank" rel="noopener">ffmpeg Documentation</a>，应用代码非常简单，这里就不再过多阐述，直接查看源码，一看即懂，理论知识及编译实现见前三篇：</p><blockquote><p><a href="https://yhaolpz.github.io/e0b4d9fc/" target="_blank" rel="noopener">Android 集成 FFmpeg (一) 基础知识及简单调用</a><br><a href="https://yhaolpz.github.io/ddeb5551/" target="_blank" rel="noopener">Android 集成 FFmpeg (二) 以命令方式调用 FFmpeg</a><br><a href="https://yhaolpz.github.io/8837781/" target="_blank" rel="noopener">Android 集成 FFmpeg (三) 获取 FFmpeg 执行进度</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看到一篇关于 FFmpeg 的文章，讲的大概是基于 FFmpeg 实现了一个 App，支持视频拼图等强大炫酷的音视频编辑功能，其原理是在 Android 端集成 FFmpeg，通过命令方式调用 FFmpeg。&lt;/p&gt;
&lt;p&gt;尽管在 Android 端集成命令方式调用并不复杂，但一个具有强大炫酷音视频编辑功能的 App 是有价值的。由此启发，并决定敲下 Android 集成 FFmpeg 系列的第四篇，以一个实际应用的方式展现 FFmpeg 强大的音视频编辑功能。&lt;/p&gt;
    
    </summary>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/yhaowa/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="FFmpeg" scheme="http://yhaowa.gitee.io/yhaowa/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES（二）绘制三角形</title>
    <link href="http://yhaowa.gitee.io/yhaowa/2296ca3/"/>
    <id>http://yhaowa.gitee.io/yhaowa/2296ca3/</id>
    <published>2019-06-16T08:39:50.000Z</published>
    <updated>2020-12-06T06:59:08.620Z</updated>
    
    <content type="html"><![CDATA[<p>通过上篇文章的学习，现在已经了解到，要想在 Android 端使用 OpenGL ES 绘制图形，必须创建 OpenGL ES 环境和视图窗口，具体来说就是构建 EGL 环境，即 OpenGL ES 和 Android 底层平台视窗系统之间的接口。另外 OpenGL ES 2.0 版本为可编程管线，我们就可以编写着色器程序来确定绘制内容，即编写 Vertex Shader 顶点着色器和 Fragment Shader 片元着色器。</p><p>而这些工作可以通过 GLSurfaceView 非常简单的实现。</p><a id="more"></a><p>在介绍 GLSurfaceView 之前先来看下 Android 系统提供的与 OpenGL ES 相关的包：</p><ul><li>javax.microedition.khronos.opengles： 存放 GL 绘图指令相关代码</li><li>javax.microedition.khronos.egl： 存放 EGL 管理相关代码，包括 Display、surface 等</li><li>android.opengl： 存放 GL 辅助类，连接 OpenGL 与 Android View，Activity 等</li></ul><p>其中 GLSurfaceView 处于 android.opengl 包中，GLSurfaceView 具有以下特性：</p><ul><li>内置 EGL 管理，自带 GL 上下文环境和 GLThread 绘制线程</li><li>起到连接 OpenGL ES 与 Android 的 View 层次结构之间的桥梁作用</li><li>使得 OpenGL ES 库适应于 Activity 生命周期</li><li>继承自 SurfaceView，拥有 SurfaceView 的全部特性，绘制结果会输出到 SurfaceView 所提供的 Surface 上</li><li>提供了方便使用的调试工具来跟踪 OpenGL ES 函数调用以帮助检查错误</li></ul><p>通过 GLSurfaceView 的 setRenderer 方法可设置要渲染的效果，即 GLSurfaceView.Renderer 渲染器接口，该接口方法：</p><ul><li>onSurfaceCreated：渲染线程开启时调用，可做初始化背景色、初始化纹理资源等工作</li><li>onSurfaceChanged：窗口尺寸改变时调用，通常会设置视窗范围或投影矩阵等</li><li>onDrawFrame：外部请求渲染一次就调用一次，可在此载入着色器程序、激活绑定纹理以及调用绘制</li></ul><p>下面来看具体如何绘制一个三角形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String vertexShaderResource =</span><br><span class="line">            <span class="string">"attribute vec3 vPosition;"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;"</span> +</span><br><span class="line">                    <span class="string">"  gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);"</span> +</span><br><span class="line">                    <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String fragmentShaderResource =</span><br><span class="line">            <span class="string">"precision mediump float;"</span> +</span><br><span class="line">                    <span class="string">"uniform vec4 vColor;"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;"</span> +</span><br><span class="line">                    <span class="string">"  gl_FragColor = vColor;"</span> +</span><br><span class="line">                    <span class="string">"&#125;"</span>;</span><br><span class="line">    <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] vertexCoords = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">            <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// top</span></span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom left</span></span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// bottom right</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> color[] = &#123;<span class="number">1.0f</span>, <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">1.0f</span>&#125;; <span class="comment">//red</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 着色器程序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mProgram;</span><br><span class="line">    <span class="comment">// 顶点坐标数据</span></span><br><span class="line">    <span class="keyword">private</span> FloatBuffer vertexFloatBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置清空屏幕后的背景色</span></span><br><span class="line">        GLES30.glClearColor(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">//构建顶点着色器</span></span><br><span class="line">        <span class="keyword">int</span> vertexShader = GLES30.glCreateShader(GLES30.GL_VERTEX_SHADER);</span><br><span class="line">        GLES30.glShaderSource(vertexShader, vertexShaderResource);</span><br><span class="line">        GLES30.glCompileShader(vertexShader);</span><br><span class="line">        <span class="comment">//构建片段着色器</span></span><br><span class="line">        <span class="keyword">int</span> fragmentShader = GLES30.glCreateShader(GLES30.GL_FRAGMENT_SHADER);</span><br><span class="line">        GLES30.glShaderSource(fragmentShader, fragmentShaderResource);</span><br><span class="line">        GLES30.glCompileShader(fragmentShader);</span><br><span class="line">        <span class="comment">//构建着色器程序，并将顶点着色器和片段着色器链接进来</span></span><br><span class="line">        mProgram = GLES30.glCreateProgram();</span><br><span class="line">        GLES30.glAttachShader(mProgram, vertexShader);</span><br><span class="line">        GLES30.glAttachShader(mProgram, fragmentShader);</span><br><span class="line">        GLES30.glLinkProgram(mProgram);</span><br><span class="line">        <span class="comment">//顶点着色器和片段着色器链接到着色器程序后就无用了</span></span><br><span class="line">        GLES30.glDeleteShader(vertexShader);</span><br><span class="line">        GLES30.glDeleteShader(fragmentShader);</span><br><span class="line">        <span class="comment">//转换为需要的顶点数据格式</span></span><br><span class="line">        vertexFloatBuffer = floatToBuffer(vertexCoords);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置视窗</span></span><br><span class="line">        GLES30.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//清空屏幕，擦除屏幕上所有的颜色，用 glClearColor 定义的颜色填充</span></span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">//在当前 EGL 环境激活着色器程序</span></span><br><span class="line">        GLES30.glUseProgram(mProgram);</span><br><span class="line">        <span class="comment">//获取顶点着色器的 vPosition 成员句柄</span></span><br><span class="line">        <span class="keyword">int</span> positionHandle = GLES30.glGetAttribLocation(mProgram, <span class="string">"vPosition"</span>);</span><br><span class="line">        <span class="comment">//启用句柄</span></span><br><span class="line">        GLES30.glEnableVertexAttribArray(positionHandle);</span><br><span class="line">        <span class="comment">//设置顶点坐标数据</span></span><br><span class="line">        GLES30.glVertexAttribPointer(positionHandle, <span class="number">3</span>, GLES30.GL_FLOAT,</span><br><span class="line">                <span class="keyword">false</span>, <span class="number">3</span> * <span class="number">4</span>, vertexFloatBuffer);</span><br><span class="line">        <span class="comment">//获取片元着色器的 vColor 成员句柄</span></span><br><span class="line">        <span class="keyword">int</span> colorHandle = GLES30.glGetUniformLocation(mProgram, <span class="string">"vColor"</span>);</span><br><span class="line">        <span class="comment">//设置颜色</span></span><br><span class="line">        GLES30.glUniform4fv(colorHandle, <span class="number">1</span>, color, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//绘制三角形</span></span><br><span class="line">        GLES30.glDrawArrays(GLES30.GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//禁止顶点数组的句柄</span></span><br><span class="line">        GLES30.glDisableVertexAttribArray(positionHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FloatBuffer <span class="title">floatToBuffer</span><span class="params">(<span class="keyword">float</span>[] a)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(a.length * <span class="number">4</span>); <span class="comment">//float占4个字节</span></span><br><span class="line">        buffer.order(ByteOrder.nativeOrder());</span><br><span class="line">        FloatBuffer byteBuffer = buffer.asFloatBuffer();</span><br><span class="line">        byteBuffer.put(a);</span><br><span class="line">        byteBuffer.position(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> byteBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h4><p>要绘制一个三角形，就要确定三个顶点的 3D 坐标（OpenGL 是一个 3D 图形库，在 OpenGL 中指定的所有坐标都需要是 3D 坐标，即 x、y 和 z）。而顶点坐标起始于局部坐标，需要为标准化设备坐标，即 x、y、z 的范围限定于 -1 到 1 之间，任何落在范围外的坐标都会被丢弃。上面代码中输入的顶点数据为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] vertexCoords = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里将 z 坐标都设置为 0，表示三角形每一点的深度都为 0（通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源），这样定义的顶点数据反应到标准化设备坐标系中就是这样的：</p><p><img src="../img/17.jpg" alt></p><h4 id="解释顶点数据"><a href="#解释顶点数据" class="headerlink" title="解释顶点数据"></a>解释顶点数据</h4><p>可以看到调用 glVertexAttribPointer 设置顶点数据时并不是直接把 float[] 数组传递进去，而是转换成 FloatBuffer 传入，所谓的解释顶点数据就是说明输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。对于 glVertexAttribPointer 函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glVertexAttribPointer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> indx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> normalized,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> stride,</span></span></span><br><span class="line"><span class="function"><span class="params">    java.nio.Buffer ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>indx：指定要配置的顶点属性，这里传入顶点着色器的 vPosition 成员句柄</li><li>size：指定顶点属性的大小，顶点属性是一个 vec3，它由 3 个值（x、y、z）组成，所以大小传入 3</li><li>type：指定数据的类型为 float 类型</li><li>normalized：是否希望数据被标准化</li><li>stride：指定连续的顶点数据之间的间隔，由于一个顶点数据长度为 3 个 float，所以把步长设置为 3 * 4（一个 float 占 4 个字节）</li><li>ptr：顶点数据</li></ul><p>下图很好的阐释这个逻辑：</p><p><img src="../img/18.jpg" alt></p><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String vertexShaderResource =</span><br><span class="line">    <span class="string">"attribute vec3 vPosition;"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;"</span> +</span><br><span class="line">        <span class="string">"  gl_Position = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><p>由于每个顶点都有一个 3D 坐标，这里就创建一个 vec3 变量输入顶点坐标。而内置变量 gl_Position 为 vec4 类型，所以需要将三维向量转换为四维向量，最后 gl_Position 设置的值会成为该顶点着色器的输出。</p><p>onDrawFrame 方法中在获取顶点着色器的 vPosition 成员句柄后，需要调用 glEnableVertexAttribArray、glDisableVertexAttribArray 分别启用、禁止顶点数据，而片段着色器的 vColor 成员句柄就不需要。这是因为出于性能考虑，所有顶点着色器的属性默认都是关闭的。<br>glVertexAttribPointer 只是建立 CPU 和 GPU 之间的逻辑连接实现将 CPU 数据上传至 GPU，但是，数据在 GPU 端是否可见，即着色器能否读取到数据，还要取决于 glEnableVertexAttribArray 方法。</p><h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String fragmentShaderResource =</span><br><span class="line"><span class="string">"precision mediump float;"</span> +</span><br><span class="line">        <span class="string">"uniform vec4 vColor;"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;"</span> +</span><br><span class="line">        <span class="string">"  gl_FragColor = vColor;"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><p>在 OpenGL 中定义一个颜色的数据格式为 RGBA 四个 0.0 到 1.0 之间强度的分量，片段着色器所做的是计算像素最后的颜色输出，也只有 gl_FragColor 这一个输出变量。</p><h4 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vertexShader = GLES30.glCreateShader(GLES30.GL_VERTEX_SHADER);</span><br><span class="line">GLES30.glShaderSource(vertexShader, vertexShaderResource);</span><br><span class="line">GLES30.glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p>为了让 OpenGL 能够使用我们编写的着色器源码，必须在运行时动态编译。首先通过 glCreateShader 创建一个着色器对象，返回该着色器的 ID，然后通过 glShaderSource、glCompileShader 方法将源码附着在着色器对象上并编译它。</p><p>编译着色器可能失败，一般编译时会通过如下方法判断是否编译成功并输出编译信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] compileStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">GLES20.glGetShaderiv(shaderObjectId, GLES20.GL_COMPILE_STATUS, compileStatus, <span class="number">0</span>);</span><br><span class="line">Log.d(TAG, <span class="string">"glCompileStatus: "</span> + compileStatus[<span class="number">0</span>] </span><br><span class="line">            + <span class="string">" log:"</span> + GLES20.glGetShaderInfoLog(shaderObjectId));</span><br><span class="line"><span class="keyword">if</span> (compileStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="comment">//编译失败</span></span><br><span class="line">    GLES20.glDeleteShader(shaderObjectId);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mProgram = GLES30.glCreateProgram();</span><br><span class="line">GLES30.glAttachShader(mProgram, vertexShader);</span><br><span class="line">GLES30.glAttachShader(mProgram, fragmentShader);</span><br><span class="line">GLES30.glLinkProgram(mProgram);</span><br></pre></td></tr></table></figure><p>着色器程序对象是多个着色器合并之后并最终链接完成的版本，它将编译好的顶点着色器和片段着色器链接为一个着色器程序对象，链接后顶点着色器和片段着色器就没用了，可以通过 glDeleteShader 删除。就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">GLES20.glGetProgramiv(mProgram, GLES20.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">Log.d(TAG, <span class="string">"glCompileStatus："</span> + linkStatus[<span class="number">0</span>]</span><br><span class="line">            + <span class="string">" log:"</span> + GLES20.glGetProgramInfoLog(mProgram));</span><br><span class="line"><span class="keyword">if</span> (linkStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="comment">//链接失败</span></span><br><span class="line">    GLES20.glDeleteProgram(mProgram);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链接成功后，在渲染的时候通过 glUseProgram 方法激活着色器程序，已激活着色器程序的着色器就会在渲染时被使用，最后通过 glDrawArrays 方法触发绘制。</p><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://item.jd.com/12292642.html" target="_blank" rel="noopener">《音视频开发进阶指南 - 基于Android与IOS平台的实践》</a><br><a href="https://blog.csdn.net/TuGeLe/article/details/79199161" target="_blank" rel="noopener">Android GLSurfaceView详解</a><br><a href="http://wiki.jikexueyuan.com/project/opengl-es-guide/glsurfaceview.html" target="_blank" rel="noopener">GLSurfaceView</a><br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">你好，三角形</a><br><a href="https://www.jianshu.com/p/b05884a0ff8e" target="_blank" rel="noopener">OpenGL ES 3.0 glEnableVertexAttribArray的作用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过上篇文章的学习，现在已经了解到，要想在 Android 端使用 OpenGL ES 绘制图形，必须创建 OpenGL ES 环境和视图窗口，具体来说就是构建 EGL 环境，即 OpenGL ES 和 Android 底层平台视窗系统之间的接口。另外 OpenGL ES 2.0 版本为可编程管线，我们就可以编写着色器程序来确定绘制内容，即编写 Vertex Shader 顶点着色器和 Fragment Shader 片元着色器。&lt;/p&gt;
&lt;p&gt;而这些工作可以通过 GLSurfaceView 非常简单的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/yhaowa/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/yhaowa/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES（一）开发入门</title>
    <link href="http://yhaowa.gitee.io/yhaowa/eeb650a2/"/>
    <id>http://yhaowa.gitee.io/yhaowa/eeb650a2/</id>
    <published>2019-06-09T12:40:06.000Z</published>
    <updated>2020-12-06T06:59:08.614Z</updated>
    
    <content type="html"><![CDATA[<p>早就听过大名鼎鼎的 OpenGL，却迟迟没有实践学习，有些惭愧。今天开始通过实践+博文方式学习掌握 OpenGL。此文对于 OpenGL 的学习分为以下部分：</p><ul><li>OpenGL 基础概念</li><li>OpenGL 坐标系理解</li><li>OpenGL 渲染管线</li><li>OpenGL 着色语言</li></ul><a id="more"></a><h1 id="OpenGL-基础概念"><a href="#OpenGL-基础概念" class="headerlink" title="OpenGL 基础概念"></a>OpenGL 基础概念</h1><h4 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h4><p>OpenGL 即 Open Graphics Library，是一个功能强大、调用方便的底层图形库，它定义了跨编程语言、跨平台的专业图形程序接口，可用于二维或三维图像的处理与渲染。</p><p>OpenGL 是跨平台的，除了它纯粹专注的渲染外，其他内容在每个平台上都要有它的具体实现，比如上下文环境和窗口的管理就交由各个设备自己来完成。</p><h4 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h4><p>OpenGL ES （OpenGL for Embedded Systems）是三维图形 API OpenGL 的子集，针对手机、PDA 和游戏主机等嵌入式设备而设计。</p><p>Android 对应 OpenGL ES 的版本支持如下：</p><ul><li>Android 1.0 开始支持 OpenGL ES 1.0 及 1.1</li><li>Android 2.2 开始支持 OpenGL ES 2.0</li><li>Android 4.3 开始支持 OpenGL ES 3.0</li><li>Android 5.0 开始支持 OpenGL ES 3.1</li></ul><p>其中 OpenGL ES 1.0 是以 OpenGL 1.3 规范为基础的，OpenGL ES 1.1 是以 OpenGL 1.5 规范为基础的，而 OpenGL ES 2.0 基于 OpenGL 2.0 实现。2.x 版本相比 1.x 版本有较大差异，1.x 版本为 fixed function pipeline，即固定管线硬件，而 2.x 版本为 programmable pipeline，可编程管线硬件。</p><p>固定管线中原本由系统做的一部分工作，在可编程管线中必须需要自己写程序实现，具体程序为 vertex shader（顶点着色器）和 fragment shader（片元着色器）。</p><h4 id="OpenGL-上下文"><a href="#OpenGL-上下文" class="headerlink" title="OpenGL 上下文"></a>OpenGL 上下文</h4><p>OpenGL 是一个仅仅关注图像渲染的图像接口库，在渲染过程中它需要将顶点信息、纹理信息、编译好的着色器等渲染状态信息存储起来，而存储这些信息的数据结构就可以看作 OpenGL 的上下文。</p><p>调用任何 OpenGL 函数前，必须已经创建了 OpenGL Context，GL Context 存储了OpenGL 的状态变量以及其他渲染有关的信息。OpenGL 是个状态机，有很多状态变量，是个标准的过程式操作过程，改变状态会影响后续所有操作，这和面向对象的解耦原则不符，毕竟渲染本身就是个复杂的过程。OpenGL 采用 Client-Server 模型来解释 OpenGL 程序，即 Server 存储 GL Context（可能不止一个），Client 提出渲染请求，Server 给予响应，一般 Server 和 Client 都在我们的 PC 上，但 Server 和 Client 也可以是通过网络连接。</p><p>之后的渲染工作就要依赖这些渲染状态信息来完成，当一个上下文被销毁时，它所对应的 OpenGL 渲染工作也将结束。</p><h4 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h4><p>在 OpenGL 的设计中，OpenGL 是不负责管理窗口的，窗口的管理交由各个设备自己来完成，具体来讲，IOS 平台上使用 EAGL 提供本地平台对 OpenGL 的实现，在 Android 平台上使用 EGL 提供本地平台对 OpenGL 的实现。EGL 是 OpenGL ES 和 Android 底层平台视窗系统之间的接口，在 OpenGL 的输出与设备屏幕之间架接起一个桥梁，承担了为 OpenGL 提供上下文环境以及管理窗口的职责。</p><p>EGL 为双缓冲工作模式，即有一个 Back Frame Buffer 和一个 Front Frame Buffer，正常绘制的目标都是 Back Frame Buffer，绘制完成后再调用 eglSwapBuffer API，将绘制完毕的 FrameBuffer 交换到 Front Frame Buffer 并显示出来。</p><p>从代码层面来看，OpenGL ES 的 opengles 包下定义了平台无关的绘图指令，EGL（javax.microedition.khronos.egl）<br>则定义了控制 displays，contexts 以及 surfaces 的统一的平台接口。</p><ul><li>Display（EGLDisplay） 是对实际显示设备的抽象</li><li>Surface（EGLSurface）是对用来存储图像的内存区域 FrameBuffer 的抽象，包括 Color Buffer、Stencil Buffer、Depth Buffer</li><li>Context（EGLContext）存储 OpenGL ES 绘图的一些状态信息</li></ul><p><img src="../img/1.jpeg" alt></p><blockquote><p>使用 EGL 绘图的一般步骤：<br>获取 EGLDisplay 对象<br>初始化与 EGLDisplay 之间的连接<br>获取 EGLConfig 对象<br>创建 EGLContext 实例<br>创建 EGLSurface 实例<br>连接 EGLContext 和 EGLSurface<br>使用 GL 指令绘制图形<br>断开并释放与 EGLSurface 关联的 EGLContext 对象<br>删除 EGLSurface 对象<br>删除 EGLContext 对象<br>终止与 EGLDisplay 之间的连接</p></blockquote><p>一般来说在 Android 平台上开发 OpenGL ES 应用，无需按照上述步骤来绘制图形，可以直接使用 GLSurfaceView 控件，该控件提供了对 Display、Surface 以及 Context 的管理，大大简化了开发流程。</p><h4 id="OpenGL-纹理"><a href="#OpenGL-纹理" class="headerlink" title="OpenGL 纹理"></a>OpenGL 纹理</h4><p>纹理（Texture）是一个 2D 图片（甚至也有 1D 和 3D 的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的 3D 的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><h1 id="OpenGL-坐标系理解"><a href="#OpenGL-坐标系理解" class="headerlink" title="OpenGL 坐标系理解"></a>OpenGL 坐标系理解</h1><p>OpenGL 要求输入的顶点坐标都是标准化设备坐标，即每个顶点的 x、y、z 都在 -1 到 1 之间，由标准化设备坐标转换为屏幕坐标的过程中会经历变换多个坐标系统，在这些特定的坐标系中，一些操作和计算可以更加方便。</p><p><img src="../img/15.jpg" alt></p><ul><li><strong>1. 局部坐标</strong><br>顶点坐标起始于局部空间（Local Space），在这里称为局部坐标，是以物体某一点为原点而建立的，该坐标系仅对该物体适用，用来简化对物体各部分坐标的描述。物体放到场景中时，各部分经历的坐标变换相同，相对位置不变。</li><li><strong>2. 世界坐标</strong><br>局部坐标通过模型矩阵进行位移、缩放、旋转，将物体从局部变换到世界空间，并和其他物体一起相对于世界的原点摆放。</li><li><strong>3. 观察坐标</strong><br>将世界空间坐标转化为用户视野前方的坐标，通常是由一系列的位移和旋转的组合（观察矩阵）来完成。</li><li><strong>4. 裁剪坐标</strong><br>坐标到达观察空间之后，通过投影矩阵会将指定范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)，所有在范围外的坐标会被裁剪掉。</li><li><strong>5. 屏幕坐标</strong><br>将裁剪坐标位于(-1.0, 1.0)范围的坐标变换到由 glViewport 函数所定义的坐标范围内，最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ul><h1 id="OpenGL-渲染管线"><a href="#OpenGL-渲染管线" class="headerlink" title="OpenGL 渲染管线"></a>OpenGL 渲染管线</h1><p>OpenGL 渲染管线流程为：顶点数据 -&gt; 顶点着色器 -&gt; 图元装配 -&gt; 几何着色器 -&gt; 光栅化 -&gt; 片段着色器 -&gt; 逐片段处理 -&gt; 帧缓冲 </p><p><img src="../img/16.jpg" alt></p><p>OpenGL 渲染管线的流程其实就是 OpenGL 引擎渲染图像的流程，也就是说 OpenGL 引擎一步一步的将图片渲染到屏幕上的过程，渲染管线可以分为以下几个阶段：</p><ul><li><p><strong>1. 指定几何对象</strong><br>首先要了解几何图元的概念，几何图元就是点、直线、三角线等几何对象，在提供了顶点坐标后，还要确定具体要画的是点、线段还是三角形，这就要确定具体执行的绘制指令。比如 OpenGL 提供给开发者的绘制方法 glDrawArrays，这个方法的第一个参数就是指定绘制方式，可选值有：<br><strong>GL_POINTS</strong>：以点的形式进行绘制，通常用在绘制粒子效果的场景。<br><strong>GL_LINES</strong>：以线的形式进行绘制，通常用于绘制直线的场景。<br><strong>GL_TRIANGLE_STRIP</strong>：以三角形的形式进行绘制，所有二维图像的渲染都会使用这种方式。<br>具体选用哪一种绘制方式决定了 OpenGL 渲染管线的第一阶段应如何去绘制几何图元，这就是第一阶段指定几何对象。</p></li><li><p><strong>2. 顶点处理</strong><br>不论上面的几何图元是如何指定的，所有的几何数据都将会通过这个阶段。这个阶段的操作内容有：根据模型视图（即根据几何图元创建的物体）和投影矩阵进行变换来改变顶点的位置，根据纹理坐标与纹理矩阵来改变纹理坐标的位置，如果设计三维的渲染，还要处理光照计算和法线变换。<br>关键的操作就是顶点坐标变换及光照处理，每个顶点是分别单独处理的。这个阶段所接受的数据是每个顶点的属性特征，输出的则是变换后的顶点数据。</p></li><li><p><strong>3. 图元组装</strong><br>在顶点处理之后，顶点的全部属性都已经被确定。在这个阶段顶点将会根据应用程序设定的图元规则如 GL_POINTS 、GL_TRIANGLES(三角形) 等被组装成图元。</p></li><li><p><strong>4. 珊格化操作</strong><br>在图元组装后会传递过来图元数据，到目前为止，这些图元信息还只是顶点而已：顶点处都还没有“像素点”、直线段端点之间是空的、多边形的边和内部也是空的，光栅化的任务就是构造这些。<br>这个阶段会将图元数据分解成更小的单元并对应于帧缓冲区的各个像素，这些单元称为片元，一个片元可能包含窗口颜色、纹理坐标等属性。片元的属性则是图元上的顶点数据等经过插值而确定的，这就是珊格化操作，也就是确定好每一个片元是什么。</p></li><li><p><strong>5. 片元处理</strong><br>珊格化操作构造了像素点，这个阶段就是处理这些像素点，根据自己的业务处理（比如提亮、饱和度调节、对比度调节、高斯模糊等）来变换这个片元的颜色。</p></li><li><p><strong>6. 逐片段处理</strong><br>进行剪切、Alpha 测试、 模版测试、深度测试、混合等处理，这些操作将会最后影响其在帧缓冲区的颜色值。</p></li><li><p><strong>7. 帧缓冲操作</strong><br>此阶段主要执行帧缓冲的写入操作，也是渲染管线的最后一步，负责将最终的像素点写到帧缓冲区。</p></li></ul><p>上面提到 OpenGL ES 2.0 版本相比之前版本，提供了可编程的着色器来代替 1.x 版本渲染管线的某些阶段，具体为：</p><ul><li>Vertex Shader（顶点着色器）用于替换顶点处理阶段</li><li>Fragment Shader（片元着色器）用于替换片元处理阶段</li></ul><h1 id="OpenGL-着色语言"><a href="#OpenGL-着色语言" class="headerlink" title="OpenGL 着色语言"></a>OpenGL 着色语言</h1><p>OpenGL 着色语言 GLSL 全称为 OpenGL Shading Language，是为了实现着色器的功能而向开发人员提供的一种开发语言，语法与 C 语言类似，下面分为以下几点来学习 GLSL：</p><ul><li><strong>1. 基本数据类型</strong></li></ul><blockquote><p>void：空类型，即不返回任何值<br>bool：布尔类型，true/false<br>int：带符号的整数，signed integer<br>float：带符号的浮点数，signed scalar<br>vec2、vec3、vec4：n-维浮点数向量<br>bvec2、bvec3、bvec4：n-维布尔向量<br>ivec2、ivec3、ivec4：n-维整数向量<br>mat2、mat3、mat4：2x2、3x3、4x4 浮点数矩阵<br>sampler2D：2D 纹理<br>samplerCube：盒纹理</p></blockquote><p>其中 float 可指定精度：</p><blockquote><p>high：32bit，一般用于顶点坐标（vertex Coordinate）<br>medium：16bit，一般用于纹理坐标（texture Coordinate）<br>low：8bit，一般用于颜色表示（color）</p></blockquote><ul><li><strong>2. 变量修饰符</strong></li></ul><blockquote><p>none：(默认的可省略)本地变量，可读可写，函数的输入参数既是这种类型<br>const：声明变量或函数的参数为只读类型<br>attribute：用于保存顶点或法线数据,它可以在数据缓冲区中读取数据，仅能用于顶点着色器<br>uniform：在运行时 shader 无法改变 uniform 变量，一般用来放置程序传递给 shader 的变换矩阵，材质，光照参数等等，可用于顶点着色器和片元着色器<br>varying：用于修饰从顶点着色器向片元着色器传递的变量</p></blockquote><p>要注意全局变量限制符只能为 const、attribute、uniform 和 varying 中的某一个，不可复合。</p><ul><li><strong>3. 内置变量</strong></li></ul><p>GLSL 程序使用一些特殊的内置变量与硬件进行沟通，他们大致分成两种，一种是 input 类型,他负责向硬件(渲染管线)发送数据；另一种是 output 类型，负责向程序回传数据，以便编程时需要。<br>顶点着色器中 output 类型的内置变量如下：</p><blockquote><p>highp vec4  gl_Position：放置顶点坐标信息<br>mediump float gl_PointSize：需要绘制点的大小,(只在gl.POINTS模式下有效)</p></blockquote><p>片元着色器中 input 类型的内置变量如下：</p><blockquote><p>mediump vec4 gl_FragCoord;：片元在 framebuffer 画面的相对位置<br>bool gl_FrontFacing：标志当前图元是不是正面图元的一部分<br>mediump vec2 gl_PointCoord：经过插值计算后的纹理坐标,点的范围是0.0到1.0</p></blockquote><p>片元着色器中 output 类型的内置变量如下：</p><blockquote><p>mediump vec4 gl_FragColor：设置当前片点的颜色<br>mediump vec4 gl_FragData[n]：设置当前片点的颜色,使用glDrawBuffers数据数组</p></blockquote><ul><li><strong>4. 内置常量</strong></li></ul><p>GLSL 提供了一些内置的常量，用来说明当前系统的一些特性。有时我们需要针对这些特性，对 shader 程序进行优化，让程序兼容度更好。</p><p>顶点着色器中的内置常量如下：</p><blockquote><p>const mediump int gl_MaxVertexAttribs &gt;= 8：顶点着色器中可用的最大 attributes 数<br>const mediump int gl_MaxVertexUniformVectors &gt;= 128：顶点着色器中可用的最大 uniform vectors 数<br>const mediump int gl_MaxVaryingVectors &gt;= 8：顶点着色器中可用的最大 varying vectors 数<br>const mediump int gl_MaxVertexTextureImageUnits &gt;= 0：顶点着色器中可用的最大纹理单元数<br>const mediump int gl_MaxCombinedTextureImageUnits &gt;= 8：表示最多支持多少个纹理单元</p></blockquote><p>片元着色器中的内置常量如下：</p><blockquote><p>const mediump int gl_MaxTextureImageUnits &gt;= 8：片元着色器中能访问的最大纹理单元数<br>const mediump int gl_MaxFragmentUniformVectors &gt;= 16：片元着色器中可用的最大 uniform vectors 数<br>const mediump int gl_MaxDrawBuffers = 1：表示可用的 drawBuffers 数,在 OpenGL ES 2.0 中这个值为 1, 在将来的版本可能会有所变化</p></blockquote><p>上面这些值的大小取决于 OpenGL ES 在某设备上的具体实现。</p><ul><li><strong>5. 内置函数</strong></li></ul><blockquote><p>通用函数：abs、floor、min、max 等，参数可传入 float/vec2/vec3/vec4 类型<br>角度函数：sin、cos 等，参数可传入 float/vec2/vec3/vec4 类型<br>指数函数：pow、log 等，参数可传入 float/vec2/vec3/vec4 类型<br>几何函数：distance、dot 等，参数可传入 float/vec2/vec3/vec4 类型<br>矩阵函数：matrixCompMult，参数传入 mat 类型<br>向量函数：lessThan、equal 等，参数可传入 vec2/vec3/vec4 类型<br>纹理函数：texture2D、texture2DProj 等</p></blockquote><p>更详细的内置函数介绍可去官方文档查看，在此只简单列一下大致种类。</p><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://item.jd.com/12292642.html" target="_blank" rel="noopener">《音视频开发进阶指南 - 基于Android与IOS平台的实践》</a><br><a href="https://baike.baidu.com/item/OpenGL/238984?fr=aladdin" target="_blank" rel="noopener">OpenGL 百度百科</a><br><a href="https://blog.csdn.net/qq_36383623/article/details/89315921" target="_blank" rel="noopener">OpenGL Context（渲染上下文）</a><br><a href="https://baike.baidu.com/item/OpenGL%20ES" target="_blank" rel="noopener">OpenGL ES 百度百科</a><br><a href="https://blog.csdn.net/weixin_41101173/article/details/80036809" target="_blank" rel="noopener">在Android中使用OpenGL ES进行开发第（一）节：概念先行</a><br><a href="https://blog.csdn.net/jackie03/article/details/7298682" target="_blank" rel="noopener">Android OpenGL ES（四）:关于EGL</a><br><a href="https://blog.csdn.net/qq_35370018/article/details/80156643" target="_blank" rel="noopener">初学OpenGL（4）：纹理</a><br><a href="https://blog.csdn.net/u011153817/article/details/51899091" target="_blank" rel="noopener">OpenGL各坐标系及模型矩阵、投影矩阵等的深入理解</a><br><a href="https://www.cnblogs.com/liangliangh/p/4116164.html" target="_blank" rel="noopener">OpenGL管线（用经典管线代说着色器内部）</a><br><a href="https://blog.csdn.net/jeffasd/article/details/77989274" target="_blank" rel="noopener">OpenGL shader GLSL 中文手册</a><br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/" target="_blank" rel="noopener">坐标系统</a></p><p><img src="../img/qrcode.jpg" alt></p><center>关注公众号，Get 更多知识点</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就听过大名鼎鼎的 OpenGL，却迟迟没有实践学习，有些惭愧。今天开始通过实践+博文方式学习掌握 OpenGL。此文对于 OpenGL 的学习分为以下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenGL 基础概念&lt;/li&gt;
&lt;li&gt;OpenGL 坐标系理解&lt;/li&gt;
&lt;li&gt;OpenGL 渲染管线&lt;/li&gt;
&lt;li&gt;OpenGL 着色语言&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="音视频" scheme="http://yhaowa.gitee.io/yhaowa/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="OpenGL" scheme="http://yhaowa.gitee.io/yhaowa/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android 知识简记</title>
    <link href="http://yhaowa.gitee.io/yhaowa/c75061d/"/>
    <id>http://yhaowa.gitee.io/yhaowa/c75061d/</id>
    <published>2019-06-01T12:42:37.000Z</published>
    <updated>2020-12-06T09:28:36.826Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>网络：分层模型、TCP、UDP、HTTP、HTTPS<br>算法：数据结构、常用算法<br>Java 基础：StringBuilder、泛型擦除、Exception、IO、容器<br>Java 同步：volatile、wait、synchronized、可重入锁、乐观锁、死锁<br>Java 设计模式：六大原则、23 种设计模式、动态代理<br>Java 虚拟机：内存模型、内存结构、GC、四种引用、ClassLoader<br>Android 基础：Activity、View 绘制、动画、Window、SurfaceView、事件分发<br>Android 通信：Handler、Parcelable、IPC、Binder<br>Android 系统：系统架构、Dalvik、ART、系统启动、类加载器、Apk 打包、Apk 安装<br>Android 优化：网络优化、卡顿优化、内存优化、瘦包、内存泄漏、ANR、Native Crash<br>其他：解析 XML、进程保活、播放器、Lint、CI、CD、AOP、JetPack</p></blockquote><a id="more"></a><h1 id="网络：分层模型、TCP、UDP、HTTP、HTTPS"><a href="#网络：分层模型、TCP、UDP、HTTP、HTTPS" class="headerlink" title="网络：分层模型、TCP、UDP、HTTP、HTTPS"></a>网络：分层模型、TCP、UDP、HTTP、HTTPS</h1><h4 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h4><ul><li>应用层：负责处理特定的应用程序细节，如 HTTP、FTP、DNS</li><li>运输层：为两台主机提供端到端的基础通信，如 TCP、UDP</li><li>网络层：控制分组传输、路由选择等，如 IP</li><li>链路层：操作系统设备驱动程序、网卡相关接口</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>UDP 头结构：来源端口、目的端口、长度域、校验和</li><li>特点：不可靠、无序、面向报文、速度快、轻量</li><li>适用场景：适用于即时通讯、视频通话等</li><li>应用：DHCP、DNS、QUCI、VXLAN、GTP-U、TFTP、SNMP</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP 头结构：来源端口、目的端口、序号、确认序号、SYN/ACK 等状态位、窗口大小、校验和、紧急指针</li><li>特点：面向字节流、有拥塞和流量控制、可靠、有序、速度慢、较重量，通过滑动窗口实现流量控制、用塞控制</li><li>适用场景：文件传输、浏览器等</li><li>应用：HTTP、HTTPS、RTMP、FTP、SMTP、POP3</li><li><p>三次握手：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. C-&gt;S：SYN，seq=x（你能听到吗？）</span><br><span class="line">2. S-&gt;C：SYN，seq=y，ack=x+1（我能听到，你能听到吗？）</span><br><span class="line">3. C-&gt;S：ACK，seq=x+1，ack=y+1（我能听到，开始吧）</span><br><span class="line"></span><br><span class="line">两方都要能确保：我说的话，你能听到；你说的话，我能听到。所以需要三次握手</span><br></pre></td></tr></table></figure></li><li><p>四次挥手:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. C-&gt;S：FIN，seq=p（我说完了）</span><br><span class="line">2. S-&gt;C：ACK，ack=p+1（我知道了，等一下，我可能还没说完）</span><br><span class="line">3. S-&gt;C：FIN，seq=q，ACK，ack=p+1（我也说完了）</span><br><span class="line">4. C-&gt;S：ACK，ack=q+1（我知道了，结束吧）</span><br><span class="line"></span><br><span class="line">S 收到 C 结束的消息后 S 可能还没说完，没法立即回复结束标示，只能等说完后再告诉 C ：我说完了</span><br></pre></td></tr></table></figure></li></ul><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ul><li>超文本传输协议，明文传输，默认 80 端口</li><li>POST 和 GET：Get 参数放在 url 中；Post 参数放在 request Body 中</li><li>访问网页过程：DNS 域名解析、TCP 三次握手建立连接、发起 HTTP 请求</li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ul><li>默认 443 端口，使用 SSL 协议对 HTTP 传输数据进行了加密，安全</li><li>加密过程：Client/Server 通过非对称加密生成密钥，然后用这个密钥去对称加密传输数据</li></ul><h1 id="算法：数据结构、常用算法"><a href="#算法：数据结构、常用算法" class="headerlink" title="算法：数据结构、常用算法"></a>算法：数据结构、常用算法</h1><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>数组、链表</li><li>栈、队列</li><li>散列表</li><li>树、堆、图</li></ul><h4 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h4><ul><li>排序</li><li>双指针、滑动窗口、字符串</li><li>递归、分治、二分</li><li>回溯、贪心、动态规划</li></ul><h1 id="Java-基础：StringBuilder、泛型擦除、Exception、IO、容器"><a href="#Java-基础：StringBuilder、泛型擦除、Exception、IO、容器" class="headerlink" title="Java 基础：StringBuilder、泛型擦除、Exception、IO、容器"></a>Java 基础：StringBuilder、泛型擦除、Exception、IO、容器</h1><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><ul><li>StringBuffer 线程安全，StringBuilder 线程不安全</li><li>+实际上是用 StringBuilder 来实现的，所以非循环体可以直接用 +，循环体不行，因为会频繁创建 StringBuilder</li><li>String.concat 实质是 new String ，效率也低，耗时排序：StringBuilder &lt; StringBuffer &lt; concat &lt; +</li></ul><h4 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h4><ul><li>修饰成员变量等类结构相关的泛型不会被擦除</li><li>容器类泛型会被擦除</li></ul><h4 id="Exception-和-Error"><a href="#Exception-和-Error" class="headerlink" title="Exception 和 Error"></a>Exception 和 Error</h4><ul><li>Exception 和 Error 都继承自 Throwable</li><li>Error 大部分是指不可恢复的错误状态，比如 OOM，所以也不需要捕获</li><li>Exception 分为 CheckedException 和 UnCheckedException<ul><li>CheckedException：必须显式捕获，受编译器检查，比如 io 操作</li><li>UnCheckedException：不用显示捕获，比如空指针、数组越界等</li></ul></li></ul><h4 id="IO-、-NIO、-OKIO"><a href="#IO-、-NIO、-OKIO" class="headerlink" title="IO 、 NIO、 OKIO"></a>IO 、 NIO、 OKIO</h4><ul><li>IO 是面向流的，一次一个字节的处理，NIO 是面向缓冲区的，一次产生或消费一个数据块</li><li>IO 是阻塞的，NIO 是非阻塞的</li><li>NIO 支持内存映射方式</li><li>okio 相比 io 和 nio，api 更简单易用</li><li>okio 支持超时机制</li><li>okio 引入 ByteString 空间换时间提高性能</li><li>okio 采用 segment 机制进行内存共享，节省 copy 时间消耗</li></ul><h4 id="ArrayList、LinkedList"><a href="#ArrayList、LinkedList" class="headerlink" title="ArrayList、LinkedList"></a>ArrayList、LinkedList</h4><ul><li>ArrayList<ul><li>基于数组实现，查找快：o(1)，增删慢：o(n)</li><li>初始容量为10，扩容通过 System.arrayCopy 方法</li></ul></li><li>LinkedList<ul><li>基于双向链表实现，查找慢：o(n)，增删快：o(1)</li><li>封装了队列和栈的调用</li></ul></li></ul><h4 id="HashMap-、HashTable、HashSet"><a href="#HashMap-、HashTable、HashSet" class="headerlink" title="HashMap 、HashTable、HashSet"></a>HashMap 、HashTable、HashSet</h4><ul><li><p>HashMap（允许 key/value 为 null）</p><ul><li>基于数组和单向链表实现，数组是 HashMap 的主体；链表是为解决哈希冲突而存在的，存放的是key和value结合的实体</li><li>数组索引通过 key.hashCode（还会二次 hash） 得到，在链表上通过 key.equals 索引</li><li>哈希冲突落在同一个桶中时，直接放在链表头部（java1.8后放到尾部）</li><li>JAVA 8 中链表数量大于 8 时会转为红黑树存储，查找时间由 O(n) 变为 O(logn)</li><li>数组长度总是2的n次方：这样就能通过位运算实现取余，从而让 index 能落在数组长度范围内</li><li>加载因子（默认0.75）表示添加到多少填充比时进行扩容，填充比大：链表较长，查找慢；填充比小：链表短，查找快</li><li>扩容时直接创建原数组两倍的长度，然后将原有对象再进行hash找到新的index，重新放</li></ul></li><li><p>HashTable（不允许 key/value 为 null)</p><ul><li>数据结构和 HashMap 一样</li><li>线程安全</li></ul></li><li><p>HashSet</p><ul><li>基于 HashMap 实现，元素就是 HashMap 的 key，Value 传入了一个固定值</li></ul></li></ul><h4 id="ArrayMap、SparseArray"><a href="#ArrayMap、SparseArray" class="headerlink" title="ArrayMap、SparseArray"></a>ArrayMap、SparseArray</h4><ul><li><p>ArrayMap</p><ul><li>基于两个数组实现，一个存放 hash；一个存放键值对</li><li>存放 hash 的数组是有序的，查找时使用二分法查找</li><li>发生哈希冲突时键值对数组里连续存放，查找时也是通过 key.equals索引，找不到时先向后再向前遍历相同hash值的键值对数组</li><li>扩容时不像 HashMap 直接 double，内存利用率高；也不需要重建哈希表，只需要调用 system.arraycopy 数组拷贝，性能较高</li><li>不适合存大量数据（1000以下），因为数据量大的时候二分查找相比红黑树会慢很多</li></ul></li><li><p>SparseArray</p><ul><li>基于 ArrayMap，key 只能是特定类型</li></ul></li></ul><h4 id="Concurrent-集合"><a href="#Concurrent-集合" class="headerlink" title="Concurrent 集合"></a>Concurrent 集合</h4><ul><li>ConcurrentHashMap<ul><li>数据结构跟 HashMap 一样，还是数组加链表</li><li>采用 segment 分段锁技术，不像 HashTable 无脑直接同步 put 和 get 操作</li><li>get 操作没有加锁，因为 value 用 volatile 修饰来保证可见行，性能很高</li><li>java1.8 后去除分段锁，采用 CAS 乐观锁加 synchronized 来实现</li></ul></li></ul><h4 id="LRUCache-原理"><a href="#LRUCache-原理" class="headerlink" title="LRUCache 原理"></a>LRUCache 原理</h4><ul><li>基于访问顺序排序的 LinkedHashMap 实现，最近访问的会排在最后</li></ul><h1 id="Java-同步：volatile、wait、synchronized、可重入锁、乐观锁、死锁"><a href="#Java-同步：volatile、wait、synchronized、可重入锁、乐观锁、死锁" class="headerlink" title="Java 同步：volatile、wait、synchronized、可重入锁、乐观锁、死锁"></a>Java 同步：volatile、wait、synchronized、可重入锁、乐观锁、死锁</h1><h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><ul><li>只能用来修饰变量，适用修饰可能被多线程同时访问的变量</li><li>相当于轻量级的 synchronized，volatitle 能保证有序性（禁用指令重排序）、可见性</li><li>变量位于主内存中，每个线程还有自己的工作内存，变量在自己线程的工作内存中有份拷贝，线程直接操作的是这个拷贝</li><li>被 volatile 修饰的变量改变后会立即同步到主内存，保持变量的可见性</li><li>双重检查单例，为什么要加 violate？<ul><li>volatile想要解决的问题是，在另一个线程中想要使用instance，发现instance!=null，但是实际上instance还未初始化完毕这个问题。将instance = newInstance();拆分为3句话是。1.分配内存2.初始化3.将instance指向分配的内存空间，volatile可以禁止指令重排序，确保先执行2，后执行3</li></ul></li></ul><h4 id="wait-和-sleep"><a href="#wait-和-sleep" class="headerlink" title="wait 和 sleep"></a>wait 和 sleep</h4><ul><li>sleep 是 Thread 的静态方法，可以在任何地方调用</li><li>wait 是 Object 的成员方法，只能在 synchronized 代码块中调用，否则会报 IllegalMonitorStateException 非法监控状态异常</li><li>sleep 不会释放共享资源锁，wait 会释放共享资源锁</li></ul><h4 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h4><ul><li>锁池：某个对象的锁已被线程A拥有，其他线程要执行该对象的 synchronized 方法获取锁时就会进入该对象的锁池，锁池中的线程回去竞争该对象的锁</li><li>等待池：某个线程调用了某个对象的 wait 方法，该线程就会释放该对象的锁，进入该对象的等待池，等待池中的线程不会去竞争该对象的锁</li><li>调用 notify 会随机唤醒等待池中的一个线程，唤醒后会进入到锁池</li><li>调用 notifyAll 会唤醒等待池中的所有线程，唤醒后会都进入到锁池</li></ul><h4 id="lock-和-synchronized"><a href="#lock-和-synchronized" class="headerlink" title="lock 和 synchronized"></a>lock 和 synchronized</h4><ul><li>synchronized 是 Java 关键字，内置特性；Lock 是一个接口</li><li>synchronized 会自动释放锁；lock 需要手动释放，所以需要写到 try catch 块中并在 finally 中释放锁</li><li>synchronized 无法中断等待锁；lock 可以中断</li><li>Lock 可以提高多个线程进行读/写操作的效率</li><li>竞争资源激烈时，lock 的性能会明显的优于 synchronized</li></ul><h4 id="Synchronized-原理"><a href="#Synchronized-原理" class="headerlink" title="Synchronized 原理"></a>Synchronized 原理</h4><ul><li>每个对象都有一个监视器锁：monitor，同步代码块会执行  monitorenter 开始，motnitorexit 结束</li><li>Wait/notify 就依赖 monitor 监视器，所以在非同步代码块中执行会报 IllegalMonitorStateException 异常</li></ul><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul><li>定义：已经获取到锁后，再次调用同步代码块/尝试获取锁时不必重新去申请锁，可以直接执行相关代码</li><li>ReentrantLock 和 synchronized 都是可重入锁</li></ul><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><ul><li>定义：等待时间最久的线程会优先获得锁</li><li>非公平锁无法保证哪个线程获取到锁，synchronized 就是非公平锁</li><li>ReentrantLock 默认时非公平锁，可以设置为公平锁</li></ul><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ul><li>悲观锁：线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁</li><li>乐观锁：假设没有冲突，不加锁，更新数据时判断该数据是否过期，过期的话则不进行数据更新，适用于读取操作频繁的场景</li><li>乐观锁 CAS：Compare And Swap，更新数据时先比较原值是否相等，不相等则表示数据过去，不进行数据更新</li><li>乐观锁实现：AtomicInteger、AtomicLong、AtomicBoolean</li></ul><h4 id="死锁-4-个必要条件"><a href="#死锁-4-个必要条件" class="headerlink" title="死锁 4 个必要条件"></a>死锁 4 个必要条件</h4><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ul><h1 id="Java-设计模式：六大原则、23-种设计模式、动态代理"><a href="#Java-设计模式：六大原则、23-种设计模式、动态代理" class="headerlink" title="Java 设计模式：六大原则、23 种设计模式、动态代理"></a>Java 设计模式：六大原则、23 种设计模式、动态代理</h1><h4 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h4><ul><li>开闭原则：对拓展开放，对修改关闭</li><li>单一指责原则：一个类指责单一</li><li>里氏替换原则：引用基类的地方都能替换成子类对象</li><li>依赖倒置原则：高层次模块不依赖低层次模块的具体实现，抽象不应该依赖细节</li><li>接口隔离原则：类之间的依赖关系应该建立在最小的接口上</li><li>迪米特原则：一个对象对其他对象应该有尽量少的了解</li></ul><h4 id="Java-23-种设计模式（按目的分类为：5-7-11）"><a href="#Java-23-种设计模式（按目的分类为：5-7-11）" class="headerlink" title="Java 23 种设计模式（按目的分类为：5+7+11）"></a>Java 23 种设计模式（按目的分类为：5+7+11）</h4><p>1995 年 GoF（四人组）出了一本设计模式的书，收录了 23 种设计模式，树立设计模式里程碑，也叫：GoF 设计模式</p><ul><li>创建型（5）：描述怎么创建对象<ul><li>1.单例模式</li><li>2.原型模式：对象的拷贝</li><li>3.建造者模式</li><li>4.工厂模式：建立一个工厂方法来制造新的对象</li><li>5.抽象工厂模式：</li></ul></li><li>结构型（7）：描述如何将类或对象按某种规则组成更大的结构<ul><li>1.桥接模式：对于两个或以上纬度独立变化的场景，将抽象与具体实现分离，实例：用不同颜色画不同形状</li><li>2.外观模式：对外有一个统一接口，外部不用关心内部子系统的具体实现，这是”迪米特原则”的典型应用</li><li>3.适配器模式：改变类的接口，使原本由于接口不匹配而无法一起工作的两个类能够在一工作，实例：RecycleView 的 Adapter 不管什么类型的 View 都返回 ViewHolder</li><li>4.代理模式：由代理对象控制对原对象的引用，包括静态代理和动态代理</li><li>5.组合模式：将对象组成树形结构，用于对单个对象和组合对象的使用具有一致性，实例：ViewGroup</li><li>6.装饰模式：对对象包装一层，动态的增加一些额外功能，实例：ContextWrapper 包装 Context</li><li>7.享元模式：复用对象，实例：java 的常量池（比如 String），线程池，Message.obtain 等</li></ul></li><li>行为型（11）：描述类或对象之间怎么相互协作，怎样分配指责<ul><li>1.观察者模式：一对多依赖关系，多个观察者可以同时监听某一个对象，实例：jetpack 的 lifeCycle 添加生命周期观察者</li><li>2.中介者模式：定义一个中介对象封装一系列对象的交互，解耦这些对象，实例：MVP 的 P</li><li>3.访问者模式：将作用于某数据结构中各元素的操作分离出来封装成独立的类，对这些元素添加新的操作，但不改变原数据结构，实例：asm 中的 classVisitor 中再分别对类注解、变量、方法等进行处理</li><li>4.状态模式：行为由状态决定，不同状态下由不同行为，与策略模式类似，实例：不同状态下有同一种操作的不同行为的子类实现</li><li>5.命令模式：将一个请求封装为一个对象发出，交给别的对象去处理请求，实例：Handler 发送定义好的消息事件</li><li>6.策略模式：将一系列的算法封装起来，方便替换，实例：动画的时间插值器</li><li>7.责任链模式：让多个对象都有机会处理一个事件，实例：View 事件传递机制</li><li>8.备忘录模式：保存对象之前的状态，方便后面恢复</li><li>9.迭代器模式：提供一种方法遍历容器中的元素，而不需要暴露该对象的内部表示，实例：集合的迭代器</li><li>10.解释器模式：多次出现的问题有一定规律，就可以归纳成一种简单的语言来解释，实例：AndroidManifest 文件、GLES 着色器语言</li><li>11.模版方法模式：定义一套固定步骤，方便直接执行，实例：AsyncTask</li></ul></li></ul><h4 id="动态代理原理及实现"><a href="#动态代理原理及实现" class="headerlink" title="动态代理原理及实现"></a>动态代理原理及实现</h4><ul><li>InvocationHandler 接口，动态代理类需要实现这个接口</li><li>Proxy.newProxyInstance，用于动态创建代理对象</li><li>Retrofit 应用： Retrofit 通过动态代理，为我们定义的请求接口都生成一个动态代理对象，实现请求</li></ul><h1 id="JVM：内存模型、内存结构、GC、四种引用、ClassLoader"><a href="#JVM：内存模型、内存结构、GC、四种引用、ClassLoader" class="headerlink" title="JVM：内存模型、内存结构、GC、四种引用、ClassLoader"></a>JVM：内存模型、内存结构、GC、四种引用、ClassLoader</h1><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>定义：可以理解成一个虚构的计算机，解释自己的字节码指令集映射到本地 CPU 或 OS 的指令集，上层只需关注 Class 文件，与操作系统无关，实现跨平台</li><li>Kotlin 就是能解释成 Class 文件，所以可以跑在 JVM 上</li></ul><h4 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h4><ul><li>Java 多线程之间是通过共享内存来通信的，每个线程都有自己的本地内存</li><li>共享变量存放于主内存中，线程会拷贝一份共享变量到本地内存</li><li>volatile 关键字就是给内存模型服务的，用来保证内存可见性和顺序性</li></ul><h4 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h4><ul><li>线程私有：<ul><li>1.程序计数器：记录正在执行的字节码指令地址，若正在执行 Native 方法则为空</li><li>2.虚拟机栈：执行方法时把方法所需数据存为一个栈帧入栈，执行完后出栈</li><li>3.本地方法栈：同虚拟机栈，但是针对的是 Native 方法</li></ul></li><li>线程共享：<ul><li>1.堆：存储 Java 实例，GC 主要区域，分代收集 GC 方法会吧堆划分为新生代、老年代</li><li>2.方法区：存储类信息，常量池，静态变量等数据</li></ul></li></ul><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><ul><li>回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收</li><li>回收类型：<ul><li>1.堆中的对象：分代收集 GC 方法会吧堆划分为新生代、老年代。 新生代：新建小对象会进入新生代；通过复制算法回收对象；老年代：新建大对象及老对象会进入老年代；通过标记-清除算法回收对象。</li><li>2.方法区中的类信息、常量池</li></ul></li><li>判断一个对象是否可被回收：<ul><li>1.引用计数法：有循环引用的缺点</li><li>2.可达性分析法：从 GC ROOT 开始搜索，不可达的对象都是可以被回收的。其中 GC ROOT 包括虚拟机栈/本地方法栈中引用的对象、方法区中常量/静态变量引用的对象。</li></ul></li></ul><h4 id="Minor-GC-Major-GC-Full-GC"><a href="#Minor-GC-Major-GC-Full-GC" class="headerlink" title="Minor GC/Major GC/Full GC"></a>Minor GC/Major GC/Full GC</h4><ul><li>Minor GC（Young GC）：即新生代（分为一个 Eden 区和两个 Survivor 区）的垃圾回收<ul><li>Eden 区无用对象被回收，存活对象会移到 Survivor 区</li><li>Survivor 区的存活对象会被复制到另一个 Survivor 区，复制次数也记做年龄，年龄足够大时（15）会移到老年代</li><li>如果 Survivor 区已满，则存活对象会被提前移动到老年代（过早提升），如果老年代也无法容纳，则会触发 Full GC（提升失败）</li><li>老年代的对象可能引用新生代对象，所以这个引用会被作为 GC Roots</li></ul></li><li>Major GC：通常是跟 Full GC 等价的，回收整个堆</li><li>Full GC：回收整个堆，包括新生代和老年代<ul><li>当要在老年代分配空间但无法容纳时触发</li><li>当主动调用 System.gc 时触发</li></ul></li></ul><h4 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h4><ul><li>强引用：不会被回收</li><li>软引用：内存不足时会被回收</li><li>弱引用：gc 时会被回收</li><li>虚引用：无法通过虚引用得到对象，可以监听对象的回收</li></ul><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><ul><li>类的生命周期：<br>1.加载；2.验证；3.准备；4.解析；5.初始化；6.使用；7.卸载</li><li>类加载过程：<br>1.加载：获取类的二进制字节流；生成方法区的运行时存储结构；在内存中生成 Class 对象<br>2.验证：确保该 Class 字节流符合虚拟机要求<br>3.准备：初始化静态变量<br>4.解析：将常量池的符号引用替换为直接引用<br>5.初始化：执行静态块代码、类变量赋值</li><li>类加载时机：<br>1.实例化对象<br>2.调用类的静态方法<br>3.调用类的静态变量（放入常量池的常量除外）</li><li>类加载器：负责加载 class 文件<br>1.引导类加载器 - 没有父类加载器<br>2.拓展类加载器 - 继承自引导类加载器<br>3.系统类加载器 - 继承自拓展类加载器</li><li>双亲委托模型：<ul><li>当要加载一个 class 时，会先逐层向上让父加载器先加载，加载失败才会自己加载</li><li>为什么叫双亲？不考虑自定义加载器，系统类加载器需要网上询问两层，所以叫双亲</li><li>判断是否是同一个类时，除了类信息，还必须时同一个类加载器</li><li>优点：防止重复加载，父加载器加载过了就没必要加载了；安全，防止篡改核心库类</li></ul></li></ul><h1 id="Android-基础：Activity、View-绘制、动画、Window、SurfaceView、事件分发"><a href="#Android-基础：Activity、View-绘制、动画、Window、SurfaceView、事件分发" class="headerlink" title="Android 基础：Activity、View 绘制、动画、Window、SurfaceView、事件分发"></a>Android 基础：Activity、View 绘制、动画、Window、SurfaceView、事件分发</h1><h4 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h4><ul><li>A 打开 B 界面，会先执行 A 的 onPause，再执行 B 的 onCreate、onStart、onResume，再执行 A 的 onStop</li><li>B 界面的打开依赖 A 界面 onPause 方法执行完，所以不要在 onPause 中做耗时操作</li></ul><h4 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h4><ul><li>standard 标准模式</li><li>singleTop 栈顶复用模式，适用于推送点击消息界面</li><li>singleTask 栈内复用模式，适用于 App 首页</li><li>singleInstance 单例模式，单独位于一个任务栈中，适用于拨打电话界面</li><li>细节：<ul><li>taskAffinity：任务相关性，用于指定任务栈名称，默认为应用包名</li><li>allowTaskReparenting：允许转移任务栈</li></ul></li></ul><h4 id="View-工作原理"><a href="#View-工作原理" class="headerlink" title="View 工作原理"></a>View 工作原理</h4><ul><li>ViewRoot 的 performTraversals 方法调用触发开始 View 的绘制，然后会依次调用:<ul><li>performMeasure：遍历 View 的 measure 测量尺寸</li><li>performLayout：遍历 View 的 layout 确定位置</li><li>performDraw：遍历 View 的 draw 绘制</li></ul></li></ul><h4 id="MeasureSpec-测量规则"><a href="#MeasureSpec-测量规则" class="headerlink" title="MeasureSpec 测量规则"></a>MeasureSpec 测量规则</h4><ul><li>EXACTLY：父 View 指定了子 View 确切的大小</li><li>AT_MOST：父 View 指定一个大小，子 View 不能超过这个值</li><li>UNSPECIFIEND： 父 View 不对子 View 有任何限制</li></ul><h4 id="View-动画、帧动画及属性动画"><a href="#View-动画、帧动画及属性动画" class="headerlink" title="View 动画、帧动画及属性动画"></a>View 动画、帧动画及属性动画</h4><ul><li>View 动画：<ul><li>作用对象是 View，可用 xml 定义，建议 xml 实现比较易读</li><li>支持四种效果：平移、缩放、旋转、透明度</li></ul></li><li>帧动画：<ul><li>通过 AnimationDrawable 实现，容易 OOM</li></ul></li><li>属性动画：<ul><li>可作用于任何对象，可用 xml 定义，Android 3 引入，建议代码实现比较灵活</li><li>包括 ObjectAnimator、ValuetAnimator、AnimatorSet</li><li>时间插值器：根据时间流逝的百分比计算当前属性改变的百分比，系统预置匀速、加速、减速等插值器</li><li>类型估值器：根据当前属性改变的百分比计算改变后的属性值，系统预置整型、浮点、色值等类型估值器</li><li>使用注意事项：避免使用帧动画，容易OOM；界面销毁时停止动画，避免内存泄漏；开启硬件加速，提高动画流畅性</li><li>硬件加速原理：将 cpu 一部分工作分担给 gpu ，使用 gpu 完成绘制工作；从工作分摊和绘制机制两个方面优化了绘制速度</li></ul></li></ul><h4 id="Window-、WindowManager、WMS、SurfaceFlinger"><a href="#Window-、WindowManager、WMS、SurfaceFlinger" class="headerlink" title="Window 、WindowManager、WMS、SurfaceFlinger"></a>Window 、WindowManager、WMS、SurfaceFlinger</h4><ul><li>WIndow：抽象概念不是实际存在的，而是以 View 的形式存在，通过 PhoneWindow 实现</li><li>WindowManager：外界访问 Window 的入口，内部与 WMS 交互是个 IPC 过程</li><li>WMS：管理窗口 Surface 的布局和次序，作为系统级服务单独运行在一个进程</li><li>SurfaceFlinger：将 WMS 维护的窗口按一定次序混合后显示到屏幕上</li></ul><h4 id="SurfaceView、TextureView、SurfaceTexture、GLSurfaceView"><a href="#SurfaceView、TextureView、SurfaceTexture、GLSurfaceView" class="headerlink" title="SurfaceView、TextureView、SurfaceTexture、GLSurfaceView"></a>SurfaceView、TextureView、SurfaceTexture、GLSurfaceView</h4><ul><li>SurfaceView：使用双缓冲机制，有自己的 surface，在一个独立的线程里绘制，Android7.0之前不能平移、缩放</li><li>TextureView：持有 SurfaceTexture，将图像处理为 OpenGL 纹理更新到 HardwareLayer，必须开启硬件加速，Android5.0之前在主线程渲染，之后有独立的渲染线程，可以平移、旋转、缩放</li><li>SurfaceTexture：将图像流转为 OpenGL 外部纹理，不直接显示</li><li>GLSurfaceView：加入 EGL 管理，自带 GL 上下文和 GL 渲染线程</li></ul><h4 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h4><ul><li>一个 MotionEvent 产生后，按 Activity -&gt; Window -&gt; decorView -&gt; View 顺序传递，View 传递过程就是事件分发，主要依赖三个方法:</li><li>dispatchTouchEvent：用于分发事件，只要接受到点击事件就会被调用，返回结果表示是否消耗了当前事件</li><li>onInterceptTouchEvent：用于判断是否拦截事件，当 ViewGroup 确定要拦截事件后，该事件序列都不会再触发调用此 ViewGroup 的 onIntercept</li><li>onTouchEvent：用于处理事件，返回结果表示是否处理了当前事件，未处理则传递给父容器处理</li><li>细节：<ul><li>一个事件序列只能被一个 View 拦截且消耗</li><li>View 没有 onIntercept 方法，直接调用 onTouchEvent 处理</li><li>OnTouchListener 优先级比 OnTouchEvent 高，onClickListener 优先级最低</li><li>requestDisallowInterceptTouchEvent 可以屏蔽父容器 onIntercept 方法的调用</li></ul></li></ul><h1 id="Android-通信：Handler、Parcelable、IPC、Binder"><a href="#Android-通信：Handler、Parcelable、IPC、Binder" class="headerlink" title="Android 通信：Handler、Parcelable、IPC、Binder"></a>Android 通信：Handler、Parcelable、IPC、Binder</h1><h4 id="Handler、MessageQueue、Looper-及-postDelayed-原理"><a href="#Handler、MessageQueue、Looper-及-postDelayed-原理" class="headerlink" title="Handler、MessageQueue、Looper 及 postDelayed 原理"></a>Handler、MessageQueue、Looper 及 postDelayed 原理</h4><ul><li>Handler：开发直接接触的类，内部持有 MessageQueue 和 Looper</li><li>MessageQueue：消息队列，内部通过单链表存储消息</li><li>Looper：内部持有 MessageQueue，循环查看是否有新消息，有就处理，没就阻塞</li><li>postDelayed 其实就是调用 postAtTime 实现的，传入的时间戳基于 SystemClock.uptimeMillis，即 boot 时间</li><li>进一步会调用 MessageQueue#enqueueMessage 将消息插入到队列</li><li>插入消息时会根据消息执行时刻 Message#when 来决定插入到什么位置，when 为 0 或最早执行就会插入到链表头，否则按执行时刻排序插入</li><li>插入后如果正在阻塞则会尝试唤醒，插入到头部则会唤醒，插入到队列中则再根据其他条件判断是否需要唤醒</li><li>Looper#loop 中调用 MessageQueue#next 取消息，next 方法除非是即将销毁时会返回 null，否则就会返回消息，没有消息就阻塞。如果当前时刻还没到消息的执行时刻 when，就会再阻塞这个时间差的时间</li><li>阻塞是调用 nativePollOnce 实现，基于 Linux epoll 事件管理机制</li><li>Looper#loop 中取出消息后通过 Message#target 拿到 handler，然后调用 Handler#dispatchMessage 分发处理消息</li></ul><h4 id="Serializable、Parcelable"><a href="#Serializable、Parcelable" class="headerlink" title="Serializable、Parcelable"></a>Serializable、Parcelable</h4><ul><li>Serializable ：Java 序列化方式，适用于存储和网络传输，serialVersionUID 用于确定反序列化和类版本是否一致，不一致时反序列化回失败</li><li>Parcelable ：Android 序列化方式，适用于组件通信数据传递，性能高，因为不像 Serializable 一样有大量反射操作</li></ul><h4 id="Linux-IPC-方式"><a href="#Linux-IPC-方式" class="headerlink" title="Linux IPC 方式"></a>Linux IPC 方式</h4><ul><li>管道</li><li>socket</li><li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段</li><li>信号：不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等（Android 中的 Kill Process 采用的就是 signal（信号）机制）</li><li>消息队列：信息复制两次，额外的 CPU 消耗；不合适频繁或信息量大的通信</li><li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决</li></ul><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><ul><li>Android 中基于 C/S 结构的一种面向对象的进程间通信的机制</li><li>主要用在 system_server 进程与上层 App 层的 IPC 交互</li><li>包含：Client,Server,Binder 驱动和 ServiceManager 四部分</li></ul><h4 id="Android-为什么选择-binder"><a href="#Android-为什么选择-binder" class="headerlink" title="Android 为什么选择 binder"></a>Android 为什么选择 binder</h4><ul><li>性能：使用 mmap 一次数据拷贝实现 IPC，传统 IPC：用户 A 空间-&gt;内核-&gt;用户 B 空间；mmap 将内核与用户 B 空间映射，实现直接从用户 A 空间-&gt;用户B空间，而 Linux 的管道、消息队列、Socket 都需要拷贝两次，binder 仅次于共享内存</li><li>稳定性：基于C/S架构，架构清晰，稳定性好，不像共享内存实现方式复杂，需要充分考虑访问临界资源的并发同步问题</li><li>安全：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份</li></ul><h4 id="Android-IPC-方式"><a href="#Android-IPC-方式" class="headerlink" title="Android IPC 方式"></a>Android IPC 方式</h4><ul><li>Intent extras、Bundle：要求传递数据能被序列化，实现 Parcelable、Serializable ，适用于四大组件通信</li><li>文件共享：适用于交换简单的数据实时性不高的场景</li><li>AIDL：AIDL 接口实质上是系统提供给我们可以方便实现 Binder 的工具<ul><li>Android Interface Definition Language，可实现跨进程调用方法</li><li>服务端：将暴漏给客户端的接口声明在 AIDL 文件中，创建 Service 实现 AIDL 接口并监听客户端连接请求</li><li>客户端：绑定服务端 Service ，绑定成功后拿到服务端 Binder 对象转为 AIDL 接口调用</li><li>RemoteCallbackList 实现跨进程接口监听，同个 Binder 对象做 key 存储客户端注册的 listener</li><li>监听 Binder 断开：1.Binder.linkToDeath 设置死亡代理；2. onServiceDisconnected 回调</li></ul></li><li>Messenger：基于 AIDL 实现，服务端串行处理，主要用于传递消息，适用于低并发一对多通信</li><li>ContentProvider：基于 Binder 实现，适用于一对多进程间数据共享</li><li>Socket：TCP、UDP，适用于网络数据交换</li></ul><h1 id="Android-系统：系统架构、Dalvik、ART、系统启动、类加载器、Apk-打包、Apk-安装"><a href="#Android-系统：系统架构、Dalvik、ART、系统启动、类加载器、Apk-打包、Apk-安装" class="headerlink" title="Android 系统：系统架构、Dalvik、ART、系统启动、类加载器、Apk 打包、Apk 安装"></a>Android 系统：系统架构、Dalvik、ART、系统启动、类加载器、Apk 打包、Apk 安装</h1><h4 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h4><p><img src="file:///Users/wangyinghao/Documents/gitRes/AndroidInterview/img/20.jpg" alt></p><ul><li>应用层</li><li>Framework 框架层</li><li>本地 Native 库和 Android 运行时环境</li><li>HAL</li><li>Linux 内核</li></ul><h4 id="Dalvik-和-ART"><a href="#Dalvik-和-ART" class="headerlink" title="Dalvik 和 ART"></a>Dalvik 和 ART</h4><ul><li>Dalvik<ul><li>谷歌设计专用于 Android 平台的 Java 虚拟机，可直接运行 .dex 文件，适合内存和处理速度有限的系统</li><li>JVM 指令集是基于栈的；Dalvik 指令集是基于寄存器的，代码执行效率更优</li></ul></li><li>ART<ul><li>Dalvik 每次运行都要将字节码转换成机器码；ART 在应用安装时就会转换成机器码，执行速度更快</li><li>ART 存储机器码占用空间更大，空间换时间</li></ul></li></ul><h4 id="Android-系统启动流程"><a href="#Android-系统启动流程" class="headerlink" title="Android 系统启动流程"></a>Android 系统启动流程</h4><ul><li>按电源键 -&gt; 加载引导程序 BootLoader 到 RAM -&gt; 执行 BootLoader 程序启动内核 -&gt; 启动 init 进程 -&gt; 启动 Zygote 和各种守护进程 -&gt; 启动  System Server 服务进程开启 AMS、WMS 等 -&gt; 启动 Launcher 应用进程</li></ul><h4 id="Android-类加载器"><a href="#Android-类加载器" class="headerlink" title="Android 类加载器"></a>Android 类加载器</h4><ul><li>BootClassLoader(加载 Framework 级别的类)</li><li>PathClassLoader(加载系统类和 data/app 应用目录下的 dex 文件)</li><li>DexClassLoader(加载自定义的 dex 文件或 jar，支持从 sd 卡中进行加载)</li></ul><h4 id="APK-打包流程"><a href="#APK-打包流程" class="headerlink" title="APK 打包流程"></a>APK 打包流程</h4><ul><li>1.aapt 打包资源文件生成 R.java 文件；aidl 生成 java 文件</li><li>2.将 java 文件编译为 class 文件</li><li>3.将工程及第三方的 class 文件转换成 dex 文件</li><li>4.将 dex 文件、so、编译过的资源、原始资源等打包成 apk 文件</li><li>5.签名</li><li>6.资源文件对齐，减少运行时内存</li></ul><h4 id="App-安装过程"><a href="#App-安装过程" class="headerlink" title="App 安装过程"></a>App 安装过程</h4><ul><li>首先要解压 APK，资源、so等放到应用目录</li><li>Dalvik 会将 dex 处理成 ODEX ；ART 会将 dex 处理成 OAT；</li><li>OAT 包含 dex 和安装时编译的机器码</li></ul><h1 id="Android-优化：网络优化、卡顿优化、内存优化、瘦包、内存泄漏、ANR、Native-Crash"><a href="#Android-优化：网络优化、卡顿优化、内存优化、瘦包、内存泄漏、ANR、Native-Crash" class="headerlink" title="Android 优化：网络优化、卡顿优化、内存优化、瘦包、内存泄漏、ANR、Native Crash"></a>Android 优化：网络优化、卡顿优化、内存优化、瘦包、内存泄漏、ANR、Native Crash</h1><h4 id="网络优化及检测"><a href="#网络优化及检测" class="headerlink" title="网络优化及检测"></a>网络优化及检测</h4><ul><li>速度：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；4.IP 直连省去 DNS 解析时间</li><li>成功率：1.失败重试策略；</li><li>流量：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；5.文件下载断点续传 ；6.缓存</li><li>协议层的优化，比如更优的 http 版本等</li><li>监控：Charles 抓包、Network Monitor 监控流量</li></ul><h4 id="UI卡顿优化"><a href="#UI卡顿优化" class="headerlink" title="UI卡顿优化"></a>UI卡顿优化</h4><ul><li>减少布局层级及控件复杂度，避免过度绘制</li><li>使用 include、merge、viewstub</li><li>优化绘制过程，避免在 Draw 中频繁创建对象、做耗时操作</li></ul><h4 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h4><ul><li>内存问题<ul><li>内存泄漏</li><li>内存抖动：频繁创建临时对象</li><li>Bitmap 大内存：规避位图超标</li><li>代码质量：intdef 代替枚举，使用 SparseArray 代替 HashMap</li></ul></li><li>检测工具<ul><li>MAT(Memory Analysis Tools) ，可分析 Java 堆数据，可查看实例占用空间、引用关系等</li><li>Android Studio 自带的 Profiler</li><li>LeakCanary：通过弱引用和引用队列监控对象是否被回收，比如 Activity 销毁时开始监控此对象，检测到未被回收则主动 gc ，然后继续监控</li></ul></li></ul><h4 id="瘦包"><a href="#瘦包" class="headerlink" title="瘦包"></a>瘦包</h4><ul><li>1.资源方面：资源在线化、图片使用 webp 格式、tint 着色生成不同色调的切、使用 icon font</li><li>2.so 库：保留一个 cpu 架构的 so 文件</li><li>3.AS Inspect Code 清除无用代码和资源</li><li>4.代码混淆：使用 ProGuard 可以移除无用的类、字段、方法（压缩），移除无用字节码指令</li><li>5.不保留行号：使用 ProGuard 配置不保留行号</li><li>6.开启 shrinkResources：移除无用资源</li><li>7.资源混淆：使用 AndResGuard 缩短资源长度，对资源进行 7z 压缩等（直接对apk操作）</li><li>8.代码结构简化，比如用 intdef 代替 枚举(一个枚举有1~1.4kb大小)</li><li>9.使用 compileOnly 在只需编译时依赖的场景，不会打到 apk 里</li><li>10.使用 thinR 插件剔除 R 文件，将引用 R 字段的地方替换成对应常量</li><li>11.Android 7.0 使用 V2(apksigner) 代替 V1(jarsigner) 签名工具</li><li>12.动态加载 so 库(System.load加载绝对路径文件)、插件化技术、App Bundle</li><li>13.使用 facebook 的 redex</li></ul><h4 id="内存泄漏场景及规避"><a href="#内存泄漏场景及规避" class="headerlink" title="内存泄漏场景及规避"></a>内存泄漏场景及规避</h4><ul><li>1.静态变量、单例强引跟生命周期相关的数据或资源，包括 EventBus</li><li>2.游标、IO 流等资源忘记主动释放</li><li>3.界面相关动画在界面销毁时及时暂停</li><li>4.内部类持有外部类引用导致的内存泄漏<ul><li>handler 内部类内存泄漏规避：1.使用静态内部类+弱引用 2.界面销毁时清空消息队列</li><li>检测：Android Studio Profiler</li></ul></li></ul><h4 id="ANR-问题及分析"><a href="#ANR-问题及分析" class="headerlink" title="ANR 问题及分析"></a>ANR 问题及分析</h4><ul><li>anr 分类<ul><li>主线程 5s 内没有处理完输入事件</li><li>service 阻塞 20s</li><li>前台广播阻塞 10s 或后台广告阻塞 20s</li><li>ContentProvider publish 在 20s 内没有处理完</li></ul></li><li>anr 发生过程<ul><li>1.捕获到 anr，发送 linux 信号量 3</li><li>2.进程接受到信号量将 anr 信息写入 data/anr/traces.txt 文件</li><li>3.Log 打印 anr 信息</li><li>4.进程进入 anr 状态，弹出 anr 提示框</li></ul></li><li>监控 anr<ul><li>1.Android 5.0 以下监听 traces.txt 文件写入</li><li>2.每隔 5s 向主线程发送消息判断主线程是否阻塞</li></ul></li><li>分析 anr<ul><li>查看 cpu 负载是否是 cpu 资源紧张导致</li><li>查看堆栈看是否是我们的代码耗时过长</li></ul></li><li>避免 anr<ul><li>主线程中不要做耗时操作，注意使用 IntentService</li><li>降低子线程优先级，让主线程可以更多的获取到 cpu 资源</li></ul></li></ul><h4 id="Native-Crash"><a href="#Native-Crash" class="headerlink" title="Native Crash"></a>Native Crash</h4><ul><li>崩溃过程：native crash 时操作系统会向进程发送信号，崩溃信息会写入到 data/tombstones 下，并在 logcat 输出崩溃日志</li><li>定位：so 库剥离调试信息的话，只有相对位置没有具体行号，可以使用 NDK 提供的 addr2line 或 ndk-stack 来定位</li><li>addr2line：根据有调试信息的 so 和相对位置定位实际的代码处</li><li>ndk-stack：可以分析 tombstone 文件，得到实际的代码调用栈</li></ul><h1 id="其他：解析-XML、进程保活、播放器、Lint、CI、CD、AOP、JetPack"><a href="#其他：解析-XML、进程保活、播放器、Lint、CI、CD、AOP、JetPack" class="headerlink" title="其他：解析 XML、进程保活、播放器、Lint、CI、CD、AOP、JetPack"></a>其他：解析 XML、进程保活、播放器、Lint、CI、CD、AOP、JetPack</h1><h4 id="Android-解析-XML"><a href="#Android-解析-XML" class="headerlink" title="Android 解析 XML"></a>Android 解析 XML</h4><ul><li>SAX：流式解析</li><li>DOM：先把 XML 全部读取到内存，再访问树形结构，很消耗内存</li><li>PULL：流式解析，Android 内置的默认解析方式</li></ul><h4 id="热修复、插件化、组件化"><a href="#热修复、插件化、组件化" class="headerlink" title="热修复、插件化、组件化"></a>热修复、插件化、组件化</h4><ul><li>热修复原理：<ul><li>Native Hook（AndFix）：直接在 native 层进行方法的结构体信息对换</li><li>分包（QFix）：插入新 dex 到 dexElements[]，利用 ClassLoader 通过遍历 dexElements[] 来 findClass 的特性</li><li>Java Hook（Robust）：hook 每个方法，在每个方法里埋好准备替换的逻辑</li></ul></li><li>插件化：DexClassLoader 动态加载，四大组件未注册问题通过 hook AMS、Instrumentation 等解决，VirtualAPK 源码分析</li><li>组件化：ARoute 路由实现：通过 APT 解析 @Route 等注解，结合 JavaPoet 生成路由表，即路由与 Activity 的映射关系</li></ul><h4 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h4><ul><li>进程优先级：1.前台进程 ；2.可见进程；3.服务进程；4.后台进程；5.空进程</li><li>进程被 kill 场景：1.切到后台内存不足时被杀；2.切到后台厂商省电机制杀死；3.用户主动清理</li><li>保活方式：<ul><li>1.Activity 提权：挂一个 1像素 Activity 将进程优先级提高到前台进程</li><li>2.Service 提权：启动一个前台服务（API&gt;18会有正在运行通知栏）</li><li>3.广播拉活</li><li>4.Service 拉活</li><li>5.JobScheduler 定时任务拉活</li><li>6.双进程拉活</li></ul></li></ul><h4 id="播放器原理"><a href="#播放器原理" class="headerlink" title="播放器原理"></a>播放器原理</h4><ul><li>视频播放原理：（mp4、flv）-&gt; 解封装 -&gt; （mp3/aac、h264/h265）-&gt; 解码 -&gt; （pcm、yuv）-&gt; 音视频同步 -&gt; 渲染播放</li><li>音视频同步：<ul><li>选择参考时钟源：音频时间戳、视频时间戳和外部时间三者选择一个作为参考时钟源（一般选择音频，因为人对音频更敏感，ijk 默认也是音频）</li><li>通过等待或丢帧将视频流与参考时钟源对齐，实现同步</li></ul></li><li>IjkPlayer 原理<ul><li>集成了 MediaPlayer、ExoPlayer 和 IjkPlayer 三种实现，其中 IjkPlayer 基于 FFmpeg 的 ffplay</li><li>音频输出方式：AudioTrack、OpenSL ES；视频输出方式：NativeWindow、OpenGL ES</li></ul></li></ul><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><ul><li>Android Lint 是 Google 提供给 Android 开发者的静态代码检查工具</li><li>使用 Lint 对 Android 工程代码进行扫描和检查，可以发现代码潜在的问题，提醒程序员及早修正</li><li>基于 Detector、IssueRegistry 实现，通过 lintChecks project 引入</li></ul><h4 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h4><ul><li>Continuous integration（持续集成，简称CI）：频繁的将代码集成到主干，防止分支大幅偏离主干，方便快速发现错误</li><li>Continuous delivery（持续交付）：频繁地将软件的新版本，交付给质量团队或者用户，以供评审</li><li>Continuous deployment（持续部署）：持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境</li><li>交付后需要进行构建，将源码转换为可以运行的实际代码，常用的构建工具有 Jenkins、Strider</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li>基于 Gradle Transform API 创建 TransForm ，其执行时机在 class 被打包成 dex 之前</li><li>在 TransForm 中通过 javassist 或 asm 修改字节码</li><li>基于 Gradle Plugin API 自定义插件，应用自定义的 TransForm</li></ul><h4 id="JetPack"><a href="#JetPack" class="headerlink" title="JetPack"></a>JetPack</h4><ul><li>LiveData 感知声明周期原理：像 Glide 一样给界面添加了无视图的 Fragment</li><li>ViewModel 界面旋转短暂销毁重建时保存数据原理：<ul><li>ViewModel 保存在 ViewModelStore 中</li><li>当 Activity 配置变更销毁时，系统会调用 onRetainNonConfigurationInstance 保存 NonConfigurationInstances，而 ViewModel 就保存在 NonConfigurationInstances 中</li><li>重建时 onCreate 方法通过 getLastNonConfigurationInstance 方法获取到 NonConfigurationInstances，从而获取到 ViewModelStore</li></ul></li><li>JetPack 与 MVVM：<ul><li>先了解下 MVP：Model：处理数据；View：控制视图；Presenter：分离 Activity 和 Model</li><li>再看 MVVM：Model：处理获取保存数据；View：控制视图；ViewModel：数据容器</li><li>使用 Jetpack 组件架构的 LiveData、ViewModel 可以便捷的实现 MVVM</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;网络：分层模型、TCP、UDP、HTTP、HTTPS&lt;br&gt;算法：数据结构、常用算法&lt;br&gt;Java 基础：StringBuilder、泛型擦除、Exception、IO、容器&lt;br&gt;Java 同步：volatile、wait、synchronized、可重入锁、乐观锁、死锁&lt;br&gt;Java 设计模式：六大原则、23 种设计模式、动态代理&lt;br&gt;Java 虚拟机：内存模型、内存结构、GC、四种引用、ClassLoader&lt;br&gt;Android 基础：Activity、View 绘制、动画、Window、SurfaceView、事件分发&lt;br&gt;Android 通信：Handler、Parcelable、IPC、Binder&lt;br&gt;Android 系统：系统架构、Dalvik、ART、系统启动、类加载器、Apk 打包、Apk 安装&lt;br&gt;Android 优化：网络优化、卡顿优化、内存优化、瘦包、内存泄漏、ANR、Native Crash&lt;br&gt;其他：解析 XML、进程保活、播放器、Lint、CI、CD、AOP、JetPack&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/yhaowa/categories/Android/"/>
    
    
      <category term="总结" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>对 Android 开发的一点思考</title>
    <link href="http://yhaowa.gitee.io/yhaowa/f713728e/"/>
    <id>http://yhaowa.gitee.io/yhaowa/f713728e/</id>
    <published>2019-04-07T09:17:09.000Z</published>
    <updated>2020-12-06T07:13:14.206Z</updated>
    
    <content type="html"><![CDATA[<p>最初的时候，你是否是一个完美主义者，不容忍任何一点 warning 与叹号，if 必有 else，switch 必有 default，即使 else 和 default 中确实什么也不用处理，你也会添加一个 //do nothing 注释，表示这里的逻辑是经过充分考虑的，下次阅读程序时，告诉别人也告诉自己，这里的确什么也不用处理，可以快速跳过。</p><a id="more"></a><p>我想大多数开发者，都是经历过这种心态的，然后在繁忙的版本迭代中、在赶着回家的加班时、在愈来愈发的对自己的薪水不满时、在一次又一次看到团队中别人得过且过的代码时，渐渐的，就可能对“生活”妥协，丢掉了完美主义。</p><p>然而如果你有更高的追求，就要勇敢的战胜自己的感性。</p><h3 id="使用-IntDef、StringDef"><a href="#使用-IntDef、StringDef" class="headerlink" title="使用 IntDef、StringDef"></a>使用 IntDef、StringDef</h3><p>平时特常用的 View.setVisibility() 方法使用 IntDef 来规定参数的可选项，可以试想一下，假如没用 IntDef 会怎么样？对于初学者来说，可能要稍微阅读一下源码或查下资料才能知道 setVisibility 有哪些参数可以设置。你可能会觉得没什么差，因为你很清楚 setVisibility 方法有哪些参数可以设置。但若是程序中新增的一个方法呢？比如你新接触一个模块，某个界面有若干个跳转 Action，你得先找到定义这些 Action 的地方，而若一不小心将这些 Action 分散写在不同的地方，那对后面的维护和拓展可能就是一个灾难。</p><p>建议凡是符合语义的逻辑，都必须用 IntDef、StringDef 来约束，它比枚举节省内存，性能更优，其 RetentionPolicy.SOURCE 表示此注解只在源码中存在，编译时会剔除。你可以在 Android Studio 的 Live Templates 中添加 IntDef、StringDef 写法：<br><img src="../img/14.jpg" alt></p><h3 id="使用精准表达的变量类型"><a href="#使用精准表达的变量类型" class="headerlink" title="使用精准表达的变量类型"></a>使用精准表达的变量类型</h3><p>比如你需要声明一个变量来表示某个功能是否启用，譬如控制你的 App 是否展示广告，并且可以通过服务端在线下发开关来控制，如果没有接收到下发的开关，就根据地区来决定是否展示。</p><p>这种情况下你会使用什么类型的变量？</p><p>你可能会想到使用一个 int 类型变量来控制，然后需要给这个变量加上注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0：展示； 1：不展示； 2：未接收到在线开关，需要根据地区决定是否展示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mShouldShowAd;</span><br></pre></td></tr></table></figure><p>以后每当改动到这部分逻辑，都需要查看一下这个变量数值对应的含义，随着时间的推移和代码量的增多，在此逻辑之上可能堆积了很多代码，然后就会出现各种各样的问题，别人可能在不存在的逻辑分支做了一些事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mShouldShowAd == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mShouldShowAd == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mShouldShowAd == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可能对这个变量赋值 [0,2] 区间之外的数值！ 你可能对这个变量的意义很了解也绝不会用错，但你不能保证他人不会出现上面所说的荒唐的用法，因为这个变量类型并不能很精准的表达它的语义，也没有任何约束性。</p><p>我们可以怎样改善这种难维护、有风险的代码？</p><ul><li>可以使用 IntDef 规定这个变量的取值</li><li>可以换成 Boolean 类型，用 null 表示未获取到在线开关，恰好的表达语义并且易读、易维护</li></ul><h3 id="使用尽可能少的变量"><a href="#使用尽可能少的变量" class="headerlink" title="使用尽可能少的变量"></a>使用尽可能少的变量</h3><p>举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mDebug = BuildConfig.DEBUG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mDebug) &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你是否写过这样的逻辑？明明已经存在了一个可以直接使用的变量条件，你仍然要重新定义。这个例子逻辑还十分简单，此变量是 final 类型的，不会出错。而如果是非 final 类型的变量，那就是强行增加了一个赋值联动的逻辑，埋下了隐患，后续如果出了问题，白白的增加了定位问题的路径与复杂度。</p><p>实际开发中我们可能自己都意识不到使用了不必要的变量，比如我们的服务端接口一般会有多个接口环境，那你的代码可能是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否是测试环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sIsApiHostTest;</span><br><span class="line"><span class="comment">//是否是beta环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sIsApiHostBeta;</span><br><span class="line"><span class="comment">//正式环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line"><span class="comment">//测试环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line"><span class="comment">//beta环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sIsApiHostTest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sIsApiHostBeta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isApiTest()) &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHostTest;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isApiBeta()) &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHostBeta;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sApiHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样看起来好像没什么问题，只要维护好 sIsApiHostTest、sIsApiHostBeta 这两个变量就行了。如果后面又添加了一个环境呢？又添加了三四个环境呢？是不是还要维护多个变量？这个逻辑可以通过减少变量来改善：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sCurApiHost;</span><br><span class="line"><span class="comment">//正式环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line"><span class="comment">//测试环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line"><span class="comment">//beta环境host</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sApiHostTest.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sApiHostBeta.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sCurApiHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再加上 StringDef 就完美了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StringDef</span>(&#123;ApiHost.sApiHost, ApiHost.sApiHostTest, ApiHost.sApiHostBeta&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiHost &#123;</span><br><span class="line">    <span class="comment">//正式环境host</span></span><br><span class="line">    String sApiHost = <span class="string">"http://api.com/"</span>;</span><br><span class="line">    <span class="comment">//测试环境host</span></span><br><span class="line">    String sApiHostTest = <span class="string">"http://test.api.com/"</span>;</span><br><span class="line">    <span class="comment">//beta环境host</span></span><br><span class="line">    String sApiHostBeta = <span class="string">"http://beta.api.com/"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前环境host</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sCurApiHost = ApiHost.sApiHost;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是测试环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiHost.sApiHostTest.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是beta环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApiBeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ApiHost.sApiHostBeta.equals(sCurApiHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getApiHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sCurApiHost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置接口域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiHost</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setApiHost</span><span class="params">(@ApiHost String apiHost)</span> </span>&#123;</span><br><span class="line">    sCurApiHost = apiHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道你有没有感受到易读性、可维护性、拓展性都蹭蹭蹭的往上涨呢？</p><h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h3><p>同时接受多个数据源数据的逻辑相比只接受一个数据源的数据需要考虑时序性等问题，要复杂很多。打个比方，可以把数据源当作你的直接上级，上级会不定时的分配任务给你做，如果你有多个上级，一个让你做任务 A，一个让你做任务 B，且 A 需要在 B 之前完成，你要怎么办？两个上级都让你做任务 A，但是只用做一次，你要怎么办？</p><p>在安卓中较为典型的场景就是同时加载网络和本地缓存数据到 UI 上，你的 UI 上展示的数据来自不同的地方，你需要考虑不同数据源之间如何协作。谷歌推出的 Jetpack 开发指南上推荐我们使用单一数据源，假如你的网络数据也需要缓存的话，那你的实现逻辑应该是这样：</p><ul><li>加载网络数据，返回后插入到本地<ul><li>统一从本地取数据展示到 UI 上</li></ul></li></ul><p>这点和上面说的“使用尽可能少的变量”有相通之处，都是尽量规避使用多个条件变量对程序产生影响的逻辑。</p><h3 id="职责分离"><a href="#职责分离" class="headerlink" title="职责分离"></a>职责分离</h3><p>强烈建议什么类里就干什么事，别把逻辑都揉到一块儿，这样随着代码量的增加，会愈发的难以维护，到最后就变成一颗存在重大隐患的地雷，看见就头疼。</p><p>举个例子，比如你要自定义一个 View，那就像系统控件一样，只负责一个控件该负责的事，处理一下渲染、展示，把手势交互通过接口开放出来，把数据的获取写在数据仓库中。这样如果数据展示出了问题，可以很快的定位到是数据获取出了问题，还是渲染展示出了问题；如果这个控件的渲染展示是经过验证的，之后就几乎不用改动此控件，至少你有机会可以将你的自定义 View 写的像系统的控件一样稳定。</p><p>这里再推荐一下谷歌的 Jetpack - MVVM 全家桶，MVC 真的是不易读、难维护、问题多、很简陋。</p><h3 id="回归最初的完美主义"><a href="#回归最初的完美主义" class="headerlink" title="回归最初的完美主义"></a>回归最初的完美主义</h3><p>希望你我可以战胜感性，不向“生活”妥协，让优秀成为准则和习惯，回归最初的完美主义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最初的时候，你是否是一个完美主义者，不容忍任何一点 warning 与叹号，if 必有 else，switch 必有 default，即使 else 和 default 中确实什么也不用处理，你也会添加一个 //do nothing 注释，表示这里的逻辑是经过充分考虑的，下次阅读程序时，告诉别人也告诉自己，这里的确什么也不用处理，可以快速跳过。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yhaowa.gitee.io/yhaowa/categories/Android/"/>
    
    
      <category term="开发模式" scheme="http://yhaowa.gitee.io/yhaowa/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
