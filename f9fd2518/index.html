
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>开发编写的 View 控件，是怎么变成屏幕上图像的？ | what is your main focus for today?</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Activity 与 Window setContentView 原理 Activity 窗口添加过程   UI 刷新机制 发起 UI 重绘请求 执行 UI 绘制时机 vsync 信号的生成 vsync 信号的分发 SurfaceFlinger -&amp;gt; DispSync DispSync -&amp;gt; DispSyncSource DispSyncSource -&amp;gt; EventThre">
<meta name="keywords" content="window,vsync,surface">
<meta property="og:type" content="article">
<meta property="og:title" content="开发编写的 View 控件，是怎么变成屏幕上图像的？">
<meta property="og:url" content="http://yhaowa.gitee.io/yhaowa/f9fd2518/index.html">
<meta property="og:site_name" content="what is your main focus for today?">
<meta property="og:description" content="Activity 与 Window setContentView 原理 Activity 窗口添加过程   UI 刷新机制 发起 UI 重绘请求 执行 UI 绘制时机 vsync 信号的生成 vsync 信号的分发 SurfaceFlinger -&amp;gt; DispSync DispSync -&amp;gt; DispSyncSource DispSyncSource -&amp;gt; EventThre">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-12-06T14:24:02.937Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="开发编写的 View 控件，是怎么变成屏幕上图像的？">
<meta name="twitter:description" content="Activity 与 Window setContentView 原理 Activity 窗口添加过程   UI 刷新机制 发起 UI 重绘请求 执行 UI 绘制时机 vsync 信号的生成 vsync 信号的分发 SurfaceFlinger -&amp;gt; DispSync DispSync -&amp;gt; DispSyncSource DispSyncSource -&amp;gt; EventThre">
  
    <link rel="alternative" href="/atom.xml" title="what is your main focus for today?" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/yhaowa/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head></html>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/yhaowa/" id="logo">what is your main focus for today?</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/yhaowa/">首页</a>
        
          <a class="main-nav-link" href="/yhaowa/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yhaowa.gitee.io/yhaowa">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-Android 屏幕显示原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yhaowa/f9fd2518/" class="article-date">
  <time datetime="2020-11-08T06:24:57.000Z" itemprop="datePublished">2020-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/yhaowa/categories/Framework/">Framework</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      开发编写的 View 控件，是怎么变成屏幕上图像的？
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<ol>
<li>Activity 与 Window<ol>
<li>setContentView 原理</li>
<li>Activity 窗口添加过程</li>
</ol>
</li>
<li>UI 刷新机制<ol>
<li>发起 UI 重绘请求</li>
<li>执行 UI 绘制时机</li>
<li>vsync 信号的生成</li>
<li>vsync 信号的分发<ol>
<li>SurfaceFlinger -&gt; DispSync</li>
<li>DispSync -&gt; DispSyncSource</li>
<li>DispSyncSource -&gt; EventThread</li>
<li>Connection -&gt; SurfaceFlinger </li>
<li>Connection -&gt; app</li>
</ol>
</li>
</ol>
</li>
<li>UI 绘制流程</li>
<li>Surface 与 SurfaceFlinger</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="1-Activity-与-Window"><a href="#1-Activity-与-Window" class="headerlink" title="1. Activity 与 Window"></a>1. Activity 与 Window</h1><h2 id="1-setContentView-原理"><a href="#1-setContentView-原理" class="headerlink" title="1. setContentView 原理"></a>1. setContentView 原理</h2><p>Activity 中将 setContentView 工作交给了 Window 对象去处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Activity 内部都持有一个 Window 对象，而 Window 对象是在创建 Activity 流程中 attach 时就实例化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PhoneWindow 中会实际去 inflate 布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 installDecor 中伪代码逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = <span class="keyword">new</span> DecorView(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = (ViewGroup)mDecor.findViewById(R.id.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Activity 内部都持有一个 window 对象，其实现为 PhoneWindow，在 Activity attachContext 时创建。</p>
<p>PhoneWindow 的根布局为 DecorView，其包括 TitleView 和 ContentView，Activity 的 setContentView 就是把布局添加到 ContentView。</p>
<h2 id="2-Activity-窗口添加过程"><a href="#2-Activity-窗口添加过程" class="headerlink" title="2. Activity 窗口添加过程"></a>2. Activity 窗口添加过程</h2><p>setContentView 只是创建好了 View 视图结构，还没告知 WMS。在 ActivityThread handleResumeActivity 方法中，才会与 WMS 通信开始添加 Activity 窗口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, ...);</span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">    &#125;</span><br><span class="line">    r.activity.makeVisible();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 performResumeActivity 方法会回调 onResume 生命周期，之后调用 WindowManager 的 addView 方法并将 DecorView 传入。这里的 WindowManager 为 WindowManagerImpl 对象，与 Activity 内部的 window 一样，都是在 Activity attachContext 时创建。</p>
<p>WindowManagerImpl 中 addView 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其进一步交给了 mGlobal 即 WindowManagerGlobal 去处理，接着来看 WindowManagerGlobal 的 addView 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">            mRoots.get(index).doDie();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                    + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ViewRootImpl root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 WindowManagerGlobal 为进程单例，其内部的 mViews 则记录了全局添加的 View。当重复添加 View 时，就会抛出 “View has already been added to the window manager” 异常。</p>
<p>接着创建一个与 View 对应的 ViewRootImpl，将 View、ViewRootImpl 记录在 WindowManagerGlobal 中后，调用了 ViewRootImpl 的 setView 方法。先来看 ViewRootImpl 的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mWindowSession 是通过 WMS openSession 获取的匿名 binder，用于应用调用 WMS；mWindow 也是一个 binder 接口，用于 WMS 调用应用端。</p>
<p>接着看 ViewRootImpl setView 方法，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">            requestLayout();</span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">                    mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                    mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">                    mTempInsets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，不需把 view 传给 WMS，这是因为 WMS 并不关心 View 树所表达的具体 UI 内容，它只要知道各应用进程显示界面的大小、窗口层级值即可。</p>
<p>到达 WMS 所在 system_server 进程后，WindowSession addToDisplay 会进一步调用 WindowManagerService 的 addWindow 方法，执行添加用户窗口工作，包括：</p>
<ul>
<li>对用户窗口进行权限检查，比如 TYPE_PHONE 等窗口类型需要 SYSTEM_ALERT_WINDOW 权限</li>
<li>检查 mWindow，窗口最终会记录到 &lt;IBinder,WindowState&gt; HashMap 中，其中 IBinder 为应用端的 mWindow，即一个 mWindow 只允许添加唯一的窗口</li>
<li>检查窗口类型，比如子窗口必须依赖于一个父窗口</li>
<li>按照窗口层级添加合适的位置</li>
<li>等等…</li>
</ul>
<p>小结一下，当 Activity 第一次回调 onResume 后，将 Activity 对应的窗口添加到 WMS 的过程：</p>
<ul>
<li>首先调用了 WindowManagerImpl，WindowManagerImpl 进一步调用进程单例的 WindowManagerGlobal</li>
<li>WindowManagerGlobal 中创建了与 DecorView 对应的 ViewRootImpl，并将 DecorView 和 ViewRootImpl 记录下来</li>
<li>WindowManagerImpl 和 WindowManagerGlobal 都还在应用进程，与 WMS 没什么关系</li>
<li>在 ViewRootImpl 中与 WMS 发生交互，应用端通过 WindowSession 调用 WMS，WMS 通过 IWindow 调用应用端</li>
<li>WMS 中会对窗口进行权限、类型等检查，最终将应用窗口信息记录下来</li>
</ul>
<h1 id="2-UI-刷新机制"><a href="#2-UI-刷新机制" class="headerlink" title="2. UI 刷新机制"></a>2. UI 刷新机制</h1><h2 id="1-发起-UI-重绘请求"><a href="#1-发起-UI-重绘请求" class="headerlink" title="1. 发起 UI 重绘请求"></a>1. 发起 UI 重绘请求</h2><p>ViewRootImpl 中的 performTraversals 中会依次调用 performMeasure、performLayout、performDraw，分别对应于 measure、layout、draw，由顶而下的进行界面绘制逻辑。</p>
<p>调用 View 控件 requestLayout、invalidate 等方法请求 UI 重绘时，会统一调用到 ViewRootImpl 的 scheduleTraversals 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 postSyncBarrier 插入一个消息屏障 block 普通消息，以保证主线程可以优先来执行接下来的绘制工作。mTraversalRunnable 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 mTraversalScheduled 变量可以看出，不是每次调用 requestLayout、invalidate 方法就会触发一次 UI 重绘的，而是要等 mTraversalRunnable 被执行后才会接收下一次的重绘请求。</p>
<p>在 mTraversalRunnable 中调用了 performTraversals() 进行真正的 UI 绘制，而 UI 真正绘制的时机则取决于 mChoreographer 触发回调的时机。</p>
<h2 id="2-执行-UI-绘制时机"><a href="#2-执行-UI-绘制时机" class="headerlink" title="2. 执行 UI 绘制时机"></a>2. 执行 UI 绘制时机</h2><p>ViewRootImpl 接收 UI 重绘请求后，将真正的 UI 绘制时机交给了 Choreographer，而 Choreographer 中会在每次 vsync 信号到来时执行 UI 绘制。</p>
<p>调用 Choreographer 的 postCallback 方法将 UI 绘制 TraversalRunnable 传入后，会进一步调用 Choreographer 的 postCallbackDelayedInternal 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将 UI 绘制 action 记录到 mCallbackQueues 队列中，然后根据处理时间决定立即调用 scheduleFrameLocked ，或发送异步消息延时调用 scheduleFrameLocked。</p>
<p>scheduleFrameLocked 方法关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span></span><br><span class="line">    <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span></span><br><span class="line">    <span class="comment">// as soon as possible.</span></span><br><span class="line">    <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">        scheduleVsyncLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注释所示，scheduleFrameLocked 中需要切换到指定线程中调用 scheduleVsyncLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scheduleVsync 表示要接受下一次 vsync 信号，等到 vsync 信号到来时会由 SurfaceFlinger 回调通知。直接来看 Choreographer 接受到 vsync 信号后的处理，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                        + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当要绘制的图像时间戳晚于一个帧刷新周期时，会去进一步计算异常跳过的帧数，如果跳过的帧数过大，就可以看到非常眼熟的一条日志了：<em>“Skipped xx frames! The application may be doing too much work on its main thread”</em> </p>
<p>随后通过 doCallbacks 回调触发执行 UI 绘制，也就是执行 ViewRootImpl 传过来的 TraversalRunnable、调用 performTraversals 方法，由顶而下的执行界面绘制逻辑。</p>
<h2 id="3-vsync-信号的生成"><a href="#3-vsync-信号的生成" class="headerlink" title="3. vsync 信号的生成"></a>3. vsync 信号的生成</h2><p><strong>vsync 信号在 SurfaceFlinger 中生成，并且有硬件、软件两种生成方式</strong> — 仅通过这种高度总结的描述，我们能得到多少信息呢？ 具体是如何生成？是优先选硬件生成还是软件生成还是同时存在？</p>
<p>下面就通过源码来一探究竟，既然在 SurfaceFlinger 中生成，那先来看 SurfaceFlinger 的 init 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mHwc = new HWComposer(<span class="keyword">this</span>);</span><br><span class="line">    mHwc-&gt;setEventHandler(static_cast&lt;HWComposer::EventHandler*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HWComposer 是 vsync 信号实际生成的类，SurfaceFlinger 通过 setEventHandler 向 HWComposer 注册了一个回调，使 SurfaceFlinger 能够接受由 HWComposer 生成的 vsync 信号，EventHandler 中的回调方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> onVSyncReceived(int32_t disp, nsecs_t timestamp)</span><br></pre></td></tr></table></figure>
<p>下面来看实际生成 vsync 的 HWComposer，其构造方法关键代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(...)&#123;</span><br><span class="line">    <span class="keyword">bool</span> needVSyncThread = <span class="literal">true</span>;</span><br><span class="line">    loadHwcModule(); <span class="comment">//加载硬件</span></span><br><span class="line">    <span class="keyword">if</span>(mHwc)&#123; <span class="comment">//硬件加载成功</span></span><br><span class="line">        mCBContext-&gt;procs.vsync = &amp;hook_vsync; <span class="comment">//注册硬件源回调</span></span><br><span class="line">        mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        needVSyncThread = <span class="literal">false</span>; <span class="comment">//不使用软件方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(needVSyncThread)&#123;</span><br><span class="line">        <span class="comment">//如果硬件不支持，则用软件模拟</span></span><br><span class="line">        mVSyncThread = new VSyncThread(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑十分简单，首先去加载硬件，优先使用硬件生成方式，如果硬件不支持，则用软件模拟。</p>
<p>硬件源生成的回调 hook_vsync 方法调用如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::hook_vsync(<span class="keyword">const</span> <span class="keyword">struct</span> hwc_procs* procs, <span class="keyword">int</span> disp,</span><br><span class="line">        int64_t timestamp) &#123;</span><br><span class="line">    cb_context* ctx = reinterpret_cast&lt;cb_context*&gt;(</span><br><span class="line">            const_cast&lt;hwc_procs_t*&gt;(procs));</span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp); <span class="comment">//调用 vsync 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HWComposer::vsync(<span class="keyword">int</span> disp, int64_t timestamp) &#123;</span><br><span class="line">    mEventHandler.onVSyncReceived(disp, timestamp); <span class="comment">//回调出去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此 HWComposer 中的 vsync 硬件生成方式流程完毕，最后调用了 mEventHandler 回调，交由 SurfaceFlinger 处理。</p>
<p>再来看软件模拟生成方式，其通过 VSyncThread 类实现，VSyncThread 继承了 Thread 类，自然也继承了 Thread 类的 <em>threadLoop</em> 方法。</p>
<p>如果 threadLoop 方法返回 true，那当工作线程启动后，基类 Thread 会循环的调用 threadLoop 方法。而软件模拟生成的 vsync 信号就是在 threadLoop 方法中生成的，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HWComposer::VSyncThread::threadLoop() &#123;</span><br><span class="line">    <span class="keyword">const</span> nsecs_t period = mRefreshPeriod; <span class="comment">// vsync 周期</span></span><br><span class="line">    <span class="keyword">const</span> nsecs_t now = systemTime(<span class="built_in">CLOCK_MONOTONIC</span>); <span class="comment">//当前时间</span></span><br><span class="line">    nsecs_t next_vsync = mNextFakeVSync; <span class="comment">//本次要生成的 vsync 信号时间</span></span><br><span class="line">    nsecs_t sleep = next_vsync - now;</span><br><span class="line">    <span class="keyword">if</span> (sleep &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错过了，重新计算本次要生成的 vsync 信号时间</span></span><br><span class="line">        sleep = (period - ((now - next_vsync) % period));</span><br><span class="line">        next_vsync = now + sleep;</span><br><span class="line">    &#125;</span><br><span class="line">    mNextFakeVSync = next_vsync + period; <span class="comment">// 下一个 vsync 信号时间</span></span><br><span class="line">    <span class="keyword">struct</span> timespec spec;</span><br><span class="line">    spec.tv_sec  = next_vsync / <span class="number">1000000000</span>;</span><br><span class="line">    spec.tv_nsec = next_vsync % <span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//休眠到 next_vsync 即本次 vsync 信号时间 </span></span><br><span class="line">        err = clock_nanosleep(<span class="built_in">CLOCK_MONOTONIC</span>, TIMER_ABSTIME, &amp;spec, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (err&lt;<span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        mHwc.mEventHandler.onVSyncReceived(<span class="number">0</span>, next_vsync);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//让系统循环调用此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何在指定的时间点产生信号呢？如代码所示，在每次循环时采用休眠的方式主动等待至 vsync 时间点。</p>
<p>第一次执行时， next_vsync、mNextFakeVSync 都为 0，所以 sleep &lt; 0 进而会重新计算 next_vsync 为 now + period，也就是基于当前时间再等一个 vsync 周期。</p>
<p>后续每次循环也会重新修正 vsync 信号的时间，避免回调 onVSyncReceived 方法或其他耗时操作导致 vsync 信号时间变得越来越晚。</p>
<p>小结一下，vsync 信号在 SurfaceFlinger 进程的 HWComposer 类中生成，优先使用硬件源生成方式，如果硬件不支持则使用软件方式模拟生成。不管是硬件生成还是软件生成，都会通过相同的回调统一通知，最后交由 SurfaceFlinger 进一步处理。</p>
<h2 id="4-vsync-信号的分发"><a href="#4-vsync-信号的分发" class="headerlink" title="4. vsync 信号的分发"></a>4. vsync 信号的分发</h2><h3 id="1-SurfaceFlinger-gt-DispSync"><a href="#1-SurfaceFlinger-gt-DispSync" class="headerlink" title="1. SurfaceFlinger -&gt; DispSync"></a>1. SurfaceFlinger -&gt; DispSync</h3><p>vsync 信号由 HWComposer 类生成后，会回调 SurfaceFlinger.cpp 的 onVSyncReceived 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onVSyncReceived(int32_t type, nsecs_t timestamp) &#123;</span><br><span class="line">    mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mPrimaryDispSync 为 DispSync 类型，DispSync 在构造时开启了一个 DispSyncThread 工作线程，专门负责 vsync 信号的分发：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispSync::DispSync(<span class="keyword">const</span> <span class="keyword">char</span>* name) :</span><br><span class="line">        mName(name),</span><br><span class="line">        mRefreshSkipCount(<span class="number">0</span>),</span><br><span class="line">        mThread(new DispSyncThread(name)) &#123;</span><br><span class="line">    mThread-&gt;run(<span class="string">"DispSync"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看 DispSync 的 addResyncSample 方法是如何处理 vsync 信号的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DispSync::addResyncSample(nsecs_t timestamp) &#123;</span><br><span class="line">    mResyncSamples[idx] = timestamp; <span class="comment">//vsync 信号时间戳</span></span><br><span class="line">    updateModelLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DispSync::updateModelLocked() &#123;</span><br><span class="line">    mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DispSync 内部记录下 vsync 信号时间戳后，通过 updateModel 方法通知内部工作线程 DispSyncThread：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> updateModel(nsecs_t period, nsecs_t phase, nsecs_t referenceTime) &#123;</span><br><span class="line">    Mutex::Autolock lock(mMutex); <span class="comment">//锁</span></span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mCond.signal(); <span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意当前还处于 vsync 信号生成线程，若是软件生成则还处于 HWComposer 的 VSyncThread 线程，为了不影响 vsync 信号的生成工作，这里切换到另外的线程去分发。</p>
<p>具体而言，就是通过 mCond.signal() 方法通知 DispSyncThread 线程去进一步分发，DispSyncThread 的分发工作在其 threadLoop 方法中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">bool</span> threadLoop() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     &#123;</span><br><span class="line">        Mutex::Autolock lock(mMutex); <span class="comment">//锁</span></span><br><span class="line">        <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">            mCond.wait(mMutex); <span class="comment">//没 vsync 信号就阻塞</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="comment">// 收集注册了需要接受 vsync 信号的回调</span></span><br><span class="line">        callbackInvocations = gatherCallbackInvocationsLocked(now);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//分发回调</span></span><br><span class="line">         fireCallbackInvocations(callbackInvocations);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此 DispSync 中对 vsync 信号的分发工作执行完毕。</p>
<h3 id="2-DispSync-gt-DispSyncSource"><a href="#2-DispSync-gt-DispSyncSource" class="headerlink" title="2. DispSync -&gt; DispSyncSource"></a>2. DispSync -&gt; DispSyncSource</h3><p>在 DispSync 内部工作线程 DispSyncThread 中，对注册需要接受 vsync 信号的回调进行调用，完成了 vsync 信号分发工作。</p>
<p>那具体是谁注册了监听？是谁需要进一步接受 vsync 信号呢？还是要从 DispSyncThread 的 threadLoop 方法入手，它通过 gatherCallbackInvocationsLocked 方法获取到当前已注册的监听，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(nsecs_t now) &#123;</span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;</span><br><span class="line">        CallbackInvocation ci;</span><br><span class="line">        ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line">        callbackInvocations.push(ci);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过 fireCallbackInvocations 方法回调了监听：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fireCallbackInvocations(<span class="keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;</span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DispSync 内部对监听进行了封装，我们只关注外部传来的 mCallback，其为 DispSync::Callback 类型。通过以上代码可以知道 mCallback 被记录在 mEventListeners 中，那只要再看下哪里将监听添加到 mEventListeners 中，就能知道到底是谁注册的监听了。</p>
<p>在 SurfaceFlinger 初始化时 DispSyncSource 与 DispSync(mPrimaryDispSync) 产生关联：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">    mEventThread = new EventThread(vsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">    mSFEventThread = new EventThread(sfVsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说 DispSyncSource 内部持有 DispSync，在 DispSyncSource 内部将监听注册到 DispSync 中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> setVSyncEnabled(<span class="keyword">bool</span> enable) &#123;</span><br><span class="line">    Mutex::Autolock lock(mVsyncMutex);</span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        status_t err = mDispSync-&gt;addEventListener(mName, mPhaseOffset,</span><br><span class="line">                static_cast&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status_t err = mDispSync-&gt;removeEventListener(</span><br><span class="line">                static_cast&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    mEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DispSyncSource 本身继承了 DispSync::Callback 接口，即直接将自身作为监听注册到 DispSync 中。</p>
<p>也就是说，在 DispSync 内部工作线程中通过 fireCallbackInvocations 分发 vsync 信号，实际上调用了 DispSyncSource 的 onDispSyncEvent 方法。</p>
<p>需要注意的是，SurfaceFlinger init 时创建了两个 DispSyncSource，分别是上层 app 和 surfaceFlinger 自身，为什么要分这两种呢？仅仅是代码上的逻辑分离吗？</p>
<p>仔细观察 SurfaceFlinger init 中对这两个 DispSyncSource 的构造入参，分别传入了 vsyncPhaseOffsetNs 和 sfVsyncPhaseOffsetNs，这是要实现 vsync 信号的错时分发，即不同时分发 vsync 信号给上层 app 和 surfaceFlinger。</p>
<h3 id="3-DispSyncSource-gt-EventThread"><a href="#3-DispSyncSource-gt-EventThread" class="headerlink" title="3. DispSyncSource -&gt; EventThread"></a>3. DispSyncSource -&gt; EventThread</h3><p>接着来看 DispSyncSource 的 onDispSyncEvent 方法是如何处理 vsync 信号的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> onDispSyncEvent(nsecs_t when) &#123;</span><br><span class="line">    sp&lt;VSyncSource::Callback&gt; callback;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock lock(mCallbackMutex);</span><br><span class="line">        callback = mCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        callback-&gt;onVSyncEvent(when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是一个 callBack 回调了出去，这个 callBack 又是谁呢？可以再看一下上面的 SurfaceFlinger init 方法，类似于 DispSyncSource 向 DispSync 注册监听，EventThread 构造时传入了 DispSyncSource，EventThread 向 DispSyncSource 注册了监听。</p>
<p>callBack 类型为 VSyncSource::Callback，而 EventThread 自身也实现了这个接口：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> EventThread : public Thread, private VSyncSource::Callback</span><br></pre></td></tr></table></figure>
<p>接着来看 EventThread 内部实现的 onVSyncEvent 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::onVSyncEvent(nsecs_t timestamp) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp; <span class="comment">//vsync 时间戳</span></span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">    mCondition.broadcast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意当前还处于 DispSync 的工作线程，这里将 vsync 信号记录到 DisplayEventReceiver::Event 类型的 mVSyncEvent 数组中后，通过 mCondition.broadcast() 通知 EventThread 工作线程去处理，即从 DispSync 工作线程切换到了 EventThread 工作线程。</p>
<p>下面来看 EventThread 的工作线程中是如何处理的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line">    <span class="keyword">const</span> size_t count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        status_t err = conn-&gt;postEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是通过返回 true 来实现线程无限循环调用 threadLoop 方法，其中比较关键的是 waitForEvent 方法，关键逻辑如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)&#123;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        检测 mVSyncEvent 数组中是否有 vsync 信号</span><br><span class="line">        如果有传递给 event 参数，并开始遍历所有注册的 connection</span><br><span class="line">        如果 connection.count &gt;= <span class="number">0</span>，就加到 signalConnections 中</span><br><span class="line">        <span class="keyword">if</span>(waitForVSync)&#123;</span><br><span class="line">            mCondition.waitRelative(mLock, timeout); <span class="comment">//休眠等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (signalConnections.isEmpty());</span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>梳理一下 EventThread 工作线程中的逻辑：通过 waitForEvent 方法进入休眠等待 vsync 信号，如果有 vsync 信号会唤醒，并将 vsync 信号传递给 event，返回 Connection，随后将 vsync 信号分发给了 Connection。</p>
<p>现在我们的关注点变为 EventThread::Connection，它是谁注册的？其 postEvent 方法又是如何进一步分发 vsync 信号的呢？</p>
<h3 id="4-Connection-gt-SurfaceFlinger"><a href="#4-Connection-gt-SurfaceFlinger" class="headerlink" title="4. Connection -&gt; SurfaceFlinger"></a>4. Connection -&gt; SurfaceFlinger</h3><p>依然聚焦于 vsync 的传递为脉络，接着来看 Connection 的 postEvent 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">status_t EventThread::Connection::postEvent(</span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t DisplayEventReceiver::sendEvents(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; dataChannel,</span><br><span class="line">        Event <span class="keyword">const</span>* events, size_t count)&#123;</span><br><span class="line">    <span class="keyword">return</span> BitTube::sendObjects(dataChannel, events, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t BitTube::sendObjects(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube,</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">const</span>* events, size_t count, size_t objSize)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vaddr = reinterpret_cast&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    ssize_t size = tube-&gt;write(vaddr, count*objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Connection 内部持有一个 BitTube，BitTube 是用来处理进程间通讯的机制，和管道类似，基于 SocketPair 封装实现。SocketPair 用来创建一对未命名、互相连接的套接字，套接字的一端可以进行读和写的操作，用来实现全双工的通讯。</p>
<p>在 Connection 中将 vsync 信号数据写入了 BitTube，那在哪里监听读呢？这就要分 SurfaceFlinger 与 app 两路了，首先来看 SurfaceFlinger 是如何接收的。再回到 SurfaceFlinger 的 init 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">    mEventThread = new EventThread(vsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">    mSFEventThread = new EventThread(sfVsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造完 SurfaceFlinger 的 EventThread 后，通过 setEventThread 方法将 EventThread 设置给 mEventQueue，mEventQueue 为 MessageQueue 类型，方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::setEventThread(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)&#123;</span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();</span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();</span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这下就全走通了，SurfaceFlinger 的消息队列监听了 Connection 中的 BitTube，当 vsync 信号在 EventThread 中分发给 Connection 写入 BitTube 后，SurfaceFlinger 的消息队列就能收到通知了。</p>
<p>接着来看 SurfaceFlinger 的 MessageQueue 如何进一步处理 vsync 消息，在 MessageQueue 的 setEventThread 方法中设置接受到 vsync 后回调 cb_eventReceiver 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::cb_eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    MessageQueue* queue = reinterpret_cast&lt;MessageQueue *&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cb_eventReceiver 进一步调用 eventReceiver 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::eventReceiver(<span class="keyword">int</span> <span class="comment">/*fd*/</span>, <span class="keyword">int</span> <span class="comment">/*events*/</span>) &#123;</span><br><span class="line">    ssize_t n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> INVALIDATE_ON_VSYNC</span></span><br><span class="line">                mHandler-&gt;dispatchInvalidate();</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                mHandler-&gt;dispatchRefresh();</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到读取出 vsync 信号数据后，只用到了 type 信息，然后通过 Handler 回调出去处理。</p>
<p>至此 vsync -&gt; SurfaceFlinger 的分发流程分析完毕。</p>
<h3 id="5-Connection-gt-app"><a href="#5-Connection-gt-app" class="headerlink" title="5. Connection -&gt; app"></a>5. Connection -&gt; app</h3><p>尽管 vsync 传递给 SurfaceFlinger 流程发生在同个进程，却使用了支持跨进程的 BitTube。为什么要使用 BitTube 呢？可以想到的一个优点是，可以与 vsync 信号传递给上层 app 进程的方式统一。</p>
<p>我们知道上层 app 会统一将 UI 刷新请求发给 Choreographer，Choreographer 会在下次 vsync 信号到来时真正执行 UI 绘制，下面通过源码来搞懂底层的 vsync 是如何传递至 Choreographer 的。  </p>
<p>Choreographer 中实际与 vsync 信号相关的逻辑在 DisplayEventReceiver 中，初始化 Choreographer 时会构造 DisplayEventReceiver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    mDisplayEventReceiver = <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DisplayEventReceiver 构造函数中会调用到 DisplayEventReceiver.java 的 nativeInit 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        WeakReference&lt;DisplayEventReceiver&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        MessageQueue messageQueue, <span class="keyword">int</span> vsyncSource)</span></span>;</span><br></pre></td></tr></table></figure>
<p>底层实现位于 android_view_DisplayEventReceiver.cpp 中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> jlong nativeInit(JNIEnv* env, </span><br><span class="line">        jclass clazz, </span><br><span class="line">        jobject receiverWeak, jobject messageQueueObj) &#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue);</span><br><span class="line">    status_t status = receiver-&gt;initialize();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造了一个 NativeDisplayEventReceiver，其继承自 DisplayEventReceiver，在后者的构造函数中，创建了关键的 IDisplayEventConnection binder 接口，建立与 SurfaceFlinger 通信的连接：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::DisplayEventReceiver() &#123;</span><br><span class="line">    <span class="comment">// ISurfaceComposer binder 接口</span></span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// IDisplayEventConnection binder 接口</span></span><br><span class="line">        mEventConnection = sf-&gt;createDisplayEventConnection();</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = mEventConnection-&gt;getDataChannel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要将 MessageQueue 传递下来呢？因为要借助 Android Handler 已有的功能，即基于内部 epoll 机制添加对某文件描述符事件的监听，上文传递给 SurfaceFlinger 的原理也是如此。</p>
<p>nativeInit 中构造 NativeDisplayEventReceiver 后调用了其 initialize 方法，内部便通过 Looper 添加了对文件描述符的监听：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventDispatcher::initialize() &#123;</span><br><span class="line">    <span class="keyword">int</span> rc = mLooper-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再回到上层的 Choreographer ，其通过 scheduleVsync 请求下一次的 vsync 信号，最终会调用到 DisplayEventReceiver 的 native 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(<span class="keyword">long</span> receiverPtr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>底层同样是在 android_view_DisplayEventReceiver.cpp 中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) &#123;</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">            reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">    receiver-&gt;scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用到 DisplayEventReceiver 的 requestNextVsync 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line">    mEventConnection-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到 mEventConnection 是一个 binder 接口，跨进程调用到 BnDisplayEventConnection，而后者的实现类就是 SurfaceFlinger 中的 EventThread：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> EventThread : public Thread, private VSyncSource::Callback &#123;</span><br><span class="line">    <span class="keyword">class</span> Connection : public BnDisplayEventConnection &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>所以会进一步调用到 EventThread 的 requestNextVsync 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::requestNextVsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mFlinger.resyncWithRateLimit();</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>;</span><br><span class="line">        mCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文对 EventThread 做过详细的分析，这里再贴一遍其工作线程的关键逻辑代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)&#123;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        检测 mVSyncEvent 数组中是否有 vsync 信号</span><br><span class="line">        如果有传递给 event 参数，并开始遍历所有注册的 connection</span><br><span class="line">        如果 connection.count &gt;= <span class="number">0</span>，就加到 signalConnections 中</span><br><span class="line">        <span class="keyword">if</span>(waitForVSync)&#123;</span><br><span class="line">            mCondition.waitRelative(mLock, timeout); <span class="comment">//休眠等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (signalConnections.isEmpty());</span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，在 requestNextVsync 中将 connection-&gt;count 置为 0 然后唤醒 EventThread，EventThread 被唤醒后会将 connection 加入要通知 vsync 的 signalConnections 中，随后与上文中分析过的逻辑一致，通过 BitTube+looper 进一步分发 vsync 信号。</p>
<p>值得注意的是，在 waitForEvent 中判断如果 connection-&gt;count 为 0，会将 count 置为 -1，这意味着 requestNextVsync 方法名副其实，只是一次性请求接受一次 vsync 信号而已，要再调用 requestNextVsync 才能再次接受 vsync 信号。</p>
<p>最后再来看 vsync 信号传递到 java 层的流程，vsync 消息到来通过 dispatchVsync 方法分发：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> DisplayEventDispatcher::handleEvent(<span class="keyword">int</span>, <span class="keyword">int</span> events, <span class="keyword">void</span>*) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又回到了与 java 层最接近的 android_view_DisplayEventReceiver.cpp 中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t <span class="keyword">id</span>, uint32_t count) &#123;</span><br><span class="line">   JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">   ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));</span><br><span class="line">   <span class="keyword">if</span> (receiverObj.get()) &#123;</span><br><span class="line">       env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">               gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, <span class="keyword">id</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jni 调用了上层 DisplayEventReceiver.java 的 dispatchVsync 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后进一步回调到 Choreographer 的 doFrame，执行 ViewRootImpl 传过来的 TraversalRunnable、调用 performTraversals 方法，由顶而下的执行界面绘制逻辑。</p>
<p>小结一下：vsync 信号分为 SurfaceFlinger、app 两路分发，这两路分别对应于一个 EventThread。当 vsync 信号到来时，会唤醒 EventThread 线程，然后 EventThread 通过注册到内部的 Connection 分发出去。Connection 进一步通过 BitTube 并使用消息机制 looper 监听 BitTube 的 fd，从而实现 vsync 的分发。</p>
<h1 id="3-UI-绘制流程"><a href="#3-UI-绘制流程" class="headerlink" title="3. UI 绘制流程"></a>3. UI 绘制流程</h1><h1 id="4-Surface-与-SurfaceFlinger"><a href="#4-Surface-与-SurfaceFlinger" class="headerlink" title="4. Surface 与 SurfaceFlinger"></a>4. Surface 与 SurfaceFlinger</h1>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yhaowa.gitee.io/yhaowa/f9fd2518/" data-id="ckicycdi800097bca5iho1hmg" class="article-share-link" data-share="baidu" data-title="开发编写的 View 控件，是怎么变成屏幕上图像的？">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/yhaowa/tags/surface/">surface</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/yhaowa/tags/vsync/">vsync</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/yhaowa/tags/window/">window</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/yhaowa/649d55e5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          Android Handler epoll 机制分析
        
      </div>
    </a>
  
  
    <a href="/yhaowa/52cb86d4/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Android 消息屏障与异步消息</div>
    </a>
  
</nav>

  
</article>

</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/Android/">Android</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/Framework/">Framework</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/深度学习/">深度学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/音视频/">音视频</a><span class="category-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/yhaowa/tags/ANativeWindow/" style="font-size: 10px;">ANativeWindow</a> <a href="/yhaowa/tags/Ashmem/" style="font-size: 10px;">Ashmem</a> <a href="/yhaowa/tags/Autolock/" style="font-size: 10px;">Autolock</a> <a href="/yhaowa/tags/BinderProxy/" style="font-size: 10px;">BinderProxy</a> <a href="/yhaowa/tags/BpBinder/" style="font-size: 10px;">BpBinder</a> <a href="/yhaowa/tags/BufferQueue/" style="font-size: 10px;">BufferQueue</a> <a href="/yhaowa/tags/COW/" style="font-size: 10px;">COW</a> <a href="/yhaowa/tags/Caffe/" style="font-size: 10px;">Caffe</a> <a href="/yhaowa/tags/FFmpeg/" style="font-size: 20px;">FFmpeg</a> <a href="/yhaowa/tags/Fmod/" style="font-size: 10px;">Fmod</a> <a href="/yhaowa/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/yhaowa/tags/Glide/" style="font-size: 10px;">Glide</a> <a href="/yhaowa/tags/Gralloc/" style="font-size: 10px;">Gralloc</a> <a href="/yhaowa/tags/IPCThreadState/" style="font-size: 10px;">IPCThreadState</a> <a href="/yhaowa/tags/LMK/" style="font-size: 10px;">LMK</a> <a href="/yhaowa/tags/Linux-IPC/" style="font-size: 10px;">Linux IPC</a> <a href="/yhaowa/tags/Linux-driver/" style="font-size: 10px;">Linux driver</a> <a href="/yhaowa/tags/Mutex/" style="font-size: 10px;">Mutex</a> <a href="/yhaowa/tags/OpenGL/" style="font-size: 12.5px;">OpenGL</a> <a href="/yhaowa/tags/ProcessState/" style="font-size: 10px;">ProcessState</a> <a href="/yhaowa/tags/RecycleView/" style="font-size: 12.5px;">RecycleView</a> <a href="/yhaowa/tags/Service-Manager/" style="font-size: 10px;">Service Manager</a> <a href="/yhaowa/tags/SoundTouch/" style="font-size: 10px;">SoundTouch</a> <a href="/yhaowa/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/yhaowa/tags/ams/" style="font-size: 10px;">ams</a> <a href="/yhaowa/tags/aop/" style="font-size: 10px;">aop</a> <a href="/yhaowa/tags/asm/" style="font-size: 10px;">asm</a> <a href="/yhaowa/tags/binder/" style="font-size: 15px;">binder</a> <a href="/yhaowa/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/yhaowa/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/yhaowa/tags/h264/" style="font-size: 10px;">h264</a> <a href="/yhaowa/tags/handler/" style="font-size: 12.5px;">handler</a> <a href="/yhaowa/tags/ijkplayer/" style="font-size: 15px;">ijkplayer</a> <a href="/yhaowa/tags/kotlin/" style="font-size: 10px;">kotlin</a> <a href="/yhaowa/tags/log/" style="font-size: 10px;">log</a> <a href="/yhaowa/tags/mmap/" style="font-size: 12.5px;">mmap</a> <a href="/yhaowa/tags/plugin/" style="font-size: 10px;">plugin</a> <a href="/yhaowa/tags/service/" style="font-size: 10px;">service</a> <a href="/yhaowa/tags/startActivity/" style="font-size: 10px;">startActivity</a> <a href="/yhaowa/tags/surface/" style="font-size: 10px;">surface</a> <a href="/yhaowa/tags/vsync/" style="font-size: 10px;">vsync</a> <a href="/yhaowa/tags/window/" style="font-size: 12.5px;">window</a> <a href="/yhaowa/tags/wms/" style="font-size: 10px;">wms</a> <a href="/yhaowa/tags/侧滑菜单/" style="font-size: 12.5px;">侧滑菜单</a> <a href="/yhaowa/tags/内部类/" style="font-size: 10px;">内部类</a> <a href="/yhaowa/tags/刘海屏适配/" style="font-size: 10px;">刘海屏适配</a> <a href="/yhaowa/tags/单例/" style="font-size: 10px;">单例</a> <a href="/yhaowa/tags/并发编程/" style="font-size: 10px;">并发编程</a> <a href="/yhaowa/tags/开发模式/" style="font-size: 10px;">开发模式</a> <a href="/yhaowa/tags/总结/" style="font-size: 10px;">总结</a> <a href="/yhaowa/tags/悬浮窗/" style="font-size: 10px;">悬浮窗</a> <a href="/yhaowa/tags/比特率/" style="font-size: 10px;">比特率</a> <a href="/yhaowa/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/yhaowa/tags/虚拟内存/" style="font-size: 10px;">虚拟内存</a> <a href="/yhaowa/tags/读书笔记/" style="font-size: 17.5px;">读书笔记</a> <a href="/yhaowa/tags/采样率/" style="font-size: 10px;">采样率</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/yhaowa/649d55e5/">Android Handler epoll 机制分析</a>
          </li>
        
          <li>
            <a href="/yhaowa/f9fd2518/">开发编写的 View 控件，是怎么变成屏幕上图像的？</a>
          </li>
        
          <li>
            <a href="/yhaowa/52cb86d4/">Android 消息屏障与异步消息</a>
          </li>
        
          <li>
            <a href="/yhaowa/d55eb6b/">Java 并发编程知识点总结</a>
          </li>
        
          <li>
            <a href="/yhaowa/a5b629de/">Android 方法插桩 plugin 开发实践</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/yhaolpz" target="_blank">我的「GitHub」</a>
          </li>
        
          <li>
            <a href="http://blog.csdn.net/yhaolpz" target="_blank">我的「CSDN」</a>
          </li>
        
          <li>
            <a href="https://moonshoter.github.io/" target="_blank">Moonshot</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Ahab<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/yhaowa/" class="mobile-nav-link">首页</a>
  
    <a href="/yhaowa/archives" class="mobile-nav-link">归档</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/yhaowa/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/yhaowa/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/yhaowa/fancybox/jquery.fancybox.css">
  <script src="/yhaowa/fancybox/jquery.fancybox.pack.js"></script>



<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/yhaowa/js/script.js"></script>

</div>
</body>
</html>
