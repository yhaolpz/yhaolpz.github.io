
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>细读《深入理解-Android-内核设计思想》（六）GUI 系统 [上] | what is your main focus for today?</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="GUI 系统综述 BufferQueue 与图像数据流 Gralloc ANativeWindow FrameBufferNativeWindow FramebufferSurface 最后">
<meta name="keywords" content="BufferQueue,GUI,ANativeWindow,Gralloc">
<meta property="og:type" content="article">
<meta property="og:title" content="细读《深入理解-Android-内核设计思想》（六）GUI 系统 [上]">
<meta property="og:url" content="http://yhaowa.gitee.io/yhaowa/38614e33/index.html">
<meta property="og:site_name" content="what is your main focus for today?">
<meta property="og:description" content="GUI 系统综述 BufferQueue 与图像数据流 Gralloc ANativeWindow FrameBufferNativeWindow FramebufferSurface 最后">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yhaowa.gitee.io/yhaowa/img/ape_fwk_graphics.png">
<meta property="og:image" content="http://yhaowa.gitee.io/yhaowa/img/bufferqueue.png">
<meta property="og:image" content="http://yhaowa.gitee.io/yhaowa/img/Gralloc.jpg">
<meta property="og:updated_time" content="2020-12-06T09:18:58.311Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="细读《深入理解-Android-内核设计思想》（六）GUI 系统 [上]">
<meta name="twitter:description" content="GUI 系统综述 BufferQueue 与图像数据流 Gralloc ANativeWindow FrameBufferNativeWindow FramebufferSurface 最后">
<meta name="twitter:image" content="http://yhaowa.gitee.io/yhaowa/img/ape_fwk_graphics.png">
  
    <link rel="alternative" href="/atom.xml" title="what is your main focus for today?" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/yhaowa/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head></html>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/yhaowa/" id="logo">what is your main focus for today?</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/yhaowa/">首页</a>
        
          <a class="main-nav-link" href="/yhaowa/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yhaowa.gitee.io/yhaowa">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-细读《深入理解-Android-内核设计思想》（六）GUI 系统 上" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/yhaowa/38614e33/" class="article-date">
  <time datetime="2020-05-17T09:37:42.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/yhaowa/categories/Framework/">Framework</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      细读《深入理解-Android-内核设计思想》（六）GUI 系统 [上]
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<ol>
<li>GUI 系统综述</li>
<li>BufferQueue 与图像数据流</li>
<li>Gralloc</li>
<li>ANativeWindow</li>
<li>FrameBufferNativeWindow</li>
<li>FramebufferSurface</li>
<li>最后</li>
</ol>
</blockquote>
<a id="more"></a>
<p><em>对冗余挑拣重点，对重点深入补充，输出结构清晰的精简版</em></p>
<h2 id="GUI-系统综述"><a href="#GUI-系统综述" class="headerlink" title="GUI 系统综述"></a>GUI 系统综述</h2><p>GUI（Graphical User Interface）即图形用户界面，官方架构图如下：</p>
<p><img src="../img/ape_fwk_graphics.png" alt></p>
<p><strong>IMAGE STREAM PRODUCERS 图像流生产方</strong>：生成图形缓冲区以供消耗的任何内容，例如 OpenGL ES、Canvas 2D 和 mediaserver 视频解码器都是图像流生产方。</p>
<p><strong>IMAGE STREAM CONSUMERS 图像流消耗方</strong>：图像流最常见的消耗方是 SurfaceFlinger，该系统服务接收来自于多个源的数据缓冲区，组合它们，并将它们发送给显示设备。除了 SurfaceFlinger，OpenGL ES 应用也可以消耗图像流，例如相机应用会消耗相机预览图像流，另外非 GL 应用也可以消耗图像流，例如 ImageReader 类。SurfaceFlinger 使用 OpenGL 和 Hardware Composer 来合成一组 Surface。</p>
<p><strong>WindowManager</strong>：WindowManager 会控制 window 对象，window 是用于容纳视图对象的容器。window 对象由 Surface 对象提供支持。WindowManager 会监督生命周期、输入和聚焦事件、屏幕方向、转换、动画、位置、变形、Z 轴顺序等窗口事件。WindowManager 会将所有窗口元数据发送到 SurfaceFlinger，以便 SurfaceFlinger 可以使用这些数据合成 Surface。</p>
<p><strong>Surface</strong>：无论开发者使用什么渲染 API，一切内容都会渲染到 Surface 上，Surface 即供 UI 应用程序绘制图像的 “画板”，承载应用要渲染的图像数据。应用端可以使用 OpenGL ES 、Vulkan 或 Canvas API 渲染到 Surface 上。</p>
<p><strong>Hardware Composer 硬件混合渲染器(HWC)</strong>：用于确定组合缓冲区的最有效方式，作为 HAL 硬件抽象层，其实现是基于特定设备的，通常由屏幕硬件设备制造商 (OEM) 完成。SurfaceFlinger 在收集可见层的所有缓冲区后，便会询问 HWC 应如何进行合成。如果 HWC 将层合成类型标记为客户端合成，则 SurfaceFlinger 会合成这些层，然后 SurfaceFlinger 会将输出缓冲区传递给 HWC。</p>
<p><strong>Gralloc</strong>：包括 fb 和 gralloc 两个设备，fb 负责打开内核中的 FrameBuffer、初始化配置，并提供了 post、setSwapInterval 等操作接口；gralloc 负责管理帧缓冲区的分配和释放。作为 HAL，上层都会通过 Gralloc 来访问内核显示设备的帧缓冲区。</p>
<h2 id="BufferQueue-与图像数据流"><a href="#BufferQueue-与图像数据流" class="headerlink" title="BufferQueue 与图像数据流"></a>BufferQueue 与图像数据流</h2><p>图像流由生产方流向消耗方，这种典型的生产者-消费者模型都是需要一个缓冲区队列的，BufferQueue 就是这个队列，它将图像流生产方与消耗方结合在一起，并且可以调解图像流从生产方到消耗方的固定周期。</p>
<p><img src="../img/bufferqueue.png" alt></p>
<p>如图，生产方通过 dequeue 向 BufferQueue 申请空闲的缓冲区，将图像数据存放进去，然后通过 queue 移交给 BufferQueue。消耗方通过 acquire 从 BufferQueue 中获取图像数据缓冲区，然后进行合成显示或处理后，再将缓冲区交还给 BufferQueue。</p>
<p>对应到显示场景，应用程序作为生产方将图像数据交给 BufferQueue；SurfaceFlinger 则作为消耗方从 BufferQueue 中取出来，然后合成图像数据。</p>
<h2 id="Gralloc"><a href="#Gralloc" class="headerlink" title="Gralloc"></a>Gralloc</h2><p>FrameBuffer 是 Linux 内核中图像硬件的抽象描述，是一块包含屏幕显示信息的缓冲区。FrameBuffer 对上层提供了统一的显示驱动，设备节点为 /dev/graphics/fb<em> 或 /dev/fb</em>，其中 fb0 标示第一个 Monitor，当前系统实现中只用到了一个显示屏。</p>
<p>Android 的各个子系统通常不会直接使用硬件的内核驱动，而是通过 HAL 层间接使用。显示系统也是如此，上层统一通过 HAL 层的 Gralloc 来操作内核的帧缓冲区。</p>
<p>先来看 Gralloc 模块的加载，它是在 FramebufferNativeWindow（OpenGL ES 的本地窗口之一，下面还会提到）的构造函数中加载的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/ui/FramebufferNativeWindow.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_MODULE_ID <span class="meta-string">"gralloc"</span></span></span><br><span class="line"></span><br><span class="line">framebufferNativeWindow::framebufferNativeWindow() </span><br><span class="line">    : BASE(),fbDev(<span class="number">0</span>),grDev(<span class="number">0</span>),mUpdateOnDemand(<span class="literal">false</span>)&#123;</span><br><span class="line">    hw_module_t <span class="keyword">const</span>* module;</span><br><span class="line">    <span class="comment">//加载 Gralloc 模块</span></span><br><span class="line">    <span class="keyword">if</span>(hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module) == <span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        err = framebuffer_open(module, &amp;fbDev); <span class="comment">//打开 fb 设备</span></span><br><span class="line">        err = gralloc_open(module, &amp;grDev); <span class="comment">//打开 gralloc 设备</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>hw_get_module 函数是上层加载 HAL 库的统一入口，不论是哪个硬件厂商提供的 HAL 库，都是通过此函数来加载的。hw_get_module 方法会在指定的路径下查找与 GRALLOC_HARDWARE_MODULE_ID 匹配的库，默认会使用 Android 原生态的实现：gralloc.default.so，此 so 主要由 gralloc.cpp，framebuffer.cpp，mapper.cpp 三个源文件编译生成。</p>
<p>加载 Gralloc 后，会分别打开 fb（frameBuffer） 和 gralloc（gpu）设备，framebuffer_open 和 gralloc_open 最终都会调用到 gralloc.cpp 的 gralloc_device_open 方法，只不过传入的设备名不一样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_FB0 <span class="meta-string">"fb0"</span> <span class="comment">//fb 设备名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_GPU0 <span class="meta-string">"gpu0"</span> <span class="comment">//gralloc 设备名</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hardware/libhardware/modules/gralloc/gralloc.cpp</span></span><br><span class="line"><span class="keyword">int</span> gralloc_device_open(<span class="keyword">const</span> hw_module_t* module, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span><br><span class="line">                            hw_device_t** device)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>书中分析了 fb 及 gralloc 设备的打开过程源码，本文不再分析，源码见：<a href="http://androidxref.com/7.0.0_r1/xref/hardware/libhardware/modules/gralloc/gralloc.cpp#gralloc_device_open" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/hardware/libhardware/modules/gralloc/gralloc.cpp#gralloc_device_open</a> 。直接来看 fb 及 gralloc 设备的主要功能：</p>
<p><img src="../img/Gralloc.jpg" alt></p>
<p>gralloc 设备比较简单，主要负责图形缓冲区的分配与释放。下面来看下 fb 设备的方法说明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 buffer 数据 post 到显示屏上，要求 buffer 必须与屏幕尺寸一致,</span></span><br><span class="line"><span class="comment">//并且没有被 locked。这样 buffer 内容将在下一次 VSYNC 中被显示出来</span></span><br><span class="line"><span class="keyword">int</span>(*post)(<span class="keyword">struct</span> framebuffer_device_t* dev, buffer_handle_t buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置两个缓冲区交换的时间间隔</span></span><br><span class="line"><span class="keyword">int</span>(*setSwapInterval)(<span class="keyword">struct</span> framebuffer_device_t* window, <span class="keyword">int</span> interval);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置刷新区域，需要 framebuffer 驱动支持 update-on-demand。</span></span><br><span class="line"><span class="comment">//也就是说，在这个区域外的数据很可能被认为是无效的</span></span><br><span class="line"><span class="keyword">int</span>(*setUpdateRect)(<span class="keyword">struct</span> framebuffer_device_t* window, </span><br><span class="line">                        <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br></pre></td></tr></table></figure>
<h2 id="ANativeWindow"><a href="#ANativeWindow" class="headerlink" title="ANativeWindow"></a>ANativeWindow</h2><p>Android 的 GUI 基于 OpenGL ES，而 OpenGL ES 是跨平台的，并不是针对某一个特定的操作系统平台设计的。这就需要一个本地窗口来适配特定的系统环境，充当 OpenGL ES 与特定系统的中介。</p>
<p>EGLNativeWindowType 是 EGL 中定义的平台相关类型，它在不同系统中对应的是不同的数据类型，而在 Android 中对应的是 ANativeWindow 指针：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//framework/native/opengl/include/egl/Eglplatform.h //Android 系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__ANDROID__) || defined(ANDROID)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ANativeWindow;</span><br><span class="line"><span class="keyword">struct</span> egl_native_pixmap_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ANativeWindow*           EGLNativeWindowType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> egl_native_pixmap_t*     EGLNativePixmapType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>*                           EGLNativeDisplayType;</span><br></pre></td></tr></table></figure>
<p>ANativeWindow 结构如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ANativeWindow&#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    <span class="keyword">int</span>   minSwapInterval; <span class="comment">//支持的最小交换间隔时间</span></span><br><span class="line">    <span class="keyword">int</span>   maxSwapInterval; <span class="comment">//支持的最大交换间隔时间</span></span><br><span class="line">    <span class="keyword">float</span> xdpi; <span class="comment">//水平方向的密度，以 dp 为单位</span></span><br><span class="line">    <span class="keyword">float</span> ydpi; <span class="comment">//竖直方向的密度，以 dp 为单位</span></span><br><span class="line">    intptr_t    oem[<span class="number">4</span>]; <span class="comment">//为 OEM 定制驱动所保留的空间</span></span><br><span class="line">    <span class="comment">//设置交换间隔时间</span></span><br><span class="line">    <span class="keyword">int</span> (*setSwapInterval)(<span class="keyword">struct</span> ANativeWindow* window, <span class="keyword">int</span> interval);</span><br><span class="line">    <span class="comment">//申请一个 buffer，即出队一个空闲缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> (*dequeueBuffer)(<span class="keyword">struct</span> ANativeWindow* window, </span><br><span class="line">                        <span class="keyword">struct</span> ANativeWindowBuffer** buffer);</span><br><span class="line">    <span class="comment">//当 EGL 渲染完一块 buffer 后，调用此接口来 unlock 和 post buffer</span></span><br><span class="line">    <span class="keyword">int</span> (*queueBuffer)(<span class="keyword">struct</span> ANativeWindow* window, </span><br><span class="line">                        <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="comment">//取消一个已经 dequeued 的 buffer</span></span><br><span class="line">    <span class="keyword">int</span> (*cancelBuffer)(<span class="keyword">struct</span> ANativeWindow* window, </span><br><span class="line">                        <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="comment">//用于向本地窗口查询相关信息</span></span><br><span class="line">    <span class="keyword">int</span> (*query)(<span class="keyword">const</span> <span class="keyword">struct</span> ANativeWindow* window, <span class="keyword">int</span> what, <span class="keyword">int</span>* value);</span><br><span class="line">    <span class="comment">//用于执行本地窗口支持的各种操作，比如</span></span><br><span class="line">    <span class="comment">//NATIVE_WINDOW_SET_CROP、NATIVE_WINDOW_SET_BUFFER_COUNT 等等</span></span><br><span class="line">    <span class="keyword">int</span> (*perform)(<span class="keyword">struct</span> ANativeWindow* window, <span class="keyword">int</span> operation, ... );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从 ANativeWindow 的结构可以看出，它更像是一份协议，规定了一个本地窗口的形态和功能。FrameBufferNativeWindow 和 Surface 都履行了这份协议，可以看作 ANativeWindow 的两个实现。</p>
<h2 id="FrameBufferNativeWindow"><a href="#FrameBufferNativeWindow" class="headerlink" title="FrameBufferNativeWindow"></a>FrameBufferNativeWindow</h2><p>在介绍 Gralloc 时提到 Gralloc 设备是在 FrameBufferNativeWindow 的构造函数中打开的，这代表 FrameBufferNativeWindow 可以直接通过 Gralloc 操控屏幕帧内容的展示；在介绍 ANativeWindow 时提到 FrameBufferNativeWindow 实现了 ANativeWindow 接口，这代表上层可以通过 ANativeWindow 中定义的方法来调用 FrameBufferNativeWindow。</p>
<p>FrameBufferNativeWindow 的构造函数关键代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/ui/FramebufferNativeWindow.cpp</span></span><br><span class="line">framebufferNativeWindow::framebufferNativeWindow() </span><br><span class="line">    : BASE(),fbDev(<span class="number">0</span>),grDev(<span class="number">0</span>),mUpdateOnDemand(<span class="literal">false</span>)&#123;</span><br><span class="line">    hw_module_t <span class="keyword">const</span>* module;</span><br><span class="line">    <span class="comment">//加载 Gralloc 模块</span></span><br><span class="line">    <span class="keyword">if</span>(hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module) == <span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        err = framebuffer_open(module, &amp;fbDev); <span class="comment">//打开 fb 设备</span></span><br><span class="line">        err = gralloc_open(module, &amp;grDev); <span class="comment">//打开 gralloc 设备</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//初始化帧缓冲区相关的变量 </span></span><br><span class="line">        mNumBuffers = NUM_FRAME_BUFFERS; </span><br><span class="line">        mNumFreeBuffers = NUM_FRAME_BUFFERS;</span><br><span class="line">        mBufferHead = mNumBuffers<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mNumBuffers; i++)&#123; <span class="comment">//创建 NativeBuffer  </span></span><br><span class="line">            buffers[i] = new NativeBuffer(fbDev-&gt;width, fbDev-&gt;height, </span><br><span class="line">                                fbDev-&gt;format, GRALLOC_USAGE_HW_FB);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mNumBuffers; i++)&#123;<span class="comment">//为 NativeBuffer 分配空间  </span></span><br><span class="line">                err = grDev-&gt;alloc(grDev,fbDev-&gt;width, fbDev-&gt;height, </span><br><span class="line">                        fbDev-&gt;format, GRALLOC_USAGE_HW_FB, </span><br><span class="line">                        &amp;buffers[i]-&gt;handle, &amp;buffers[i]-&gt;stride);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化本地窗口 ANativeWindow 的相关属性  </span></span><br><span class="line">        const_cast&lt;uint32_t&amp;&gt;(ANativeWindow::flags) = fbDev-&gt;flags;   </span><br><span class="line">        const_cast&lt;<span class="keyword">float</span>&amp;&gt;(ANativeWindow::xdpi) = fbDev-&gt;xdpi;  </span><br><span class="line">        const_cast&lt;<span class="keyword">float</span>&amp;&gt;(ANativeWindow::ydpi) = fbDev-&gt;ydpi;  </span><br><span class="line">        const_cast&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::minSwapInterval) = fbDev-&gt;minSwapInterval;  </span><br><span class="line">        const_cast&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::maxSwapInterval) = fbDev-&gt;maxSwapInterval;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ALOGE(<span class="string">"Couldn't get gralloc module"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//本地窗口 ANativeWindow 的接口函数实现  </span></span><br><span class="line">    ANativeWindow::setSwapInterval = setSwapInterval;  </span><br><span class="line">    ANativeWindow::dequeueBuffer = dequeueBuffer;  </span><br><span class="line">    ANativeWindow::lockBuffer = lockBuffer;  </span><br><span class="line">    ANativeWindow::queueBuffer = queueBuffer;  </span><br><span class="line">    ANativeWindow::query = query;  </span><br><span class="line">    ANativeWindow::perform = perform;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameBufferNativeWindow 的构造函数主要做了以下工作：</p>
<ol>
<li>加载 Gralloc 模块，分别打开 fb 和 gralloc 设备</li>
<li>根据 fb 设备描述来初始化 FrameBufferNativeWindow，包括申请缓冲区及初始化本地窗口属性值</li>
<li>根据 FrameBufferNativeWindow 的实现来填充 ANativeWindow 中的”协议”</li>
</ol>
<p>可以看到帧缓冲区的数量为 mNumBuffers，FrameBufferNativeWindow 对应的是 1 个真实的物理屏幕，那为什么要准备多个 buffer 呢？这就是所谓的双缓冲/多缓冲技术，至少 2 个buffer，一个为 screen-buffer（用户直接看到的东西），一个为 off-screen-buffer（即将呈现给用户的东西），通过 swap buffer 交替显示，避免屏幕撕裂现象，以保证用户任何时候看到的都是完整的画面。</p>
<p>再来看 FrameBufferNativeWindow 中另一个重要的 dequeueBuffer 函数，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window,</span><br><span class="line">        ANativeWindowBuffer** buffer)&#123;</span><br><span class="line">    <span class="comment">//将 ANativeWindow 强转为 FramebufferNativeWindow</span></span><br><span class="line">    FramebufferNativeWindow* <span class="keyword">self</span> = getSelf(window);</span><br><span class="line">    Mutex::Autolock _l(<span class="keyword">self</span>-&gt;mutex); <span class="comment">//函数执行结束后自动释放锁</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//计算 mBufferHead，超出 mNumBuffers 时重指向 0 循环</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="keyword">self</span>-&gt;mBufferHead++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;mBufferHead &gt;= <span class="keyword">self</span>-&gt;mNumBuffers)</span><br><span class="line">        <span class="keyword">self</span>-&gt;mBufferHead = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//如果当前没有空闲的 buffer，即 mNumFreeBuffers = 0，则睡眠等待 buffer 的释放</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">self</span>-&gt;mNumFreeBuffers) &#123;</span><br><span class="line">        <span class="keyword">self</span>-&gt;mCondition.wait(<span class="keyword">self</span>-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存在了空闲 buffer 线程被唤醒，由于此时要申请一块 buffer，因此空闲 buffer 数减 1</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;mNumFreeBuffers--;</span><br><span class="line">    <span class="comment">// 保存当前申请的 buffer 在缓冲区数组中的索引位置</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;mCurrentBufferIndex = index;</span><br><span class="line">    <span class="comment">// 得到 buffer 数组中的 NativeBuffer 对象指针</span></span><br><span class="line">    *buffer = <span class="keyword">self</span>-&gt;buffers[index].get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dequeueBuffer 函数就是从 FramebufferNativeWindow 创建的缓冲区队列中取出一块空闲可用的 buffer，如果当前缓冲区队列中没有空闲的 buffer，则当前线程阻塞等待，等待其他线程释放图形缓冲区。</p>
<p>mNumFreeBuffers 用来描述可用的空闲 buffer 个数，mBufferHead 指向下一次申请的图形 buffer 的位置。由于是循环利用缓冲区，所以如果 mBufferHead 的值超过 mNumBuffers，就需要置 0。</p>
<p>再来看与之对应的 queueBuffer 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> FramebufferNativeWindow::queueBuffer(ANativeWindow* window, </span><br><span class="line">                    ANativeWindowBuffer* buffer)&#123;</span><br><span class="line">    FramebufferNativeWindow* <span class="keyword">self</span> = getSelf(window);</span><br><span class="line">    Mutex::Autolock _l(<span class="keyword">self</span>-&gt;mutex);</span><br><span class="line">    framebuffer_device_t* fb = <span class="keyword">self</span>-&gt;fbDev;</span><br><span class="line">    buffer_handle_t handle = static_cast&lt;NativeBuffer*&gt;(buffer)-&gt;handle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = <span class="keyword">self</span>-&gt;mCurrentBufferIndex;</span><br><span class="line">    <span class="comment">//调用 fb 设备的 post 函数将绘制好的 buffer 渲染到 framebuffer</span></span><br><span class="line">    <span class="keyword">int</span> res = fb-&gt;post(fb, handle);</span><br><span class="line">    <span class="keyword">self</span>-&gt;front = static_cast&lt;NativeBuffer*&gt;(buffer);</span><br><span class="line">    <span class="comment">//当前 buffer 已经渲染完，将当前 buffer 入列，从而可以被申请</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;mNumFreeBuffers++;</span><br><span class="line">    <span class="comment">//唤醒申请 buffer 被阻塞等待的线程，表示已有空闲 buffer 可以被申请</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;mCondition.broadcast();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将调用 fb 设备的 post 方法将 buffer 渲染到屏幕上，然后修改空闲 buffer 个数，最后唤醒正在申请图形 buffer 出列却因无空闲 buffer 而睡眠的线程。</p>
<h2 id="FramebufferSurface"><a href="#FramebufferSurface" class="headerlink" title="FramebufferSurface"></a>FramebufferSurface</h2><p>Android 4.2 版本后不再使用 FramebufferNativeWindow，随着版本的升级，相关的代码一直在变动，从 FramebufferNativeWindow 到 SurfaceTextureClient，再到 FramebufferSurface… 变动历史可参考：<a href="https://www.cnblogs.com/bbqzsl/p/7826141.html" target="_blank" rel="noopener">https://www.cnblogs.com/bbqzsl/p/7826141.html</a> 。</p>
<p>本以为 FramebufferSurface 已经稳定，可发现即使是 FramebufferSurface，在 7.0 和 9.0 版本上的实现也不相同。这里就不再纠结各版本的 API 变动，只对比下 FramebufferNativeWindow 与 FramebufferSurface 的送显逻辑。</p>
<p>FramebufferNativeWindow 被 FramebufferSurface 代替后，原本 FramebufferNativeWindow 中的 fb 设备交由 HWComposer 管理，FramebufferSurface 中不再直接持有 fb 设备，而是通过 HWComposer 去控制屏幕显示。</p>
<p>对上层来说，FramebufferNativeWindow 与 FramebufferSurface 可以看作真实的物理屏幕，它们都直接或间接的与 fb 设备交互。所谓的 “上层”，一般就是指 SurfaceFlinger，在较早版本，它可以这样通过 FramebufferNativeWindow 将内容送显：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Android 2.3.7 版本</span></span><br><span class="line"><span class="comment">//frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="keyword">bool</span> SurfaceFlinger::handleBypassLayer()&#123;</span><br><span class="line">    sp&lt;Layer&gt; bypassLayer(mBypassLayer.promote());</span><br><span class="line">    <span class="keyword">if</span> (bypassLayer != <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; buffer(bypassLayer-&gt;getBypassBuffer());</span><br><span class="line">        <span class="keyword">if</span> (buffer!=<span class="number">0</span> &amp;&amp; (buffer-&gt;usage &amp; GRALLOC_USAGE_HW_FB)) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayHardware&amp; hw(graphicPlane(<span class="number">0</span>).displayHardware());</span><br><span class="line">            <span class="comment">//调用 DisplayHardware 送显</span></span><br><span class="line">            hw.postBypassBuffer(buffer-&gt;handle);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp</span></span><br><span class="line"><span class="keyword">void</span> DisplayHardware::init(uint32_t dpy)&#123;</span><br><span class="line">    <span class="comment">// FramebufferNativeWindow 封装在 DisplayHardware 中</span></span><br><span class="line">    mNativeWindow = new FramebufferNativeWindow();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t DisplayHardware::postBypassBuffer(<span class="keyword">const</span> native_handle_t* handle) <span class="keyword">const</span>&#123;</span><br><span class="line">   <span class="comment">//获取 FramebufferNativeWindow 中打开的 fb 设备</span></span><br><span class="line">   framebuffer_device_t *fbDev = (framebuffer_device_t *)mNativeWindow-&gt;getDevice();</span><br><span class="line">   <span class="comment">//调用 fb 设备送显</span></span><br><span class="line">   <span class="keyword">return</span> fbDev-&gt;post(fbDev, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面通过 FramebufferNativeWindow 送显的逻辑比较简单，调用链为： SurfaceFlinger -&gt; DisplayHardware -&gt; FramebufferNativeWindow -&gt; fb 设备 。</p>
<p>下面来看 FramebufferSurface 的送显逻辑，它便没那么直观了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Android 7.0</span></span><br><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::doDisplayComposition(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">        <span class="keyword">const</span> Region&amp; inDirtyRegion)&#123;</span><br><span class="line">    <span class="comment">// ...省略 doComposeSurfaces 等合成工作</span></span><br><span class="line">    <span class="comment">// 合成后通过 swap buffers 送显</span></span><br><span class="line">    hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp</span></span><br><span class="line"><span class="keyword">void</span> FramebufferSurface::onFrameAvailable(<span class="keyword">const</span> BufferItem&amp; <span class="comment">/* item */</span>) &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    status_t err = nextBuffer(buf, acquireFence);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用 HWComposer</span></span><br><span class="line">    err = mHwc.fbPost(mDisplayType, acquireFence, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer_hwc1.cpp</span></span><br><span class="line"><span class="keyword">int</span> HWComposer::fbPost(int32_t <span class="keyword">id</span>,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; acquireFence, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> setFramebufferTarget(<span class="keyword">id</span>, acquireFence, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acquireFence-&gt;waitForever(<span class="string">"HWComposer::fbPost"</span>);</span><br><span class="line">        <span class="comment">//调用 fb 设备送显</span></span><br><span class="line">        <span class="keyword">return</span> mFbDev-&gt;post(mFbDev, buffer-&gt;handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会有疑问，swapBuffers 是怎么触发 FramebufferSurface 的 onFrameAvailable 回调的呢？它是通过生产者-消费者模式通知调用 onFrameAvailable 的，具体代码就不再列出，可以参考： <a href="https://www.cnblogs.com/ztguang/p/12645201.html" target="_blank" rel="noopener">https://www.cnblogs.com/ztguang/p/12645201.html</a> 。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Android 手机屏幕内容是怎么显示的，底层的显示原理到底是怎样的？强烈的好奇心驱使，开始 GUI 系统的学习，跟预想的一样，它很复杂、有难度。目前已大概学习了从 SurfaceFlinger 到物理屏幕的显示过程，后面继续由底而上，学习 SurfaceFlinger、Surface、Vsnyc、Choreographer 等，打通到 View 的 draw，相信就会有 “拨开云雾见天日” 的感觉了。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yhaowa.gitee.io/yhaowa/38614e33/" data-id="ckkxdyphh003totcaj1o0pa4i" class="article-share-link" data-share="baidu" data-title="细读《深入理解-Android-内核设计思想》（六）GUI 系统 [上]">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/yhaowa/tags/ANativeWindow/">ANativeWindow</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/yhaowa/tags/BufferQueue/">BufferQueue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/yhaowa/tags/GUI/">GUI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/yhaowa/tags/Gralloc/">Gralloc</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/yhaowa/a183dbba/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          如何绕过 Android 8.0 startService 限制？
        
      </div>
    </a>
  
  
    <a href="/yhaowa/c74cb1a3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">细读《深入理解 Android 内核设计思想》（五）Binder 机制 [下]</div>
    </a>
  
</nav>

  
</article>

</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/Android/">Android</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/Framework/">Framework</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/深度学习/">深度学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/yhaowa/categories/音视频/">音视频</a><span class="category-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/yhaowa/tags/ANativeWindow/" style="font-size: 10px;">ANativeWindow</a> <a href="/yhaowa/tags/APT/" style="font-size: 10px;">APT</a> <a href="/yhaowa/tags/Ashmem/" style="font-size: 10px;">Ashmem</a> <a href="/yhaowa/tags/Autolock/" style="font-size: 10px;">Autolock</a> <a href="/yhaowa/tags/BinderProxy/" style="font-size: 10px;">BinderProxy</a> <a href="/yhaowa/tags/BpBinder/" style="font-size: 10px;">BpBinder</a> <a href="/yhaowa/tags/BufferQueue/" style="font-size: 10px;">BufferQueue</a> <a href="/yhaowa/tags/COW/" style="font-size: 10px;">COW</a> <a href="/yhaowa/tags/Caffe/" style="font-size: 10px;">Caffe</a> <a href="/yhaowa/tags/FFmpeg/" style="font-size: 20px;">FFmpeg</a> <a href="/yhaowa/tags/Fmod/" style="font-size: 10px;">Fmod</a> <a href="/yhaowa/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/yhaowa/tags/Glide/" style="font-size: 10px;">Glide</a> <a href="/yhaowa/tags/Gralloc/" style="font-size: 10px;">Gralloc</a> <a href="/yhaowa/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/yhaowa/tags/IPCThreadState/" style="font-size: 10px;">IPCThreadState</a> <a href="/yhaowa/tags/JavaPoet/" style="font-size: 10px;">JavaPoet</a> <a href="/yhaowa/tags/LMK/" style="font-size: 10px;">LMK</a> <a href="/yhaowa/tags/Linux-IPC/" style="font-size: 10px;">Linux IPC</a> <a href="/yhaowa/tags/Linux-driver/" style="font-size: 10px;">Linux driver</a> <a href="/yhaowa/tags/Mutex/" style="font-size: 10px;">Mutex</a> <a href="/yhaowa/tags/OpenGL/" style="font-size: 12.5px;">OpenGL</a> <a href="/yhaowa/tags/ProcessState/" style="font-size: 10px;">ProcessState</a> <a href="/yhaowa/tags/RecycleView/" style="font-size: 12.5px;">RecycleView</a> <a href="/yhaowa/tags/Service-Manager/" style="font-size: 10px;">Service Manager</a> <a href="/yhaowa/tags/SoundTouch/" style="font-size: 10px;">SoundTouch</a> <a href="/yhaowa/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/yhaowa/tags/UDP/" style="font-size: 10px;">UDP</a> <a href="/yhaowa/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/yhaowa/tags/ViewModel/" style="font-size: 10px;">ViewModel</a> <a href="/yhaowa/tags/ams/" style="font-size: 10px;">ams</a> <a href="/yhaowa/tags/aop/" style="font-size: 10px;">aop</a> <a href="/yhaowa/tags/asm/" style="font-size: 10px;">asm</a> <a href="/yhaowa/tags/binder/" style="font-size: 15px;">binder</a> <a href="/yhaowa/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/yhaowa/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/yhaowa/tags/h264/" style="font-size: 10px;">h264</a> <a href="/yhaowa/tags/handler/" style="font-size: 12.5px;">handler</a> <a href="/yhaowa/tags/ijkplayer/" style="font-size: 15px;">ijkplayer</a> <a href="/yhaowa/tags/kotlin/" style="font-size: 10px;">kotlin</a> <a href="/yhaowa/tags/log/" style="font-size: 10px;">log</a> <a href="/yhaowa/tags/mmap/" style="font-size: 12.5px;">mmap</a> <a href="/yhaowa/tags/plugin/" style="font-size: 10px;">plugin</a> <a href="/yhaowa/tags/service/" style="font-size: 10px;">service</a> <a href="/yhaowa/tags/startActivity/" style="font-size: 10px;">startActivity</a> <a href="/yhaowa/tags/surface/" style="font-size: 10px;">surface</a> <a href="/yhaowa/tags/vsync/" style="font-size: 10px;">vsync</a> <a href="/yhaowa/tags/window/" style="font-size: 12.5px;">window</a> <a href="/yhaowa/tags/wms/" style="font-size: 10px;">wms</a> <a href="/yhaowa/tags/侧滑菜单/" style="font-size: 12.5px;">侧滑菜单</a> <a href="/yhaowa/tags/内部类/" style="font-size: 10px;">内部类</a> <a href="/yhaowa/tags/刘海屏适配/" style="font-size: 10px;">刘海屏适配</a> <a href="/yhaowa/tags/单例/" style="font-size: 10px;">单例</a> <a href="/yhaowa/tags/并发编程/" style="font-size: 10px;">并发编程</a> <a href="/yhaowa/tags/开发模式/" style="font-size: 10px;">开发模式</a> <a href="/yhaowa/tags/总结/" style="font-size: 10px;">总结</a> <a href="/yhaowa/tags/悬浮窗/" style="font-size: 10px;">悬浮窗</a> <a href="/yhaowa/tags/比特率/" style="font-size: 10px;">比特率</a> <a href="/yhaowa/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/yhaowa/tags/网络/" style="font-size: 10px;">网络</a> <a href="/yhaowa/tags/虚拟内存/" style="font-size: 10px;">虚拟内存</a> <a href="/yhaowa/tags/读书笔记/" style="font-size: 17.5px;">读书笔记</a> <a href="/yhaowa/tags/采样率/" style="font-size: 10px;">采样率</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/yhaowa/625d4c7c/">TCP/IP 网络协议知识点总结</a>
          </li>
        
          <li>
            <a href="/yhaowa/28077273/">Android APT 开发实践</a>
          </li>
        
          <li>
            <a href="/yhaowa/649d55e5/">Android Handler epoll 机制分析</a>
          </li>
        
          <li>
            <a href="/yhaowa/f9fd2518/">开发编写的 View 控件，是怎么变成屏幕上图像的？</a>
          </li>
        
          <li>
            <a href="/yhaowa/52cb86d4/">Android 消息屏障与异步消息</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/yhaolpz" target="_blank">我的「GitHub」</a>
          </li>
        
          <li>
            <a href="http://blog.csdn.net/yhaolpz" target="_blank">我的「CSDN」</a>
          </li>
        
          <li>
            <a href="https://moonshoter.github.io/" target="_blank">Moonshot</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Ahab<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/yhaowa/" class="mobile-nav-link">首页</a>
  
    <a href="/yhaowa/archives" class="mobile-nav-link">归档</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/yhaowa/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/yhaowa/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/yhaowa/fancybox/jquery.fancybox.css">
  <script src="/yhaowa/fancybox/jquery.fancybox.pack.js"></script>



<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/yhaowa/js/script.js"></script>

</div>
</body>
</html>
